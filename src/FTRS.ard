\import ARS
\import Data.Or
\import Equiv
\import Equiv.Univalence
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import Vector
\import Set.Fin

\module HighOrderTRS \where {
  -- | Family of symbols (functional or metavariables)
  \func Signature (Sort : \Set) => \Pi (parameters : SomeVector Sort) (returnType : Sort) -> \Set

  \func Constant {Sort : \Set} (S : Signature Sort) (returnType : Sort): \Set => S svnil returnType

  -- | This tuple of sets occurs in every term. It is rarely changes, so it may reduce amount of code
  \record Environment
    | Sort : \Set
    | Symbol : Signature Sort
    | MetaVar : Signature Sort

  -- | Term of High-order TRS
  \data Term (env : Environment)
             (context : SomeVector env.Sort)
             (termSort : env.Sort) : \Set
    | var (index : Fin context.size) (termSort = context !! index) -- | Bound variable, appears after abstractions
    | metavar (parameters : SomeVector env.Sort) -- | Metavariable, used in substitutions
              (m : env.MetaVar parameters termSort)
              (choosing : \Pi (index : Fin parameters.size) -> Term env context (parameters !! index))
    | func (parameters : SomeVector env.Sort) -- | Functional symbol
           (f : env.Symbol parameters termSort)
           (choosing : \Pi (index : Fin parameters.size) -> Term env context (parameters !! index))
    | abs (s : env.Sort) (t : Term env (append s context) termSort) -- | Abstraction
    \where {
      -- | Checks if term `t` contains metavariable `v`
      \func \infix 4 in {env : Environment} {s' s'' : env.Sort}
                        {context metaparams : SomeVector env.Sort}
                        (v : MetaVar metaparams s'')
                        (t : Term env context s') : \Prop \elim t
        | var index p => Empty
        | metavar (parameters : SomeVector env.Sort) m choosing =>
          (\Sigma (p : metaparams = parameters) (s=s' : s'' = s') (m = (transport2 MetaVar p s=s' v)))
            ||
          (\Sigma (n : Fin parameters.size) (v in choosing n))
        | func (parameters : SomeVector Sort) f choosing => ∃ (n : Fin parameters.size) (v in choosing n)
        | abs s t => v in t
    }

  \open Term

  -- | todo : constructing rewrite rules by terms is a candidate for meta
  \record RewriteRule {env : Environment} {s : env.Sort} (l : Term env svnil s) (r : Term env svnil s) {
    | r-is-not-generating : \Pi {s'' : env.Sort} {params : SomeVector Sort} (m : env.MetaVar params s'') (m in r) -> m in l
  }

  -- | Represents substitution of metavariables
  \func Substitution (env : Environment) : \Set =>
    \Pi {s : env.Sort} {params : SomeVector Sort} (env.MetaVar params s) -- given a metavariable
    ->  (\Pi {newContext : SomeVector env.Sort}
             (newTerms : \Pi (index : Fin params.size) -> Term env newContext (params !! index)) -- and set of new terms of suitable sort
    -> Term env newContext s -- we allowed to produce a new term that has provided terms among substituted
    )

  \func applySubstitution {env : Environment} {context : SomeVector env.Sort} {s : env.Sort} (t : Term env context s) (subst : Substitution env) : Term env context s \elim t
    | var index p => var index p
    | metavar parameters m choosing => subst m choosing
    | func parameters f choosing => func parameters f (\lam i => applySubstitution (choosing i) subst)
    | abs s1 t => abs s1 (applySubstitution t subst)

  -- | Allows to insert a context (denoted as white square in papers) in terms.
  \data SignatureWithWildcard {Sort : \Set} (wildcardSort : Sort) (MainSignature : Signature Sort) (context : SomeVector Sort) (returnSort : Sort) : \Set
    | main (MainSignature context returnSort)
    | wildcard (returnSort = wildcardSort)

  \func EnvironmentWithWildcards (env : Environment) (wildcardSort : env.Sort) : Environment \cowith
    | Sort => env.Sort
    | Symbol => SignatureWithWildcard wildcardSort env.Symbol
    | MetaVar => env.MetaVar

  \func replaceWildcards {Sort : \Set}
                         {env : Environment Sort}
                         {context-parameters : SomeVector env.Sort}
                         {context-sort wildcard-sort : env.Sort}
                         (C : Term (EnvironmentWithWildcards env wildcard-sort) context-parameters context-sort)
                         (t : Term env svnil wildcard-sort) : Term env context-parameters context-sort \elim C
    | var index p => var index p
    | metavar parameters' m choosing => metavar parameters' m (\lam i => replaceWildcards (choosing i) t)
    | func parameters' f choosing => \case \elim f \with {
      | main m => func parameters' m (\lam i => replaceWildcards (choosing i) t)
      | wildcard p => rewriteI (concat.concat-nil context-parameters) (enrich (transportInv (Term env svnil) p t) context-parameters)
    }
    | abs s t1 => abs s (replaceWildcards t1 t)
    \where {
      \func enrich {env : Environment} {s : env.Sort}
                   {existing-context : SomeVector env.Sort}
                   (t : Term env existing-context s)
                   (context : SomeVector env.Sort) : Term env (concat existing-context context) s \elim t
        | var index p => \let (a, b) => concat.concat-promotion existing-context context p \in var a b
        | metavar parameters m choosing => metavar parameters m (\lam i => enrich (choosing i) context)
        | func parameters f choosing => func parameters f (\lam i => enrich (choosing i) context)
        | abs s1 t => abs s1 (rewrite (concat.concat-distrib existing-context context s1) (enrich t context))
    }

  \truncated \data RewriteRelation {env : Environment}
                                   (set-of-rules : RewriteRule {env} -> \Prop)
                                   {s : env.Sort}
                                   {context : SomeVector env.Sort} (A : Term env context s) (B : Term env context s) : \Prop
    | term-rewriting (replacementSort : env.Sort)
                     (rule : RewriteRule {env} {replacementSort})
                     (set-of-rules rule)
                     (C : Term (EnvironmentWithWildcards env replacementSort) context s)
                     (subst : Substitution env)
                     (left-term : A = replaceWildcards C (applySubstitution rule.l subst))
                     (right-term : B = replaceWildcards C (applySubstitution rule.r subst))

  \class HighOrderTermRewritingSystem (env : Environment) (set-of-rules : RewriteRule {env} -> \Prop) \extends AbstractReductionSystem
    | A => \Sigma (context : SomeVector env.Sort) (sort : Sort) (Term env context sort)
    | ~> a b => \case \elim a, b \with {
      | (context, sort, A), (context', sort', B) => ∃ (p : context' = context) (q : sort' = sort) (RewriteRelation set-of-rules A (transport2 (Term env) p q B))
    }

  \class SimpleHighOrderTermRewritingSystem \extends HighOrderTermRewritingSystem, SimpleARS
}
