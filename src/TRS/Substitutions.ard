\import Data.List (++, ::, List, nil)
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.List

\func plain-identity {env : Environment} {context : List Sort} {meta-signature : MetaSignature Sort} : Substitution context context meta-signature =>
  \lam i => var i idp

\func plain-identity-effect {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort}
                            (t : Term env context s meta-signature) : Substitution.apply t plain-identity = t \elim t
  | var index p => \case \elim s, \elim p \with {
    | s, idp => idp
  }
  | metavar m choosing => pmap (metavar m) (ext (\lam index => plain-identity-effect (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => {?}))

\func append-context-left {env : Environment} {old-context new-context : List Sort} {meta-signature : MetaSignature Sort}
                          {additional-context : List Sort}
                          (subst : Substitution old-context new-context meta-signature)
                          (index : Fin (length (additional-context ++ old-context))) : Term env (additional-context ++ new-context) ((additional-context ++ old-context) !! index) meta-signature \elim additional-context, index
  | nil, index => subst index
  | :: a additional-context, zero => var zero idp
  | :: a additional-context, suc index => \let inner-shifting => append-context-left subst index
                                          \in weakening inner-shifting (sublist-skip SubList.identity)

\func weakening {env : Environment} {s' : Sort} {narrow-context wide-context : List Sort} {meta-signature : MetaSignature Sort}
                (t : Term env narrow-context s' meta-signature)
                (sublist : SubList narrow-context wide-context)
  : Term env wide-context s' meta-signature \elim t
  | var index p => \let (index', p') => recalculate-index sublist index p \in var index' p'
  | metavar m choosing => metavar m (\lam i1 => weakening (choosing i1) sublist)
  | func f choosing => func f (\lam i1 => weakening (choosing i1) (SubList.extend-left sublist))
  \where {
    \func recalculate-index {A : \Set} {a b : List A} {point : A} (sublist : SubList a b) (ind : Fin (length a)) (p : point = a !! ind) : \Sigma (ind' : Fin (length b)) (point = b !! ind') \elim a, b, sublist, ind, p
      | nil, r, sublist-trivial, (), p
      | :: x xs, :: y ys, sublist-match p sublist, zero, idp => (zero, p)
      | :: x xs, :: y ys, sublist-match p sublist, suc ind, idp => \let (ind', p') => recalculate-index sublist ind idp \in (suc ind', p')
      | l, :: y ys, sublist-skip sublist, ind, idp => \let (ind', p') => recalculate-index sublist ind idp \in (suc ind', p')
  }

\func extend-substitution-right {env : Environment} {left-context right-context some-context : List Sort} {meta-signature : MetaSignature Sort}
                                (sublist : SubList right-context some-context)
                                (chooser : Substitution left-context some-context meta-signature)
                                (j : Fin (length (left-context ++ right-context)))
  : Term env some-context ((left-context ++ right-context) !! j) meta-signature
\elim left-context, j
  | nil, j => \let (index, q) => produce-inner-term sublist j \in var index q
  | :: a narrow-context, zero => chooser zero
  | :: a narrow-context, suc j => extend-substitution-right sublist (\lam i => chooser (suc i)) j
  \where {
    \func produce-inner-term {env : Environment} {right-context some-context : List Sort} (sublist : SubList right-context some-context) (j : Fin (length right-context)) :
      \Sigma (ind : Fin (length some-context)) (right-context !! j = some-context !! ind) \elim right-context, some-context, sublist, j
      | :: x xs, :: y ys, sublist-match p sublist, zero => (0, p)
      | :: x xs, :: y ys, sublist-match p sublist, suc j => \let (ind, q) => produce-inner-term sublist j \in (suc ind, q)
      | l, :: y ys, sublist-skip sublist, j => \let (ind, q) => produce-inner-term sublist j \in (suc ind, q)
  }
