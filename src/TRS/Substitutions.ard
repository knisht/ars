\import Arith.Nat
\import Data.List (!!, ++, ++_nil, ::, List, length, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.List

\func plain-identity {env : Environment} {context : List Sort} {meta-signature : MetaSignature Sort} : Substitution context context meta-signature =>
  \lam i => var i idp

\func wide-identity {env : Environment} {context wide-context : List Sort} (sublist : SubList context wide-context) {meta-signature : MetaSignature Sort} : Substitution context wide-context meta-signature =>
  \lam i => weakening (var i idp) sublist

\func plain-identity-effect {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort}
                            (t : Term env context s meta-signature) : Substitution.apply t plain-identity = t \elim t
  | var index p => \case \elim s, \elim p \with {
    | s, idp => idp
  }
  | metavar m choosing => pmap (metavar m) (ext (\lam index => plain-identity-effect (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => rewrite append-context-right-to-identity.ext' (plain-identity-effect (choosing index))))

\func append-context-left
  {env : Environment} {old-context new-context : List Sort} {meta-signature : MetaSignature Sort}
  {additional-context : List Sort}
  (subst : Substitution old-context new-context meta-signature)
  (index : Fin (length (additional-context ++ old-context)))
  : Term env (additional-context ++ new-context) ((additional-context ++ old-context) !! index) meta-signature
\elim additional-context, index
  | nil, index => subst index
  | :: a additional-context, zero => var zero idp
  | :: a additional-context, suc index => weakening (append-context-left subst index) (sublist-skip SubList.identity)

\func append-context-right
  {env : Environment} {old-context new-context : List Sort} {meta-signature : MetaSignature Sort}
  {additional-context : List Sort}
  (subst : Substitution old-context new-context meta-signature)
  (index : Fin (length (old-context ++ additional-context)))
  : Term env (new-context ++ additional-context) ((old-context ++ additional-context) !! index) meta-signature
\elim old-context, index
  | nil, index => weakening (var index idp) (SubList.extend-right-single-left SubList.identity)
  | :: a old-context, zero => weakening (subst 0) (SubList.extend-right-single SubList.identity)
  | :: a old-context, suc index => append-context-right (\lam i => subst (suc i)) index
  \where {
    \func coerce-fin {n m : Nat} (i : Fin (n Nat.+ m)) (diff : i NatSemiring.< n) : Fin n \elim n, i, diff
      | suc n, 0, NatSemiring.zero<suc => 0
      | suc n, suc i, NatSemiring.suc<suc diff => suc (coerce-fin i diff)

    \func expand-fin {A : \Type} {a b : List A} (i : Fin (length a)) : Fin (length (a ++ b)) \elim a, i
      | :: a _, 0 => 0
      | :: _ _, suc i => suc (expand-fin i)

    \func expand-fin-late {A : \Type} {a b : List A} (i : Fin (length b)) : Fin (length (a ++ b)) \elim a
      | nil => i
      | :: a a1 => suc (expand-fin-late i)

    \func expand-fin-eq {A : \Type} {a b : List A} (i : Fin (length a)) : (a ++ b) !! (expand-fin i) = a !! i \elim a, i
      | :: a a1, 0 => idp
      | :: a a1, suc i => expand-fin-eq i

    \func expand-fin-eq-late {A : \Type} {a b : List A} (i : Fin (length b)) : (a ++ b) !! (expand-fin-late i) = b !! i \elim a
      | nil => idp
      | :: a a1 => expand-fin-eq-late i

    \func extension-over-shift  {env : Environment} {old-context new-context : List Sort} {meta-signature : MetaSignature Sort}
                                {additional-context : List Sort}
                                (subst : Substitution old-context new-context meta-signature)
                                (index : Fin (length (old-context)))
      : append-context-right subst (expand-fin index) =
    weakening (transport (Term env (new-context) __ meta-signature) (inv (expand-fin-eq {_} {_} {additional-context} index)) (subst index)) (SubList.extend-right-single SubList.identity) \elim old-context, index
      | :: a old-context, 0 => idp
      | :: a old-context, suc index => extension-over-shift (\lam i => subst (suc i)) index

    \func extension-over-shift-late
      {env : Environment} {old-context new-context : List Sort} {meta-signature : MetaSignature Sort}
      {additional-context : List Sort}
      (subst : Substitution old-context new-context meta-signature)
      (index : Fin (length (additional-context)))
      : append-context-right subst (expand-fin-late {_} {old-context} {additional-context} index) =
    weakening (var index (expand-fin-eq-late index)) (SubList.extend-right-single-left SubList.identity) \elim old-context
      | nil => idp
      | :: a old-context => extension-over-shift-late (\lam i => subst (suc i)) index

    \func partial-fin-induction
      {A : \Type} {a b : List A} (C : Fin (length (a ++ b)) -> \Type)
      (prefix : \Pi (i : Fin (length a)) -> C (expand-fin i))
      (suffix : \Pi (i : Fin (length b)) -> C (expand-fin-late i)) (index : Fin (length (a ++ b))) : C index =>
      \let decomposed => fin-decide index \in \case \elim decomposed \with {
        | inl (i, p) => rewrite p (prefix i)
        | inr (j, p) => rewrite p (suffix j)
      }

    \func fin-decide {A : \Type} {a b : List A} (index : Fin (length (a ++ b))) : (\Sigma (i : Fin (length a)) (index = expand-fin i)) `Or` (\Sigma (j : Fin (length b)) (index = expand-fin-late j)) \elim a, index
      | nil, index => inr (index, idp)
      | :: a a1, 0 => inl (0, idp)
      | :: a a1, suc index => \case (fin-decide index) \with {
        | inl (i, eq) => inl (suc i, pmap (fsuc) eq)
        | inr (j, eq) => inr (j, pmap (fsuc) eq)
      }

    \func fsuc {n : Nat} (x : Fin n) : Fin (suc n) => suc x
  }
    \func weakening {env : Environment} {s' : Sort} {narrow-context wide-context : List Sort} {meta-signature : MetaSignature Sort}
                (t : Term env narrow-context s' meta-signature)
                (sublist : SubList narrow-context wide-context)
  : Term env wide-context s' meta-signature \elim t
  | var index p => to-var (recalculate-index sublist index p)
  | metavar m choosing => metavar m (\lam i1 => weakening (choosing i1) sublist)
  | func f choosing => func f (\lam i1 => weakening (choosing i1) (SubList.extend-right sublist))
  \where {
    \func recalculate-index {A : \Set} {a b : List A} {point : A} (sublist : SubList a b) (ind : Fin (length a)) (p : point = a !! ind) : \Sigma (ind' : Fin (length b)) (point = b !! ind') \elim a, b, sublist, ind, p
      | nil, r, sublist-trivial, (), p
      | :: x xs, :: y ys, sublist-match p sublist, zero, idp => (zero, p)
      | :: x xs, :: y ys, sublist-match p sublist, suc ind, idp => \let (ind', p') => recalculate-index sublist ind idp \in (suc ind', p')
      | l, :: y ys, sublist-skip sublist, ind, idp => \let (ind', p') => recalculate-index sublist ind idp \in (suc ind', p')

    \func recalculate-index-over-identity {A : \Set} {a : List A} (ind : Fin (length a)) : recalculate-index SubList.identity ind idp = (ind, idp) \elim a, ind
      | :: a a1, zero => idp
      | :: a a1, suc ind => {?}

    \func recalculate-index-over-right-extension {A : \Set} {a b : List A} (ind : Fin (length a)) :
      \Sigma (eq : (a !! ind) = (a ++ b) !! append-context-right.expand-fin ind) (recalculate-index {A} {a} {a ++ b} (SubList.extend-right-single SubList.identity {b}) ind idp = (append-context-right.expand-fin {A} {a} {b} ind, eq)) \elim a, ind
      | :: a a1, 0 => (idp, idp)
      | :: a a1, suc ind => \let | (eq-custom, b-eq) => recalculate-index-over-right-extension {_} {a1} {b} ind
                                 | (ind', q') => recalculate-index (SubList.extend-right-single SubList.identity {b}) ind idp \in (eq-custom, rewrite b-eq idp)

      \func recalculate-index-over-left-extension {A : \Set} {a b : List A} (ind : Fin (length b)) :
               (recalculate-index {A} {b} {a ++ b} (SubList.extend-right-single-left SubList.identity {a}) ind (append-context-right.expand-fin-eq-late {_} {a} ind) = (append-context-right.expand-fin-late ind, idp)) \elim a
        | nil => (recalculate-index-over-identity ind)
        | :: a a1 => {?}
--          \let | b-eq => recalculate-index-over-left-extension {_} {a1} {b} ind
--                     \in (rewrite (recalc-lemma {A} {b} {a1} {_} {a} (SubList.extend-right-single-left SubList.identity) ind (append-context-right.expand-fin-eq-late ind)) {?})
        \where {
          \func recalc-lemma {A : \Set} {a b : List A} {point point' : A} (sublist : SubList a b) (ind : Fin (length a)) (eq : point = a !! ind) :
            recalculate-index {A} {a} {point' :: b} {point} (sublist-skip sublist) ind eq = (\let (ind', eq') => recalculate-index sublist ind eq \in (suc ind', eq')) \elim a, b, sublist, ind, eq
            | nil, b, sublist-trivial, (), eq
            | :: x a, :: y b, sublist-match p sublist, 0, idp => idp
            | :: x a, :: y b, sublist-match p sublist, suc ind, idp => idp
            | nil, :: y b, sublist-skip sublist, ind, idp => idp
            | :: a a1, :: y b, sublist-skip sublist, ind, idp => idp
        }
  }

\func extend-substitution-right
  {env : Environment} {left-context right-context some-context : List Sort} {meta-signature : MetaSignature Sort}
  (sublist : SubList right-context some-context)
  (chooser : Substitution left-context some-context meta-signature)
  (j : Fin (length (left-context ++ right-context)))
  : Term env some-context ((left-context ++ right-context) !! j) meta-signature
\elim left-context, j
  | nil, j => to-var (produce-inner-term sublist j)
  | :: a narrow-context, zero => chooser zero
  | :: a narrow-context, suc j => extend-substitution-right sublist (\lam i => chooser (suc i)) j
  \where {
    \func produce-inner-term {A : \Type} {right-context some-context : List A} (sublist : SubList right-context some-context) (j : Fin (length right-context)) :
      \Sigma (ind : Fin (length some-context)) (right-context !! j = some-context !! ind) \elim right-context, some-context, sublist, j
      | :: x xs, :: y ys, sublist-match p sublist, zero => (0, p)
      | :: x xs, :: y ys, sublist-match p sublist, suc j => \let (ind, q) => produce-inner-term sublist j \in (suc ind, q)
      | l, :: y ys, sublist-skip sublist, j => \let (ind, q) => produce-inner-term sublist j \in (suc ind, q)
  }

\func extend-substitution-left
  {env : Environment} {left-context right-context some-context : List Sort} {meta-signature : MetaSignature Sort}
  (sublist : SubList left-context some-context)
  (chooser : Substitution right-context some-context meta-signature)
  (j : Fin (length (left-context ++ right-context)))
  : Term env some-context ((left-context ++ right-context) !! j) meta-signature \elim left-context, j
  | nil, j => chooser j
  | :: a left-context, 0 => weakening (var 0 idp) sublist
  | :: a left-context, suc j => extend-substitution-left (SubList.shrink sublist) chooser j

\func to-var {env : Environment} {some-context : List Sort} {s : Sort} {msig : MetaSignature Sort} (sig : \Sigma (ind : Fin (length some-context)) (s = some-context !! ind))
  : Term env some-context s msig => var sig.1 sig.2

\func append-context-right-to-identity
  {env : Environment} {old-context : List Sort} {meta-signature : MetaSignature Sort}
  {additional-context : List Sort} (i : Fin (length (old-context ++ additional-context)))
  : append-context-right {_} {old-context} {_} {meta-signature} {additional-context} plain-identity i = plain-identity i =>
  append-context-right.partial-fin-induction
      (\lam i => append-context-right {_} {old-context} {_} {meta-signature} {additional-context} plain-identity i = plain-identity i)
      (\lam i1 => append-context-right.extension-over-shift plain-identity i1 *>
      (rewrite lem (\let | some-lemma => weakening.recalculate-index-over-right-extension {_} {_} {additional-context} i1
                    \in rewrite (pmap (to-var) some-lemma.2) (unfold (to-var, plain-identity) (lem2 (append-context-right.expand-fin i1) (some-lemma).1 idp (inv (append-context-right.expand-fin-eq i1)))))))
      (\lam i1 => append-context-right.extension-over-shift-late plain-identity i1 *> (pmap (to-var {env}) (weakening.recalculate-index-over-left-extension i1)))
      i
  \where {
    \func lem {env : Environment} {context context' : List Sort} {s s' : Sort} {meta-signature : MetaSignature Sort}
              (T : Term env context s meta-signature) (eq : s = s') (sublist : SubList context context')
      :
      weakening (transport (Term env context __ meta-signature) eq T) sublist = transport (Term env context' __ meta-signature) eq (weakening T sublist) \elim eq
      | idp => idp

    \func lem2  {env : Environment} {context : List Sort} {s s' : Sort} {meta-signature : MetaSignature Sort}
                (index : Fin (length context)) (eq : s = context !! index) (eq' : s' = context !! index) (eq'' : s = s')
      : transport (Term env context __ meta-signature) eq'' (var index eq)  = var index eq' \elim eq''
      | idp => pmap (var index) (Path.inProp eq eq')

    \func ext' {env : Environment} {old-context : List Sort} {meta-signature : MetaSignature Sort}
               {additional-context : List Sort} : (\lam (i : Fin (length (old-context ++ additional-context))) => append-context-right {_} {old-context} {_} {meta-signature} {additional-context} plain-identity i) = plain-identity =>
      ext append-context-right-to-identity
  }

