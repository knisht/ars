\import Arith.Nat
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.List
\import TRS.Union
\import TRS.Union.TopLevel
\import TRS.Utils

\func plain-identity {env : FSignature} {context : List Sort} {mc : MetaContext Sort} : Substitution context context mc =>
  \lam i => var i idp

\func wide-identity {env : FSignature} {context wide-context : List Sort} (sublist : SubList context wide-context) {mc : MetaContext Sort} : Substitution context wide-context mc =>
  \lam i => weakening (var i idp) sublist

\lemma plain-identity-effect {env : FSignature} {context : List Sort} {s : Sort} {mc : MetaContext Sort}
                             (t : Term env context s mc)
  : Substitution.apply t plain-identity = t \elim t
  | var index p => \case \elim s, \elim p \with {
    | s, idp => idp
  }
  | metavar m choosing => pmap (metavar m) (ext (\lam index => plain-identity-effect (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => rewrite append-context-right-to-identity.ext' (plain-identity-effect (choosing index))))

\func append-context-left
  {env : FSignature} {old-context new-context : List Sort} {mc : MetaContext Sort}
  {additional-context : List Sort}
  (subst : Substitution old-context new-context mc)
  (index : Fin (length (additional-context ++ old-context)))
  : Term env (additional-context ++ new-context) ((additional-context ++ old-context) !! index) mc
\elim additional-context, index
  | nil, index => subst index
  | :: a additional-context, zero => var zero idp
  | :: a additional-context, suc index => weakening (append-context-left subst index) (sublist-skip SubList.identity)

\func append-context-right
  {env : FSignature} {old-context new-context : List Sort} {mc : MetaContext Sort}
  (subst : Substitution old-context new-context mc)
  {additional-context : List Sort}
  (index : Fin (length (old-context ++ additional-context)))
  : Term env (new-context ++ additional-context) ((old-context ++ additional-context) !! index) mc
\elim old-context, index
  | nil, index => weakening (var index idp) (SubList.extend-left-single SubList.identity)
  | :: a old-context, zero => weakening (subst 0) (SubList.extend-right-single SubList.identity)
  | :: a old-context, suc index => append-context-right (\lam i => subst (suc i)) index

\lemma append-context-right-begin  {env : FSignature} {old-context new-context : List Sort} {mc : MetaContext Sort}
                                   {additional-context : List Sort}
                                   (subst : Substitution old-context new-context mc)
                                   (index : Fin (length (old-context)))
  : append-context-right subst (expand-fin index) =
weakening (transport (Term env (new-context) __ mc) (inv (expand-fin-eq {_} {_} {additional-context} index)) (subst index)) (SubList.extend-right-single SubList.identity) \elim old-context, index
  | :: a old-context, 0 => idp
  | :: a old-context, suc index => append-context-right-begin (\lam i => subst (suc i)) index

\lemma append-context-right-end
  {env : FSignature} {old-context new-context : List Sort} {mc : MetaContext Sort}
  {additional-context : List Sort}
  (subst : Substitution old-context new-context mc)
  (index : Fin (length (additional-context)))
  : append-context-right subst (expand-fin-late {_} {old-context} {additional-context} index) =
weakening (var index (expand-fin-eq-late index)) (SubList.extend-left-single SubList.identity) \elim old-context
  | nil => idp
  | :: a old-context => append-context-right-end (\lam i => subst (suc i)) index

\func weakening {env : FSignature} {s' : Sort} {narrow-context wide-context : List Sort} {mc : MetaContext Sort}
                (t : Term env narrow-context s' mc)
                (sublist : SubList narrow-context wide-context)
  : Term env wide-context s' mc \elim t
  | var index p => to-var (recalculate-index sublist index p)
  | metavar m choosing => metavar m (\lam i1 => weakening (choosing i1) sublist)
  | func f choosing => func f (\lam i1 => weakening (choosing i1) (SubList.extend-right-both sublist))
  \where {
    \func recalculate-index {A : \Set} {a b : List A} {point : A} (sublist : SubList a b) (ind : Fin (length a)) (p : point = a !! ind) : \Sigma (ind' : Fin (length b)) (point = b !! ind') \elim a, b, sublist, ind, p
      | :: x xs, :: y ys, sublist-match p sublist, zero, idp => (zero, p)
      | :: x xs, :: y ys, sublist-match p sublist, suc ind, idp => \let (ind', p') => recalculate-index sublist ind idp \in (suc ind', p')
      | l, :: y ys, sublist-skip sublist, ind, idp => \let (ind', p') => recalculate-index sublist ind idp \in (suc ind', p')

    \func recalculate-index-fpr {A : \Set} {a b : List A} (sublist : SubList a b) (ind : Fin (length a)) : Fin (length b) \elim a, b, sublist, ind
      | :: x xs, :: y ys, sublist-match p sublist, zero => zero
      | :: x xs, :: y ys, sublist-match p sublist, suc ind => suc (recalculate-index-fpr sublist ind)
      | l, :: y ys, sublist-skip sublist, ind => suc (recalculate-index-fpr sublist ind)
        \where {
          \func over-skip {A : \Set} {a b : List A} {x : A} (sublist : SubList a b) (ind : Fin (length (a))) : recalculate-index-fpr (sublist-skip {_} {_} {x} sublist) ind = fsuc (recalculate-index-fpr sublist ind) \elim a
            | nil => idp
            | :: a a1 => idp
        }

    \func recalculate-index-to-fpr  {A : \Set} {a b : List A} {point : A} (sublist : SubList a b) (ind : Fin (length a)) (p : point = a !! ind) : (recalculate-index sublist ind p).1 = recalculate-index-fpr sublist ind \elim a, b, sublist, ind, p
      | :: x a, :: y b, sublist-match p sublist, 0, idp => idp
      | :: x a, :: y b, sublist-match p sublist, suc ind, idp => rewriteI (recalculate-index-to-fpr sublist ind idp) idp
      | :: a a1, :: y b, sublist-skip sublist, ind, idp => rewriteI (recalculate-index-to-fpr sublist ind idp) idp

    \lemma recalculate-index-over-identity {A : \Set} {a : List A} (ind : Fin (length a)) : recalculate-index SubList.identity ind idp = (ind, idp) \elim a, ind
      | :: a a1, zero => idp
      | :: a a1, suc ind => rewrite recalculate-index-over-identity idp

    \lemma recalculate-index-over-shrink {A : \Set} {x : A} {p : A} {a b : List A} (sublist : SubList (x :: a) b) (ind : Fin (length a)) (eq : p = a !! ind)
      : recalculate-index (SubList.shrink sublist) ind eq = recalculate-index sublist (suc ind) eq
    \elim a, b, sublist, ind, eq
      | nil, :: y b, sublist-match p1 sublist, ind, idp => idp
      | :: a a1, :: y b, sublist-match p1 sublist, ind, idp => idp
      | nil, :: y b, sublist-skip sublist, (), eq
      | :: a a1, :: y b, sublist-skip sublist, ind, idp => rewrite (recalculate-index-over-shrink sublist ind idp) idp

    \lemma recalculate-index-over-right-extension {A : \Set} {a b : List A} (ind : Fin (length a)) :
      \Sigma (eq : (a !! ind) = (a ++ b) !! expand-fin ind) (recalculate-index {A} {a} {a ++ b} (SubList.extend-right-single SubList.identity {b}) ind idp = (expand-fin {A} {a} {b} ind, eq)) \elim a, ind
      | :: a a1, 0 => (idp, idp)
      | :: a a1, suc ind => \let | (eq-custom, b-eq) => recalculate-index-over-right-extension {_} {a1} {b} ind
                                 | (ind', q') => recalculate-index (SubList.extend-right-single SubList.identity {b}) ind idp
                            \in (eq-custom, rewrite b-eq idp)

    \lemma recalculate-index-over-right-extension' {A : \Set} {a b : List A} (ind : Fin (length a)) :
      \Sigma (eq : (a ++ b) !! expand-fin ind = (a !! ind)) (recalculate-index {A} {a} {a ++ b} (SubList.extend-right-single SubList.identity {b}) ind eq = (expand-fin {A} {a} {b} ind, idp)) \elim a, ind
      | :: a a1, 0 => (idp, idp)
      | :: a a1, suc ind => \let | (eq-custom, b-eq) => recalculate-index-over-right-extension' {_} {a1} {b} ind
                                 | (ind', q') => recalculate-index (SubList.extend-right-single SubList.identity {b}) ind idp
                            \in (eq-custom, recalculate-over-match {A} {a1} {a1 ++ b} (SubList.extend-right-single SubList.identity {b}) ind eq-custom *> (rewrite b-eq idp))

    \lemma recalculate-index-over-left-extension {A : \Set} {a b : List A} (ind : Fin (length b)) :
      (recalculate-index {A} {b} {a ++ b} (SubList.extend-left-single SubList.identity {a}) ind (expand-fin-eq-late {_} {a} ind) = (expand-fin-late ind, idp)) \elim a
      | nil => (recalculate-index-over-identity ind)
      | :: a a1 => \let | b-eq => recalculate-index-over-left-extension {_} {a1} {b} ind
                   \in (rewrite (recalculate-over-skip {A} {b} {a1 ++ b} {_} {a} (SubList.extend-left-single SubList.identity) ind (expand-fin-eq-late ind)) (rewrite b-eq idp))

    \lemma recalculate-index-over-left-extension-generic {A : \Set} {a b : List A} {point : A} (ind : Fin (length b)) {point-eq : point = b !! ind} :
      \Sigma (eq2 : (point = (a ++ b) !! expand-fin-late ind)) (recalculate-index {A} {b} {a ++ b} (SubList.extend-left-single SubList.identity {a}) ind (point-eq) = (expand-fin-late ind, eq2)) \elim a, point-eq
      | nil, idp => (idp, recalculate-index-over-identity ind)
      | :: a a1, idp => \let (new-eq, new-ind) => recalculate-index-over-left-extension-generic {_} {a1} {b} ind {idp} \in (new-eq, rewrite recalculate-over-skip (rewrite new-ind idp))
    --      \elim a
--      | nil => (recalculate-index-over-identity ind)
--      | :: a a1 => \let | b-eq => recalculate-index-over-left-extension {_} {a1} {b} ind
--                   \in (rewrite (recalculate-over-skip {A} {b} {a1 ++ b} {_} {a} (SubList.extend-left-single SubList.identity) ind (expand-fin-eq-late ind)) (rewrite b-eq idp))


    \lemma recalculate-index-over-left-extension' {A : \Set} {a b : List A} (ind : Fin (length b)) :
      (recalculate-index {A} {b} {a ++ b} (SubList.extend-left-single SubList.identity {a}) ind (idp) = (expand-fin-late ind, inv (expand-fin-eq-late {_} {a} ind))) \elim a
      | nil => (recalculate-index-over-identity ind)
      | :: a a1 => \let b-eq => recalculate-index-over-left-extension' {_} {a1} {b} ind \in rewrite (recalculate-over-skip {A} {b} {a1 ++ b} {_} {a} (SubList.extend-left-single SubList.identity) ind idp) (rewrite b-eq idp)

    \lemma recalculate-over-skip {A : \Set} {a b : List A} {point point' : A} (sublist : SubList a b) (ind : Fin (length a)) (eq : point = a !! ind) :
      recalculate-index {A} {a} {point' :: b} {point} (sublist-skip sublist) ind eq = (\let (ind', eq') => recalculate-index sublist ind eq \in (suc ind', eq')) \elim a, b, sublist, ind, eq
      | :: x a, :: y b, sublist-match p sublist, 0, idp => idp
      | :: x a, :: y b, sublist-match p sublist, suc ind, idp => idp
      | nil, :: y b, sublist-skip sublist, ind, idp => idp
      | :: a a1, :: y b, sublist-skip sublist, ind, idp => idp

    \lemma recalculate-over-match {A : \Set} {a b : List A} {point point' : A} (sublist : SubList a b) (ind : Fin (length a)) (eq : point = a !! (ind)) :
      recalculate-index {A} {point' :: a} {point' :: b} {point} (sublist-match idp sublist) (suc ind) eq = (\let (ind', eq') => recalculate-index sublist ind eq \in (suc ind', eq')) \elim a, b, sublist, ind, eq
      | :: x a, :: y b, sublist-match p sublist, 0, idp => idp
      | :: x a, :: y b, sublist-match p sublist, suc ind, idp => idp
      | nil, :: y b, sublist-skip sublist, ind, idp => idp
      | :: a a1, :: y b, sublist-skip sublist, ind, idp => idp
  }

\func extend-substitution-right
  {env : FSignature} {left-context right-context some-context : List Sort} {mc : MetaContext Sort}
  (sublist : SubList right-context some-context)
  (chooser : Substitution left-context some-context mc)
  (j : Fin (length (left-context ++ right-context)))
  : Term env some-context ((left-context ++ right-context) !! j) mc
\elim left-context, j
  | nil, j => to-var (produce-inner-term sublist j)
  | :: a narrow-context, zero => chooser zero
  | :: a narrow-context, suc j => extend-substitution-right sublist (\lam i => chooser (suc i)) j
  \where {
    \func produce-inner-term {A : \Type} {right-context some-context : List A} (sublist : SubList right-context some-context) (j : Fin (length right-context)) :
      \Sigma (ind : Fin (length some-context)) (right-context !! j = some-context !! ind) \elim right-context, some-context, sublist, j
      | :: x xs, :: y ys, sublist-match p sublist, zero => (0, p)
      | :: x xs, :: y ys, sublist-match p sublist, suc j => \let (ind, q) => produce-inner-term sublist j \in (suc ind, q)
      | l, :: y ys, sublist-skip sublist, j => \let (ind, q) => produce-inner-term sublist j \in (suc ind, q)
  }

\func extend-substitution-left
  {env : FSignature} {left-context right-context some-context : List Sort} {mc : MetaContext Sort}
  (sublist : SubList left-context some-context)
  (chooser : Substitution right-context some-context mc)
  (j : Fin (length (left-context ++ right-context)))
  : Term env some-context ((left-context ++ right-context) !! j) mc \elim left-context, j
  | nil, j => chooser j
  | :: a left-context, 0 => weakening (var 0 idp) sublist
  | :: a left-context, suc j => extend-substitution-left (SubList.shrink sublist) chooser j
  \where {
    \lemma for-left-context
      {env : FSignature} {left-context right-context some-context : List Sort} {mc : MetaContext Sort}
      (sublist : SubList left-context some-context)
      (chooser : Substitution right-context some-context mc)
      (j : Fin (length (left-context))) : extend-substitution-left sublist chooser (expand-fin j) = weakening (var j (expand-fin-eq j)) sublist \elim left-context, j
      | :: a left-context, 0 => idp
      | :: a left-context, suc j => \let inductive => for-left-context (SubList.shrink sublist) chooser j \in inductive *> (pmap to-var (weakening.recalculate-index-over-shrink sublist j (expand-fin-eq j)))

    \lemma for-right-context
      {env : FSignature} {left-context right-context some-context : List Sort} {mc : MetaContext Sort}
      (sublist : SubList left-context some-context)
      (chooser : Substitution right-context some-context mc)
      (j : Fin (length (right-context)))
      : extend-substitution-left sublist chooser (expand-fin-late j) = transport (Term env some-context __ mc) (inv (expand-fin-eq-late j)) (chooser j)
    \elim left-context, j
      | nil, j => idp
      | :: a left-context, j => for-right-context (SubList.shrink sublist) chooser j
  }

\func to-var {env : FSignature} {some-context : List Sort} {s : Sort} {msig : MetaContext Sort} (sig : \Sigma (ind : Fin (length some-context)) (s = some-context !! ind))
  : Term env some-context s msig => var sig.1 sig.2

\lemma append-context-right-to-identity
  {env : FSignature} {old-context : List Sort} {mc : MetaContext Sort}
  {additional-context : List Sort} (i : Fin (length (old-context ++ additional-context)))
  : append-context-right {_} {old-context} {_} {mc}  plain-identity {additional-context} i = plain-identity i =>
  partial-fin-induction
      (\lam i => append-context-right {_} {old-context} {_} {mc} plain-identity {additional-context} i = plain-identity i)
      (\lam i1 => append-context-right-begin plain-identity i1 *>
      (rewrite transport-over-weakening (\let | some-lemma => weakening.recalculate-index-over-right-extension {_} {_} {additional-context} i1
                                         \in rewrite (pmap (to-var) some-lemma.2) (unfold (to-var, plain-identity) (lem2 (expand-fin i1) (some-lemma).1 idp (inv (expand-fin-eq i1)))))))
      (\lam i1 => append-context-right-end plain-identity i1 *> (pmap (to-var {env}) (weakening.recalculate-index-over-left-extension i1)))
      i
  \where {
    \lemma transport-over-weakening {env : FSignature} {context context' : List Sort} {s s' : Sort} {mc : MetaContext Sort}
                                    (T : Term env context s mc) (eq : s = s') (sublist : SubList context context')
      : weakening (transport (Term env context __ mc) eq T) sublist = transport (Term env context' __ mc) eq (weakening T sublist) \elim eq
      | idp => idp

    \lemma lem2  {env : FSignature} {context : List Sort} {s s' : Sort} {mc : MetaContext Sort}
                 (index : Fin (length context)) (eq : s = context !! index) (eq' : s' = context !! index) (eq'' : s = s')
      : transport (Term env context __ mc) eq'' (var index eq)  = var index eq' \elim eq''
      | idp => pmap (var index) (Path.inProp eq eq')

    \lemma ext' {env : FSignature} {old-context : List Sort} {mc : MetaContext Sort}
                {additional-context : List Sort} : (\lam (i : Fin (length (old-context ++ additional-context))) => append-context-right {_} {old-context} {_} {mc}  plain-identity {additional-context} i) = plain-identity =>
      ext append-context-right-to-identity
  }

\lemma double-append-context-right {env : FSignature} {context-a context-res context-b context-c : List Sort} {mc : MetaContext Sort}
                                   (subst : Substitution context-a context-res mc) :
  append-context-right (append-context-right subst)
    =
  transport2 (\lam ctx ctx' => \Pi (index : Fin (length ctx)) ->
      Term env ctx' (ctx !! index) mc) (inv ++-assoc) (inv ++-assoc) (append-context-right subst {context-b ++ context-c}) =>
  ext (unext subst)
  \where {
    \lemma unext {env : FSignature} {context-a context-res context-b context-c : List Sort} {mc : MetaContext Sort}
                 (subst : Substitution context-a context-res mc) (i : Fin (length ((context-a ++ context-b) ++ context-c)))
      : append-context-right (append-context-right subst) i = transport2 (\lam ctx ctx' => \Pi (index : Fin (length ctx)) ->
        Term env ctx' (ctx !! index) mc) (inv ++-assoc) (inv ++-assoc) (append-context-right subst {context-b ++ context-c}) i =>
      partial-fin-induction
          (\lam fin =>
              append-context-right (append-context-right subst) fin =
              transport2 (\lam ctx ctx' => \Pi (index : Fin (length (ctx))) -> Term env (ctx') ((ctx) !! index) mc) (inv ++-assoc) (inv ++-assoc) (append-context-right subst {context-b ++ context-c}) fin)
          (\lam i1 => rewrite append-context-right-begin (rewriteI end-over-transport
              (rewrite end-over-transport-3 (rewrite transport_inv_id idp))))
          (\lam i1 => rewrite append-context-right-end (rewriteI end-over-transport (rewrite end-over-transport-2 (rewrite transport_inv_id idp))))
          i

    \func end-over-transport {env : FSignature} {context-a context-b context-res context-add : List Sort} {mc : MetaContext Sort}
                             (subst : Substitution context-a context-res mc)
                             (i1 : Fin (length ((context-a ++ context-b) ++ context-add)))
      :
      transport (\lam (ctx' : List env.Sort) => Term env ctx' (((context-a ++ context-b) ++ context-add) !! (i1)) mc)
          (inv ++-assoc) (transport (\lam ctx => \Pi (index : Fin (length ctx)) -> Term env (context-res ++ context-b ++ context-add) (ctx !! index) mc) (inv ++-assoc) (append-context-right subst) (i1))  =
      transport2 (\lam (ctx : List env.Sort) (ctx' : List env.Sort) => \Pi (index : Fin (length ctx)) -> Term env ctx' (ctx !! index) mc)
          (inv ++-assoc) (inv ++-assoc) (append-context-right subst) (i1) => rewriteI decompose-transport2 (lemma subst _ _ _)
      \where {
        \func lemma {env : FSignature} {big-context-al big-context-ar context-sl context-rl context-add : List Sort} {mc : MetaContext Sort}
                    (subst : Substitution context-sl context-rl mc)
                    (eq : context-sl ++ context-add = big-context-al)
                    (eq' : context-rl ++ context-add = big-context-ar)
          (i1 : Fin (length big-context-al)) : transport (\lam (ctx' : List env.Sort) => Term env ctx' ((big-context-al) !! i1) mc) (eq')
            (transport (\lam (ctx : List env.Sort) =>
                \Pi (index : Fin (length ctx)) -> Term env (context-rl ++ context-add) (ctx !! index) mc) (eq)
                (append-context-right subst) i1) = transport (\lam (p0 : List env.Sort) =>
            \Pi (index : Fin (length p0)) -> Term env (big-context-ar) (p0 !! index) mc) (eq)
                                                       (transport (\lam (p0 : List env.Sort) => \Pi (index : Fin (length (context-sl ++ context-add))) ->
                                                           Term env p0 ((context-sl ++ context-add) !! index) mc) (eq') (append-context-right subst)) i1 \elim eq, eq'
          | idp, idp => idp
      }

    \func decompose-transport2 {A B : \Type} (C : A -> B -> \Type) {a a' : A} (eq : a = a') {b b' : B} (eq' : b = b') (x : C a b) : transport (C __ b') eq (transport (C a __) eq' x) = transport2 C eq eq' x \elim eq, eq'
      | idp, idp => idp

    \func end-over-transport-2 {env : FSignature} {context-a context-b context-res context-add : List Sort} {mc : MetaContext Sort}
                               (subst : Substitution context-a context-res mc)
                               (i1 : Fin (length (context-add)))
      : (transport (\lam (ctx : List env.Sort) =>
        \Pi (index : Fin (length ctx)) -> Term env (context-res ++ context-b ++ context-add) (ctx !! index) mc) (inv ++-assoc)
        (append-context-right subst) (expand-fin-late i1)) =
    transport (Term env __ (((context-a ++ context-b) ++ context-add) !! expand-fin-late i1) mc) (++-assoc) (weakening (var i1 (expand-fin-eq-late i1)) ((SubList.extend-left-single SubList.identity)))
    \elim context-a
      | nil => unfold transport
          (transport (\lam vr => var (vr).1 (vr).2 =
          coe (\lam i => Term env (++-assoc @ i) ((context-b ++ context-add) !! expand-fin-late i1) mc)
              (var (weakening.recalculate-index (SubList.extend-left-single SubList.identity) i1 (expand-fin-eq-late i1)).1
                  (weakening.recalculate-index (SubList.extend-left-single SubList.identity) i1 (expand-fin-eq-late i1)).2) right) (inv (weakening.recalculate-index-over-left-extension' (expand-fin-late i1)))
              (              (rewrite (push-transport-var _ _ _).2 (var-extensionality _ _ (expansion-lemma {_} {context-res} {context-b} i1 *> (repeat {2} (rewrite weakening.recalculate-index-to-fpr) idp)) _ _))))
      | :: a context-a => \let inductive => end-over-transport-2 {_} {_} {context-b} (\lam i => subst (suc i)) (i1) \in (equation _ _ _ _) *> inductive
      \where {
        \func expansion-lemma {A : \Set} {context-a context-b context-c : List A}
                              (index : Fin (length context-c)) :
          expand-fin-late {_} {context-a} (expand-fin-late {_} {context-b} index) =
          transport (\lam ctx => Fin (length (ctx))) ++-assoc
              (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index (expand-fin-eq-late {_} {context-a ++ context-b} index)).1 \elim context-a, context-b
          | nil, nil => rewrite weakening.recalculate-index-over-identity idp
          | nil, :: a context-b => rewrite weakening.recalculate-over-skip (rewrite weakening.recalculate-index-over-left-extension idp)
          | :: a context-a, context-b => rewrite (expansion-lemma {_} {context-a} index) (rewrite weakening.recalculate-index-to-fpr (rewrite (weakening.recalculate-index-to-fpr (sublist-skip (SubList.extend-left-single SubList.identity))) (unassoc _ _)))
          \where {
            \func unassoc {A : \Set} {context-a context-b context-c big-context : List A} {a : A}
                          (eq : (context-a ++ context-b) ++ context-c = big-context)
                          (index : Fin (length context-c)) : suc (coe (\lam (i : I) => Fin (length (eq @ i)))
                (weakening.recalculate-index-fpr (SubList.extend-left-single SubList.identity) index) right) = transport (\lam (ctx : List A) => Fin (length ctx)) (path (\lam (i : I) => a :: eq @ i))
                                                                                                                   (weakening.recalculate-index-fpr (sublist-skip {_} {_} {a} (SubList.extend-left-single SubList.identity)) index) \elim eq
              | idp => unfold transport (rewrite weakening.recalculate-index-fpr.over-skip idp)
          }

        \func push-transport-var {env : FSignature} {s : Sort}
                                 {context context' : List Sort}
                                 (eq : context = context')
                                 {ms : MetaContext Sort}
                                 (index : Fin (length context))
                                 (eq' : s = context !! index): \Sigma (eqn : s = context' !! transport (\lam ctx => Fin (length ctx)) eq index) (transport (Term env __ s ms) eq (var index eq') = var (transport (\lam ctx => Fin (length ctx)) eq index) eqn) \elim eq
          | idp => (eq', idp)

        \func push-transport-var-2 {env : FSignature} {s s' : Sort}
                                   {context : List Sort}
                                   (eq : s = s')
                                   {ms : MetaContext Sort}
                                   (index : Fin (length context))
                                   (eq' : s = context !! index)
          : transport (Term env context __ ms) eq (var index eq') = var index (inv eq <* eq') \elim eq
          | idp => idp

        \func equation {env : FSignature} {context-a context-b context-res context-add big-context-a : List Sort} {mc : MetaContext Sort}
                       (a : Sort)
                       (subst : Substitution (a :: context-a) context-res mc)
                       (i1 : Fin (length (big-context-a)))
                       (eq : big-context-a = context-a ++ (context-b ++ context-add))
          :
          transport (\lam (ctx : List env.Sort) =>
              \Pi (index : Fin (length ctx)) -> Term env (context-res ++ context-b ++ context-add) (ctx !! index) mc)
              (inv (path (\lam (i : I) => a :: eq @ i))) (append-context-right subst) (suc (i1)) = transport (\lam (ctx : List env.Sort) =>
              \Pi (index : Fin (length ctx)) -> Term env (context-res ++ context-b ++ context-add) (ctx !! index) mc) (inv eq)
                                                                                                       (append-context-right (\lam (i : Fin (length context-a)) => subst (suc i))) (i1) \elim eq
          | idp => unfold transport idp
      }

    \func end-over-transport-3 {env : FSignature} {context-a context-b context-res context-add : List Sort} {mc : MetaContext Sort}
                               (subst : Substitution context-a context-res mc)
                               (i2 : Fin (length (context-a ++ context-b)))
      : (transport (\lam (ctx : List env.Sort) =>
        \Pi (index : Fin (length ctx)) -> Term env (context-res ++ context-b ++ context-add) (ctx !! index) mc) (inv ++-assoc)
        (append-context-right subst) (expand-fin i2)) =
    (transport (Term env __ _ mc) (++-assoc)
        (weakening (transport (Term env (context-res ++ context-b) __ mc) (inv (expand-fin-eq {_} {_} {context-add} i2)) (append-context-right subst i2)) (SubList.extend-right-single SubList.identity))) \elim context-a, context-b, i2
      | nil, context-b, i2 => transport (\lam eqt => transport (\lam (ctx : List env.Sort) =>
          \Pi (index : Fin (length ctx)) -> Term env (context-res ++ context-b ++ context-add) (ctx !! index) mc)
          (path (\lam (_ : I) => context-b ++ context-add)) (\lam (index1 : Fin (length (nil ++ context-b ++ context-add))) =>
              var (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index1 idp).1
                  (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index1 idp).2) (expand-fin i2) = transport (\lam (p0 : List env.Sort) => Term env p0 ((context-b ++ context-add) !! expand-fin i2) mc) ++-assoc
                                                                                                                                  (weakening (eqt)
                                                                                                                                      (SubList.extend-right-single SubList.identity))) (inv (end-over-transport-2.push-transport-var-2 _ _ _)) (rewrite (end-over-transport-2.push-transport-var _ _ _).2 (var-extensionality _ _ (rewrite weakening.recalculate-index-over-left-extension'
          (transport (\lam idx => expand-fin-late (expand-fin i2) = coe (\lam (i : I) => Fin (length (++-assoc @ i))) (weakening.recalculate-index (SubList.extend-right-single SubList.identity)
              (idx).1
              (inv (inv (expand-fin-eq i2)) <* (idx).2)).1
                                                                        right) (inv (weakening.recalculate-index-over-left-extension' _)) ((rewrite weakening.recalculate-index-to-fpr) (fin-transporting-lemma)))) _ _))
      | :: a context-a, context-b, 0 => equating-lemma a subst _
      | :: a context-a, context-b, suc i2 => \let inductive => end-over-transport-3 {_} {_} {_} {context-res} {context-add} (\lam i => subst (suc i)) i2 \in end-over-transport-2.equation _ _ _ _ *> inductive
      \where {
        \func fin-transporting-lemma {A : \Set} {context-a context-b context-c : List A} {i2 : Fin (length context-b)} :
          expand-fin-late {_} {context-a} (expand-fin {_} {_} {context-c} i2) =
          transport (\lam ctx => Fin (length ctx)) ++-assoc (weakening.recalculate-index-fpr (SubList.extend-right-single SubList.identity) (expand-fin-late i2)) \elim context-a,  i2
          | nil, i2 => (quick-unify-2 i2)
          | :: a context-a, i2 => rewrite (fin-transporting-lemma) (quick-unify {_} {a})
        \where {
          \func quick-unify {A : \Set} {x : A} {context-a context-b : List A} {f1 : Fin (length context-b)} {eq : context-b = context-a} : suc (transport (\lam ctx => Fin (length ctx)) eq f1) = transport (\lam ctx => Fin (length ctx)) (path (\lam (i : I) => x :: eq @ i)) (suc f1) \elim eq
            | idp => idp

          \func quick-unify-2 {A : \Set} {ctx ctx' : List A} (i2 : Fin (length ctx)) : expand-fin i2 = weakening.recalculate-index-fpr (SubList.extend-right-single SubList.identity {ctx'}) i2 \elim ctx, i2
            | :: a ctx, 0 => idp
            | :: a ctx, suc i2 => pmap fsuc (quick-unify-2 i2)
        }

        \func equating-lemma {env : FSignature} {context-a context-b context-res context-add big-context : List Sort} {mc : MetaContext Sort}
                             (a : Sort)
                             (subst : Substitution (a :: context-a) context-res mc)
                             (eq : big-context = context-a ++ (context-b ++ context-add))
          : transport (\lam (ctx : List env.Sort) =>
            \Pi (index : Fin (length ctx)) -> Term env (context-res ++ context-b ++ context-add) (ctx !! index) mc)
            (inv (path (\lam (i : I) => a :: eq @ i))) (append-context-right subst) 0 =
        transport (\lam (p0 : List env.Sort) => Term env p0 a mc) ++-assoc
            (weakening (weakening (subst 0) (SubList.extend-right-single SubList.identity)) (SubList.extend-right-single SubList.identity)) \elim eq
          | idp => subequating-lemma _ _
          \where {
            \func subequating-lemma
              {env : FSignature} {context-a context-b context-c : List Sort} {mc : MetaContext Sort}
              (a : Sort)
              (t : Term env context-a a mc)
              : weakening t (SubList.extend-right-single SubList.identity) =
            transport (Term env __ a mc) ++-assoc
                (weakening (weakening t (SubList.extend-right-single SubList.identity {context-b})) (SubList.extend-right-single SubList.identity {context-c})) =>
              rewrite weakening-composition (rewrite transport-over-weakening (pmap (weakening t) (sublist-equation)))

            \func sublist-equation {A : \Type} {a b c : List A} :
              SubList.extend-right-single SubList.identity =
              transport (SubList a) ++-assoc (sublist-compose (SubList.extend-right-single (SubList.identity {_} {a}) {b}) (SubList.extend-right-single SubList.identity {c})) \elim a, b, c
              | nil, b, c => decompose-along-reduction.any-nil-sublist-equate _ _
              | :: a a1, b, c => \let inductive => sublist-equation {_} {a1} {b} {c} \in (rewrite inductive (rewrite (decompose-along-reduction.different-weakening.equate-sublists-2.commute-match-straight) idp))

            \func transport-over-weakening
              {env : FSignature} {context-a big-context big-context' : List Sort} {mc : MetaContext Sort}
              (a : Sort)
              (t : Term env context-a a mc)
              (sl : SubList context-a big-context)
              (eq : big-context = big-context') : transport (Term env __ a mc) eq (weakening t sl) = weakening t (transport (SubList context-a) eq sl) \elim eq | idp => idp
          }

        \func weakening-composition {env : FSignature} {context-a context-b context-c : List Sort} {mc : MetaContext Sort}
                                    {a : Sort}
                                    (t : Term env context-a a mc)
                                    (sl : SubList context-a context-b)
                                    (sl' : SubList context-b context-c)
          : weakening (weakening t sl) sl' = weakening t (sublist-compose sl sl') \elim t
          | var index p => var-extensionality _ _ (repeat {3} (rewrite weakening.recalculate-index-to-fpr) (lemma _ _ _)) _ _
          | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-composition (choosing index) _ _))
          | func f choosing => pmap (func f) (ext (\lam index => rewrite (weakening-composition (choosing index) _ _) (pmap (weakening (choosing index)) (lemma2 _ _))))
            \where {
              \func lemma {A : \Set} {a b c : List A} (sl : SubList a b) (sl' : SubList b c) (ind : Fin (length a)) :
                weakening.recalculate-index-fpr sl' (weakening.recalculate-index-fpr sl ind) = weakening.recalculate-index-fpr (sublist-compose sl sl') ind \elim a, b, c, sl, sl', ind
                | :: x a, :: x1 b, :: y c, sublist-match p sl, sublist-match p1 sl', 0       => idp
                | :: x a, :: x1 b, :: y c, sublist-match p sl, sublist-match p1 sl', suc ind => pmap (fsuc) (lemma _ _ _)
                | :: x a, :: y b, :: y1 c, sublist-match p sl, sublist-skip sl', 0           => pmap (fsuc) (lemma _ _ _)
                | :: x a, :: y b, :: y1 c, sublist-match p sl, sublist-skip sl', suc ind     => pmap (fsuc) (lemma _ _ _)
                | nil, :: x b, :: y c, sublist-skip sl, sublist-match p sl', ind             => pmap (fsuc) (lemma _ _ _)
                | :: a a1, :: x b, :: y c, sublist-skip sl, sublist-match p sl', ind         => pmap (fsuc) (lemma _ _ _)
                | :: a a1, :: y b, :: y1 c, sublist-skip sl, sublist-skip sl', ind           => pmap (fsuc) (lemma _ _ _)

              \func lemma2 {A : \Set} {a b c d : List A} (sl : SubList a b) (sl' : SubList b c)
                : sublist-compose (SubList.extend-right-both sl) (SubList.extend-right-both sl') = SubList.extend-right-both (sublist-compose sl sl') {d} \elim a, b, c, d, sl, sl'
                | nil, nil, nil, d, sublist-trivial, sublist-trivial => sublist-compose.identity
                | nil, nil, :: y c, nil, sublist-trivial, sublist-skip sl' => pmap sublist-skip (lemma2 _ _)
                | nil, nil, :: y c, :: a d, sublist-trivial, sublist-skip sl' => pmap sublist-skip (lemma2 _ _)
                | :: x a, :: x1 b, :: y c, d, sublist-match p sl, sublist-match p1 sl' => pmap (sublist-match (p *> p1)) (lemma2 _ _)
                | :: x a, :: y b, :: y1 c, d, sublist-match p sl, sublist-skip sl' => pmap sublist-skip (lemma2 _ _)
                | nil, :: x b, :: y c, nil, sublist-skip sl, sublist-match p sl' => pmap sublist-skip (lemma2 _ _)
                | nil, :: x b, :: y c, :: a d, sublist-skip sl, sublist-match p sl' => pmap sublist-skip (lemma2 _ _)
                | :: a a1, :: x b, :: y c, d, sublist-skip sl, sublist-match p sl' => pmap sublist-skip (lemma2 _ _)
                | nil, :: y b, :: y1 c, nil, sublist-skip sl, sublist-skip sl' => pmap sublist-skip (transport (\lam slx => sublist-compose (SubList.extend-right-both sl) slx = SubList.extend-right-both (sublist-compose sl (SubList.shrink sl'))) (inv (extend-right-commute-with-shrink sl')) (lemma2 _ _))
                | nil, :: y b, :: y1 c, :: a d, sublist-skip sl, sublist-skip sl' => pmap sublist-skip (lemma2 (sublist-skip sl) (sl') *> (rewrite (decompose-along-reduction.any-nil-sublist-equate {_} {_} (sublist-compose (sublist-skip sl) sl') (sublist-compose sl (SubList.shrink sl'))) idp))
                | :: a a1, :: y b, :: y1 c, d, sublist-skip sl, sublist-skip sl' => pmap sublist-skip (lemma2 _ _)

              \func extend-right-commute-with-skip {A : \Set} {x : A} {a b c : List A} (sl : SubList a b) : sublist-skip {_} {_} {x} (SubList.extend-right-both sl {c})  = SubList.extend-right-both (sublist-skip sl) \elim a, b, sl
                | nil, nil, sublist-trivial => idp
                | :: x1 a, :: y b, sublist-match p sl => idp
                | nil, :: y b, sublist-skip sl => idp
                | :: a a1, :: y b, sublist-skip sl => idp

              \func extend-right-commute-with-shrink {A : \Set} {x : A} {a b c : List A} (sl : SubList (x :: a) b) : SubList.shrink (SubList.extend-right-both sl {c})  = SubList.extend-right-both (SubList.shrink sl) \elim a, b, sl
                | a, :: y b, sublist-match p sl => rewriteI extend-right-commute-with-skip (pmap sublist-skip idp)
                | a, :: y b, sublist-skip sl => rewriteI extend-right-commute-with-skip (pmap sublist-skip (extend-right-commute-with-shrink _))
            }

        \func sublist-compose {A : \Type} {a b c : List A} (sl : SubList a b) (sl' : SubList b c) : SubList a c \elim a, b, c, sl, sl'
          | nil, nil, nil, sublist-trivial, sublist-trivial => sublist-trivial
          | nil, nil, :: y c, sublist-trivial, sublist-skip sl' => sublist-skip (sublist-compose sublist-trivial sl')
          | :: x a, :: x1 b, :: y c, sublist-match p sl, sublist-match p1 sl' => sublist-match (p *> p1) (sublist-compose sl sl')
          | :: x a, :: y b, :: y1 c, sl, sublist-skip sl' => sublist-skip (sublist-compose sl sl')
          | a, :: x b, :: y c, sublist-skip sl, sublist-match p sl' => sublist-skip (sublist-compose sl sl')
          | a, :: y b, :: y1 c, sublist-skip sl, sublist-skip sl' => sublist-skip (sublist-compose sl (SubList.shrink sl'))
            \where {
              \func identity {A : \Type} {a : List A} : sublist-compose SubList.identity SubList.identity = SubList.identity {_} {a} \elim a
                | nil => idp
                | :: a a1 => pmap (sublist-match idp) identity
            }
      }
  }

\func append-context-right-to-nil {env : FSignature} {context-a context-b : List Sort} {mc : MetaContext Sort}
                                  (subst : Substitution context-a context-b mc) :
  subst = transport2 (\lam ctx ctx' => Substitution ctx ctx' mc) ++_nil ++_nil (append-context-right subst) =>
  ext (unext _)
  \where {
    \func unext {env : FSignature} {context-a context-b : List Sort} {mc : MetaContext Sort}
                (subst : Substitution context-a context-b mc) (i : Fin (length (context-a))) : subst i = transport2 (\lam ctx ctx' => Substitution ctx ctx' mc) ++_nil ++_nil (append-context-right subst) i =>
      rewriteI decompose-transport2 (rewrite move-under-transport
          (rewrite transport-move (rewrite append-ctr-lemma (rewrite transport_id_inv (rewrite weakening-comm (rewrite sublist-eq (rewrite transport_id_inv (inv (weakening-over-identity (subst i))))))))))

    \func sublist-eq {A : \Type} {a : List A} : (SubList.extend-right-single (SubList.identity {_} {a})) = transport (SubList a __) (inv ++_nil) (SubList.identity) \elim a
      | nil => idp
      | :: a a1 => rewriteI decompose-along-reduction.different-weakening.equate-sublists-2.commute-match (pmap (sublist-match idp) (sublist-eq))

    \func weakening-comm {env : FSignature} {context context' context'' : List Sort} {s : Sort} {mc : MetaContext Sort} {t : Term env context s mc}
      (sublist : SubList context context')
                         (eq : context' = context'')

      : transport (Term env __ s mc) eq (weakening t sublist) = weakening t (transport (SubList context) eq sublist) \elim eq
      | idp => idp

    \func decompose-transport2 {A B : \Type} (C : A -> B -> \Type) {a a' : A} (eq : a = a') {b b' : B} (eq' : b = b') (x : C a b) : transport (C a') eq' (transport (C __ b) eq x) = transport2 C eq eq' x \elim eq, eq'
      | idp, idp => idp

    \func move-under-transport {env : FSignature} {context-a context-b context-c : List Sort} {mc : MetaContext Sort}
                               (subst : Substitution context-a context-b mc)
                               (eq : context-b = context-c)
                               (i : Fin (length context-a))
      : transport (Substitution context-a __ mc) eq subst i = transport (Term env __ (context-a !! i) mc) eq (subst i) \elim eq
      | idp => idp

    \type Index {A : \Type} (l : List A) => Fin (length l)

    \func some-eq {A : \Type} {a : List A} (i : Fin (length a)) : (a ++ nil) !! transport (\lam ctx => Fin (length ctx)) (inv ++_nil) i = a !! i =>
      generic i (inv ++_nil)
      \where {
      \func generic {A : \Type} {a b : List A} (i : Fin (length a)) (eq : a = b): (b) !! transport (\lam ctx => Fin (length ctx)) (eq) i = a !! i \elim eq | idp => idp
    }

    \func some-eq2 {A : \Type} {a : List A} (fin : Fin (length (a ++ nil))) : a !! transport (\lam ctx => Fin (length ctx)) ++_nil fin = (a ++ nil) !! fin =>
      generic _ _
      \where {
        \func generic {A : \Type} {a b : List A} (fin : Fin (length (b))) (eq : b = a) : a !! transport (\lam ctx => Fin (length ctx)) eq fin = (b) !! fin \elim eq | idp => idp
      }

    \func transport-move {env : FSignature} {context new-context : List Sort} {mc : MetaContext Sort} {subst : Substitution context new-context mc} (i : Fin (length context))
      : transport (\lam (p0 : List env.Sort) => Substitution p0 (new-context ++ nil) mc) ++_nil (append-context-right subst) i =
    transport (Term env _ __ mc) (some-eq i) (append-context-right subst (transport (\lam ctx => Fin (length ctx)) (inv ++_nil) i)) =>
      generic-transport-move i ++_nil _

    \func generic-transport-move {env : FSignature} {context new-context inner-context add-context : List Sort} {mc : MetaContext Sort}
                                 {subst : Substitution inner-context new-context mc}
                                 (i : Fin (length context))
                                 (eq : inner-context ++ add-context = context)
                                 (eq' : (inner-context ++ add-context) !! transport (\lam (ctx : List env.Sort) => Fin (length ctx)) (inv eq) i = context !! i)
      : transport (Substitution __ (new-context ++ add-context) mc) eq (append-context-right subst) i =
    transport (Term env _ __ mc) (eq') (append-context-right subst (transport (\lam ctx => Fin (length ctx)) (inv eq) i)) \elim eq
      | idp => \let q : eq' = idp => Path.inProp _ _ \in unfold transport (rewrite q idp)

    \func append-ctr-lemma {env : FSignature} {context new-context : List Sort} {mc : MetaContext Sort} {subst : Substitution context new-context mc} (i : Fin (length context)) :
      (append-context-right subst (transport (\lam (ctx : List env.Sort) => Fin (length ctx)) (inv ++_nil) i)) = transport (Term env _ __ mc) (inv (some-eq i)) (weakening (subst i) (SubList.extend-right-single SubList.identity)) =>
      \let q => partial-fin-induction
          (\lam fin => append-context-right subst fin = weakening (transport (Term env _ __ mc) (some-eq2 fin) (subst (transport (\lam ctx => Fin (length ctx)) ++_nil fin))) (SubList.extend-right-single SubList.identity))
          (\lam i1 => rewrite append-context-right-begin (pmap (weakening __ _) ((quick-unifier _ _ (subst i1)) *> inv (untransport subst ++_nil (expand-fin i1) i1 (unexpand-fin i1) (inv (some-eq i1) *> (pmap ((context ++ nil) !!) (unexpand-fin-2 i1))) (some-eq2 (expand-fin i1))))))
          (\lam i1 => contradiction)
          (transport (\lam (ctx : List env.Sort) => Fin (length ctx)) (inv ++_nil) i)
      \in q *> (rewriteI append-context-right-to-identity.transport-over-weakening (pmap (weakening __ _) (untransport subst ++_nil (transport (\lam (ctx : List env.Sort) => Fin (length ctx)) (inv ++_nil) i) i (rewrite transport_id_inv idp) (inv (some-eq _)) (some-eq2 (transport (\lam (ctx : List env.Sort) => Fin (length ctx)) (inv ++_nil) i)))))
        \where {
          \func untransport {env : FSignature} {context context' new-context : List Sort} {s : Sort} {mc : MetaContext Sort}
                            (subst : Substitution context' new-context mc)
                            (eq2 : context = context')
                            (i : Fin (length context))
                            (j : Fin (length context'))
                            (eqij : j = transport ((\lam ctx => Fin (length (ctx)))) eq2 i)
                            (eq' : context' !! j = s)
                            (eq : context' !! (transport (\lam ctx => Fin (length ctx)) eq2 i) = s)
            : transport (Term env new-context __ mc) eq (subst (transport (\lam ctx => Fin (length ctx)) eq2 i)) = transport (Term env new-context __ mc) eq' (subst j) \elim eq2
            | idp => \case \elim i, \elim eqij, \elim eq \with {
              | i, idp, eq => \let q : eq' = eq => Path.inProp _ _ \in rewrite q idp
            }

          \func quick-unifier {env : FSignature} {context : List Sort} {s s' : Sort} {mc : MetaContext Sort} (eq1 eq2 : s = s') (t : Term env context s mc)
            : transport (Term env context __ mc) eq1 t = transport (Term env context __ mc) eq2 t => \let q : eq1 = eq2 => Path.inProp _ _ \in rewrite q idp

          \func unexpand-fin {A : \Type} {a : List A} (i1 : Fin (length a)) : i1 = transport (\lam ctx => Fin (length (ctx))) (++_nil) (expand-fin i1) \elim a, i1
            | :: a a1, 0 => add-lemma {_} {a} ++_nil
            | :: a a1, suc i1 => suc-lemma {_} {a} ++_nil _ _ (unexpand-fin i1)
            \where {
              \func add-lemma {A : \Type} {x : A} {a b : List A} (eq : a = b) : 0 = {Fin (length (x :: b))} transport (\lam ctx => Fin (length ctx)) (path (\lam (i : I) => x :: (eq) @ i)) 0 \elim eq
                | idp => idp

              \func suc-lemma {A : \Type} {x : A} {a b : List A} (eq : a = b) (j : Fin (length b)) (k : Fin (length a)) (eq' : j = transport (\lam ctx => Fin (length ctx)) (path (\lam (i : I) => (eq) @ i)) k) : (suc j) = {Fin (length (x :: b))} transport (\lam ctx => Fin (length ctx)) (path (\lam (i : I) => x :: (eq) @ i)) (suc k) \elim eq
                | idp => pmap fsuc eq'
            }

          \func unexpand-fin-2 {A : \Type} {a : List A} (i1 : Fin (length a)) : transport (\lam ctx => Fin (length (ctx))) (inv ++_nil) i1 = expand-fin i1 => pmap (transport (\lam ctx => Fin (length ctx)) (inv ++_nil)) (unexpand-fin i1) *> (transport_inv_id (\lam ctx => Fin (length ctx)) ++_nil (expand-fin i1))

        }
  }

\func weakening-as-substitution {env : FSignature} {narrow-context wide-context : List Sort} (sublist : SubList narrow-context wide-context) {ms : MetaContext Sort}: Substitution narrow-context wide-context ms =>
  \lam i => to-var (weakening.recalculate-index sublist i idp)

\func substitution-ext {env : FSignature} {context-a context-b : List Sort} {ms : MetaContext Sort}
                       (subst-a subst-b : Substitution context-a context-b ms) (eq : \Pi (i : Fin (length context-a)) -> subst-a i = subst-b i) : subst-a = subst-b =>
  ext eq

\func var-extensionality {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort}
                         (i1 i2 : Fin (length context))
                         (eq : i1 = i2)
                         (p1 : s = context !! i1)
                         (p2 : s = context !! i2) : var {_} {_} {_} {ms} i1 p1 = var i2 p2 \elim eq
  | idp => \let eq' : p1 = p2 => Path.inProp _ _ \in pmap (var i1) eq'

\func weakening-as-substitution-eq  {env : FSignature} {narrow-context wide-context : List Sort} {s : Sort} (sublist : SubList narrow-context wide-context) {ms : MetaContext Sort}
                                    (t : Term env narrow-context s ms) : weakening t sublist = Substitution.apply t (weakening-as-substitution sublist) \elim t
  | var index idp => idp
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-as-substitution-eq sublist (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => weakening-as-substitution-eq (SubList.extend-right-both sublist) (choosing index) *> (pmap (Substitution.apply (choosing index)) (ext (\lam index1 => weakening-commutation-lemma sublist index1)))))
  \where {
    \func weakening-commutation-lemma {env : FSignature}
                                      {narrow-context wide-context add-context : List Sort}
                                      (sublist : SubList narrow-context wide-context) {ms : MetaContext Sort}
                                      (index : Fin (length (narrow-context ++ add-context)))
      : weakening-as-substitution (SubList.extend-right-both sublist) {ms} index = append-context-right (weakening-as-substitution sublist) index =>
      partial-fin-induction
          (\lam i => weakening-as-substitution (SubList.extend-right-both sublist) {ms} i = append-context-right (weakening-as-substitution sublist) i)
          (\lam i => rewrite (append-context-right-begin) ((lemma sublist i _ _)))
          (\lam i => rewrite (append-context-right-end) (unfold weakening-as-substitution (var-extensionality (weakening.recalculate-index (SubList.extend-right-both sublist) (expand-fin-late i) idp).1 (weakening.recalculate-index (SubList.extend-left-single SubList.identity) i (expand-fin-eq-late i)).1 (repeat {2} (rewrite weakening.recalculate-index-to-fpr) (recalculate-rb-vs-ls _ _)) _ _)))
          index

    \func lemma {env : FSignature}
                {s : Sort}
                {narrow-context wide-context add-context : List Sort}
                (sublist : SubList narrow-context wide-context) {ms : MetaContext Sort}
                (index : Fin (length (narrow-context)))
                (eq : s = narrow-context !! index)
                (eq' : s = (narrow-context ++ add-context) !! (expand-fin index))
      : to-var (weakening.recalculate-index (SubList.extend-right-both sublist) (expand-fin index) eq') = weakening (transport (\lam (p0 : env.Sort) => Term env wide-context p0 ms) (inv (eq))
        (to-var (weakening.recalculate-index sublist index idp))) (SubList.extend-right-single SubList.identity) \elim eq
      | idp => var-extensionality
          (weakening.recalculate-index (SubList.extend-right-both sublist) (expand-fin index) eq').1
          (weakening.recalculate-index
              (SubList.extend-right-single SubList.identity) (weakening.recalculate-index sublist index idp).1
              (weakening.recalculate-index sublist index idp).2).1
          (repeat {3} (rewrite weakening.recalculate-index-to-fpr) (recalculate-rb-then-sublist _ _))
          _
          _

    \func recalculate-rb-then-sublist {A : \Set} {a b c : List A} (sublist : SubList a b) (index : Fin (length a)) :
      weakening.recalculate-index-fpr (SubList.extend-right-both sublist {c}) (expand-fin index)
        =
      weakening.recalculate-index-fpr
          (SubList.extend-right-single SubList.identity) (weakening.recalculate-index-fpr sublist index) \elim a, b, sublist, index
      | :: x a, :: y b, sublist-match p sublist, 0 => idp
      | :: x a, :: y b, sublist-match p sublist, suc index => pmap fsuc (recalculate-rb-then-sublist sublist index)
      | nil, :: y b, sublist-skip sublist, ()
      | :: a a1, :: y b, sublist-skip sublist, index => pmap fsuc (recalculate-rb-then-sublist sublist index)

    \func recalculate-rb-vs-ls {A : \Set} {a b c : List A} (sublist : SubList a b) (index : Fin (length c)) :
      weakening.recalculate-index-fpr (SubList.extend-right-both sublist {c}) (expand-fin-late index)
        =
      weakening.recalculate-index-fpr
          (SubList.extend-left-single SubList.identity) index \elim a, b, c, sublist, index
      | nil, nil, :: a c, sublist-trivial, 0 => idp
      | nil, nil, :: a c, sublist-trivial, suc index => idp
      | :: x a, :: y b, :: a1 c, sublist-match p sublist, 0 => pmap fsuc (recalculate-rb-vs-ls sublist 0)
      | :: x a, :: y b, :: a1 c, sublist-match idp sublist, suc index => pmap fsuc (recalculate-rb-vs-ls {A} {a} {b} {:: a1 c} sublist (fsuc index))
      | nil, :: y b, :: a1 c, sublist-skip sublist, 0 => pmap fsuc (recalculate-rb-vs-ls sublist 0)
      | :: a a2, :: y b, :: a1 c, sublist-skip sublist, 0 => pmap fsuc (recalculate-rb-vs-ls sublist 0)
      | nil, :: y b, :: a1 c, sublist-skip sublist, suc index => pmap fsuc (recalculate-rb-vs-ls {A} {nil} {b} {:: a1 c} sublist (suc index))
      | :: a a2, :: y b, :: a1 c, sublist-skip sublist, suc index => pmap fsuc (recalculate-rb-vs-ls {A} {:: a a2} {b} {:: a1 c} sublist (suc index))
  }

\func weakening-extend-right {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                             (subst : Substitution context-a context-b ms)
                             (t : Term env context-a s ms)
  : Substitution.apply (weakening t (SubList.extend-right-single SubList.identity {context-c})) (append-context-right subst) = weakening (Substitution.apply t subst) (SubList.extend-right-single SubList.identity) =>
  rewrite weakening-as-substitution-eq (rewrite weakening-as-substitution-eq (rewrite subst-comm-for-weakening (rewrite subst-comm-for-weakening-2 (pmap (Substitution.apply t) (ext (\lam i => rewriteI weakening-as-substitution-eq ((untransport subst (SubList.sublist-trivial-skip) (var i idp) var-witness idp))))))))
  \where {
    \func subst-comm-for-weakening
      {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
      (subst : Substitution context-b context-c ms)
      (t : Term env context-a s ms)
      (sublist : SubList context-a context-b)
      :
      Substitution.apply (Substitution.apply t (weakening-as-substitution (sublist))) (subst) =
      Substitution.apply t (\lam i => Substitution.apply (Substitution.apply (var i idp) (weakening-as-substitution (sublist))) (subst)) \elim t
      | var index idp => idp
      | metavar m choosing => pmap (metavar m) (ext (\lam index => subst-comm-for-weakening subst (choosing index) sublist))
      | func f choosing => pmap (func f)
          (ext (\lam index => \let inductive => subst-comm-for-weakening (append-context-right subst) (choosing index) (SubList.extend-right-both sublist)
                              \in rewrite weakening-rewriting (inductive *> pmap (Substitution.apply (choosing index))
                                                                                (ext (\lam index1 => (rewriteI weakening-rewriting (wsubst-over-right-extension subst sublist index1)))))))

    \func subst-comm-for-weakening-2
      {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
      (subst : Substitution context-a context-b ms)
      (t : Term env context-a s ms)
      (sublist : SubList context-b context-c)
      : Substitution.apply (Substitution.apply t subst) (weakening-as-substitution sublist) = Substitution.apply t (\lam i => Substitution.apply (subst i) (weakening-as-substitution sublist)) \elim t
      | var index idp => idp
      | metavar m choosing => pmap (metavar m) (ext (\lam index => subst-comm-for-weakening-2 subst (choosing index) sublist))
      | func f choosing => pmap (func f)
          (ext (\lam index => \let inductive => subst-comm-for-weakening-2 (append-context-right subst) (choosing index) (SubList.extend-right-both sublist)
                              \in rewrite weakening-rewriting (inductive *> (pmap (Substitution.apply (choosing index)) (ext (\lam index1 => rewriteI weakening-rewriting (wsubst-over-right-extension-2 subst sublist index1)))))))

    \func wsubst-over-right-extension
      {env : FSignature} {context-a context-b context-c context-add : List Sort} {ms : MetaContext Sort}
      (subst : Substitution context-b context-c ms)
      (sublist : SubList context-a context-b)
      (index : Fin (length (context-a ++ context-add)))
      : Substitution.apply (append-context-right (weakening-as-substitution sublist) index) (append-context-right subst) = append-context-right (\lam i => Substitution.apply (weakening-as-substitution sublist i) subst) index =>
      partial-fin-induction
          (\lam fin => Substitution.apply (append-context-right (weakening-as-substitution sublist) fin) (append-context-right subst) = append-context-right (\lam i => Substitution.apply (weakening-as-substitution sublist i) subst) fin)
          (\lam fin => repeat {2} (rewrite append-context-right-begin) (untransport subst sublist (weakening-as-substitution sublist fin) var-witness _))
          (\lam fin => repeat {2} (rewrite append-context-right-end) (rewrite local-untransport (rewrite ((weakening.recalculate-index-over-left-extension-generic fin {(expand-fin-eq-late {env.Sort} {context-a} {context-add} fin)}).2) (rewrite append-context-right-end (rewrite ((weakening.recalculate-index-over-left-extension-generic fin {(expand-fin-eq-late {env.Sort} {context-a} {context-add} fin)}).2) (rewrite ((weakening.recalculate-index-over-left-extension-generic fin {_}).2) (local-untransport-2 _ fin _ _)))))))
          index
      \where {
        \func local-untransport-2 {env : FSignature} {context-c : List Sort} {context-add : List Sort} {s s' : Sort} {mc : MetaContext Sort}
          (eq : s = s')
                                  (ind : Fin (length (context-add)))
                                  (eq' : s = (context-c ++ context-add) !! (expand-fin-late ind))
                                  (eq'' : s' = (context-c ++ context-add) !! (expand-fin-late ind))
          : transport (Term env (context-c ++ context-add) __ mc) eq (var (expand-fin-late ind) eq') = var (expand-fin-late ind) eq'' \elim eq
          | idp => var-extensionality _ _ idp _ _

        \func local-untransport {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {mc : MetaContext Sort}
                                (i1 : Fin (length (context-a ++ context-c))) (eq1 : s = (context-a ++ context-c) !! i1)
                                (subst : Substitution context-a context-b mc)
          : Substitution.apply (var i1 eq1) (append-context-right subst) = transport (Term env (context-b ++ context-c) __ mc) (inv eq1) (append-context-right subst i1) \elim eq1
          | idp => idp
      }

    \func wsubst-over-right-extension-2
      {env : FSignature} {context-a context-b context-c context-add : List Sort} {ms : MetaContext Sort}
      (subst : Substitution context-a context-b ms)
      (sublist : SubList context-b context-c)
      (index : Fin (length (context-a ++ context-add)))
      : Substitution.apply (append-context-right subst index) (append-context-right (weakening-as-substitution sublist)) = append-context-right (\lam i => Substitution.apply (subst i) (weakening-as-substitution sublist)) index =>
      partial-fin-induction
          (\lam fin => Substitution.apply (append-context-right subst fin) (append-context-right (weakening-as-substitution sublist)) = append-context-right (\lam i => Substitution.apply (subst i) (weakening-as-substitution sublist)) fin)
          (\lam fin => repeat {2} (rewrite append-context-right-begin) (rewrite weakening-rewriting (repeat {2} (rewriteI weakening-as-substitution-eq) (double-weakening _ (subst fin) _))))
          (\lam fin => repeat {2} (rewrite append-context-right-end) (rewrite weakening-rewriting (rewriteI weakening-as-substitution-eq (var-extensionality _ _ (rewrite weakening.recalculate-index-to-fpr (rewrite ((weakening.recalculate-index-over-left-extension-generic fin {_}).2 ) (rewrite ((weakening.recalculate-index-over-left-extension-generic fin {_}).2 ) (unrecalculate sublist fin)))) _ _))))
          index
      \where {
        \func unrecalculate {A : \Set} {a b c : List A} (sublist : SubList a b) (fin : Fin (length c)) : weakening.recalculate-index-fpr (SubList.extend-right-both sublist) (expand-fin-late fin) = expand-fin-late fin \elim a, b, c, sublist, fin
          | nil, nil, :: a c, sublist-trivial, 0 => idp
          | nil, nil, :: a c, sublist-trivial, suc fin => pmap fsuc (unrecalculate sublist-trivial fin)
          | :: x a, :: y b, c, sublist-match p sublist, fin => pmap fsuc (unrecalculate sublist fin)
          | nil, :: y b, :: a c, sublist-skip sublist, 0 => pmap fsuc (unrecalculate sublist 0)
          | nil, :: y b, :: a c, sublist-skip sublist, suc fin => pmap fsuc (unrecalculate {_} {_} {_} {:: a c} sublist (suc fin))
          | :: a a1, :: y b, c, sublist-skip sublist, fin => pmap fsuc (unrecalculate sublist fin)

        \func double-weakening {env : FSignature} {context context' context-add : List Sort} {s s' : Sort} {mc : MetaContext Sort}
                               (eq : s = s')
                               (t : Term env context s mc)
                               (sublist : SubList context context'): weakening (weakening (transport (\lam (p0 : env.Sort) => Term env context p0 mc) (eq) (t))
            (SubList.extend-right-single SubList.identity {context-add})) (SubList.extend-right-both sublist) =
        weakening (transport (\lam (p0 : env.Sort) => Term env context' p0 mc) (eq) (weakening (t) sublist))
            (SubList.extend-right-single SubList.identity) \elim eq, t
          | idp, t => unfold transport (rewrite double-append-context-right.end-over-transport-3.weakening-composition (rewrite double-append-context-right.end-over-transport-3.weakening-composition (pmap (weakening t) (composition-lemma sublist))))

        \func composition-lemma {A : \Set} {a b c : List A} (sublist : SubList a b)
          : double-append-context-right.end-over-transport-3.sublist-compose
            (SubList.extend-right-single SubList.identity {c}) (SubList.extend-right-both sublist) = double-append-context-right.end-over-transport-3.sublist-compose sublist (SubList.extend-right-single SubList.identity) \elim a, b, c, sublist
          | nil, nil, nil, sublist-trivial => idp
          | nil, nil, :: a c, sublist-trivial => pmap sublist-skip (composition-lemma sublist-trivial)
          | :: x a, :: y b, c, sublist-match p sublist => rewrite idp_*> (pmap (sublist-match p) (composition-lemma sublist))
          | :: a a2, :: y b, c, sublist-skip sublist => \let inductive => composition-lemma {_} {_} {_} {c} sublist \in pmap (sublist-skip) inductive
          | nil, :: y b, nil, sublist-skip sublist => pmap (sublist-skip) (decompose-along-reduction.any-nil-sublist-equate _ _)
          | nil, :: y b, :: a1 c, sublist-skip sublist => \let inductive => composition-lemma {_} {_} {_} {:: a1 c} sublist \in pmap (sublist-skip) (decompose-along-reduction.any-nil-sublist-equate _ _ *> inductive)
      }

    \func untransport {env : FSignature} {context-a context-b context-c context-add : List Sort} {s s' : Sort} {ms : MetaContext Sort}
                      (subst : Substitution context-b context-c ms)
                      (sublist : SubList context-a context-b)
                      (t : Term env context-b s ms)
                      (var-witness : VarWitness t)
                      (eq : s = s')
      :  Substitution.apply
        (weakening (transport (\lam (p0 : env.Sort) => Term env context-b p0 ms) (eq) t)
            (SubList.extend-right-single SubList.identity)) (append-context-right subst {context-add}) = weakening (transport (\lam (p0 : env.Sort) => Term env context-c p0 ms) (eq)
        (Substitution.apply t subst)) (SubList.extend-right-single SubList.identity) \elim t, var-witness, eq
      | var index idp, var-witness, idp => rewrite reapply (rewrite (weakening.recalculate-index-over-right-extension index).2 (rewrite append-context-right-begin (unifying-lemma subst _ _ _)))

    \data VarWitness {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort} (t : Term env context s ms) \elim t
      | var index p => var-witness

    \func weakening-rewriting
      {env : FSignature} {context-a context-b context-c : List Sort} {ms : MetaContext Sort}
      (sublist : SubList context-a context-b)
      : append-context-right (weakening-as-substitution sublist) = weakening-as-substitution (SubList.extend-right-both sublist {context-c}) {ms} =>
      ext (unext sublist)
      \where {
        \func unext {env : FSignature} {context-a context-b context-c : List Sort} {ms : MetaContext Sort}
                    (sublist : SubList context-a context-b)
                    (i : Fin (length (context-a ++ context-c)))
          : append-context-right (weakening-as-substitution sublist) i = weakening-as-substitution (SubList.extend-right-both sublist {context-c}) {ms} i =>
          partial-fin-induction
              (\lam fin => append-context-right (weakening-as-substitution sublist) fin = weakening-as-substitution (SubList.extend-right-both sublist {context-c}) {ms} fin)
              (\lam fin => rewrite append-context-right-begin (unfold weakening-as-substitution (equalize-indices (inv (expand-fin-eq fin)) (weakening.recalculate-index sublist fin idp).1 (weakening.recalculate-index sublist fin idp).2 _ _ (SubList.extend-right-single SubList.identity) (rewrite (weakening.recalculate-index-to-fpr ((SubList.extend-right-both sublist)) (expand-fin fin) idp) (transport (__ = weakening.recalculate-index-fpr (SubList.extend-right-both sublist) (expand-fin fin)) (inv (weakening.recalculate-index-to-fpr (SubList.extend-right-single SubList.identity) (weakening.recalculate-index sublist fin idp).1 (weakening.recalculate-index sublist fin idp).2)) (rewrite weakening.recalculate-index-to-fpr (recalculation-2 fin sublist)))))))
              (\lam fin => rewrite append-context-right-end (var-extensionality _ _ (repeat {2} (rewrite weakening.recalculate-index-to-fpr) (recalculation fin sublist)) _ _))
              i

        \func equalize-indices  {env : FSignature} {cb cc : List Sort} {s s' : Sort} {ms : MetaContext Sort}
                                (eq : s = s') (i1 : Fin (length (cb))) (eq1 : s = cb !! i1) (i2 : Fin (length cc)) (eq2 : s' = cc !! i2)
                                (sublist : SubList cb cc)
                                (geq : (weakening.recalculate-index sublist i1 eq1).1 = i2)
          : weakening (transport (Term env cb __ ms) eq (var i1 eq1)) sublist = var i2 eq2 \elim eq
          | idp => var-extensionality _ _ geq _ _

        \func recalculation-2 {A : \Set} {a b c : List A}
                              (fin : Fin (length a))
                              (sublist : SubList a b): weakening.recalculate-index-fpr
            (SubList.extend-right-single SubList.identity {c}) (weakening.recalculate-index-fpr sublist fin) = weakening.recalculate-index-fpr (SubList.extend-right-both sublist) (expand-fin fin) \elim a, b, c, fin, sublist
          | :: x a, :: y b, nil, 0, sublist-match p sublist => idp
          | :: x a, :: y b, nil, suc fin, sublist-match p sublist => pmap fsuc (recalculation-2 fin sublist)
          | :: x a, :: y b, :: a1 c, 0, sublist-match p sublist => idp
          | :: x a, :: y b, :: a1 c, suc fin, sublist-match p sublist => pmap fsuc (recalculation-2 fin sublist)
          | nil, :: y b, nil, fin, sublist-skip sublist => pmap fsuc (recalculation-2 fin sublist)
          | :: a a1, :: y b, nil, fin, sublist-skip sublist => pmap fsuc (recalculation-2 fin sublist)
          | nil, :: y b, :: a1 c, fin, sublist-skip sublist => pmap fsuc (recalculation-2 fin sublist)
          | :: a a2, :: y b, :: a1 c, fin, sublist-skip sublist => pmap fsuc (recalculation-2 fin sublist)

        \func recalculation {A : \Set} {a b c : List A}
                            (fin : Fin (length c))
                            (sublist : SubList a b) :
          weakening.recalculate-index-fpr (SubList.extend-left-single SubList.identity {b}) fin = weakening.recalculate-index-fpr (SubList.extend-right-both sublist {c}) (expand-fin-late fin) \elim a, b, c, fin, sublist
          | nil, nil, :: a c, fin, sublist-trivial => idp
          | :: x a, :: y b, :: a1 c, fin, sublist-match p sublist => pmap fsuc (recalculation {_} {_} {_} {:: a1 c} (fin) sublist)
          | nil, :: y b, :: a1 c, fin, sublist-skip sublist => \let inductive => recalculation {_} {_} {_} {:: a1 c} (fin) sublist \in pmap fsuc (inductive)
          | :: a a2, :: y b, :: a1 c, fin, sublist-skip sublist => pmap fsuc (recalculation {_} {_} {_} {:: a1 c} (fin) sublist)
      }

    \func reapply {env : FSignature} {context wide-context : List Sort} {s : Sort} {ms : MetaContext Sort} (i : Fin (length context)) (eq : s = context !! i)
                  (subst : Substitution context wide-context ms) : Substitution.apply (var i eq) subst = transport (Term env wide-context __ ms) (inv eq) (subst i) \elim eq
      | idp => idp

    \func unifying-lemma {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                         (subst : Substitution context-a context-b ms)
                         (index : Fin (length context-a))
                         (eq1 eq2 : s = context-a !! index) :
      transport (Term env (context-b ++ context-c) __ ms)
          (eq1)
          (weakening (transport (Term env context-b __ ms) (inv eq2) (subst index))
              (SubList.extend-right-single SubList.identity)) = weakening (subst index) (SubList.extend-right-single SubList.identity) \elim eq1
      | idp => \let q : eq2 = idp => Path.inProp _ _ \in rewrite q idp
  }

\func weakening-extend-left {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                            (subst : Substitution context-a context-b ms)
                            (t : Term env context-c s ms)
  : Substitution.apply (weakening t (SubList.extend-left-single SubList.identity {context-a})) (append-context-right subst) = weakening (t) (SubList.extend-left-single SubList.identity) \elim t
  | var index idp => rewrite weakening-extend-right.reapply (rewrite weakening.recalculate-index-over-left-extension' (rewrite append-context-right-end (unifying-lemma subst _ _)))
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-extend-left subst (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => {?}))
  \where {
    \func unifying-lemma {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                         (subst : Substitution context-a context-b ms)
                         (index : Fin (length context-c))
                         (eq : s = context-c !! index)
      : transport (\lam (p0 : env.Sort) => Term env (context-b ++ context-c) p0 ms) (inv (inv (eq)))
        (var (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index (eq)).1
            (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index (eq)).2) = var (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index idp).1
                                                                                                                                  (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index idp).2 \elim eq
      | idp => idp
  }

\func weakening-append-left {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                            (subst : Substitution context-b (context-a ++ context-c) ms)
                            (t : Term env context-a s ms)
  :
  Substitution.apply (weakening t (SubList.extend-right-single SubList.identity)) (extend-substitution-left (SubList.extend-right-single SubList.identity) subst)
    =
  weakening t (SubList.extend-right-single SubList.identity)
\elim t
  | var index idp => rewrite weakening-extend-right.reapply (rewrite (weakening.recalculate-index-over-right-extension index).2 (rewrite extend-substitution-left.for-left-context (unifying-lemma subst index _ _ _)))
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-append-left subst (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => {?}))
    \where {
      \func unifying-lemma
        {env : FSignature} {context-a context-b context-c : List Sort} {s s' : Sort} {ms : MetaContext Sort}
        (subst : Substitution context-b (context-a ++ context-c) ms)
        (index : Fin (length context-a))
        (eq : s = s')
        (eq' : s' = context-a !! index)
        (eq'' : s = (context-a ++ context-c) !! (weakening.recalculate-index (SubList.extend-right-single SubList.identity) index idp).1)
        : transport (\lam (p0 : env.Sort) => Term env (context-a ++ context-c) p0 ms)
          (inv eq)
          (var (weakening.recalculate-index (SubList.extend-right-single SubList.identity) index (eq')).1
              (weakening.recalculate-index (SubList.extend-right-single SubList.identity) index (eq')).2) = var (weakening.recalculate-index (SubList.extend-right-single SubList.identity) index idp).1 eq'' \elim eq
        | idp => var-extensionality _ _ (repeat {2} (rewrite weakening.recalculate-index-to-fpr) idp) _ _
    }

\func weakening-append-right {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                             (subst : Substitution context-b (context-a ++ context-c) ms)
                             (t : Term env context-b s ms)
  :
  Substitution.apply (weakening t (SubList.extend-left-single SubList.identity)) (extend-substitution-left (SubList.extend-right-single SubList.identity) subst)
    =
  Substitution.apply t subst
\elim t
  | var index idp => rewrite weakening-extend-right.reapply (rewrite weakening.recalculate-index-over-left-extension' (rewrite extend-substitution-left.for-right-context (rewrite transport_inv_id idp)))
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-append-right subst (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => {?}))

\func weakening-over-identity {env : FSignature} {context : List Sort} {s : Sort} {mc : MetaContext Sort} (t : Term env context s mc) : weakening t SubList.identity = t \elim t
  | var index idp => var-extensionality _ _ (rewrite weakening.recalculate-index-over-identity idp) _ _
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-over-identity (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => rewrite extend-lemma (weakening-over-identity (choosing index))))
  \where {
    \func extend-lemma {A : \Type} {a b : List A} : SubList.extend-right-both (SubList.identity {_} {a}) {b} = SubList.identity \elim a
      | nil => idp
      | :: a a1 => pmap (sublist-match idp) (extend-lemma)
  }

\func subst-composition {env : FSignature} {context-a context-b context-c : List Sort} {mc : MetaContext Sort}
                        (subst-a : Substitution context-a context-b mc)
                        (subst-b : Substitution context-b context-c mc)
  : Substitution context-a context-c mc => \lam i => Substitution.apply (subst-a i) subst-b

\func apply-composition {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {mc : MetaContext Sort}
                        (subst-a : Substitution context-a context-b mc)
                        (subst-b : Substitution context-b context-c mc)
                        (t : Term env context-a s mc) : Substitution.apply t (\lam i => Substitution.apply (subst-a i) subst-b) = Substitution.apply (Substitution.apply t subst-a) subst-b \elim t
  | var index idp => idp
  | metavar m choosing => pmap (metavar m) (ext (\lam index => apply-composition subst-a subst-b (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => (pmap (Substitution.apply (choosing index)) (ext (distribute-append-context-right subst-a subst-b))) *> apply-composition (append-context-right subst-a) (append-context-right subst-b) (choosing index)))
  \where {
    \func distribute-append-context-right {env : FSignature} {context-a context-b context-c context-add : List Sort} {mc : MetaContext Sort}
                                          (subst-a : Substitution context-a context-b mc)
                                          (subst-b : Substitution context-b context-c mc)
                                          (i : Fin (length (context-a ++ context-add)))
      : append-context-right (\lam i => Substitution.apply (subst-a i) subst-b) {context-add} i = Substitution.apply (append-context-right subst-a i) (append-context-right subst-b) =>
      partial-fin-induction
          (\lam fin => append-context-right (subst-composition subst-a subst-b) {context-add} fin = subst-composition (append-context-right subst-a) (append-context-right subst-b) fin)
          (\lam i1 => rewrite append-context-right-begin (unfold subst-composition (rewrite append-context-right-begin (Jl (\lam s eq => weakening (transport (Term env context-c __ mc) (eq) (Substitution.apply (subst-a i1) subst-b))
              (SubList.extend-right-single SubList.identity) = Substitution.apply
                                                                   (weakening (transport (Term env context-b __ mc) (eq) (subst-a i1))
                                                                       (SubList.extend-right-single SubList.identity)) (append-context-right subst-b)) (unfold transport (rewrite weakening-as-substitution-eq (rewrite weakening-as-substitution-eq ({?})))) (inv (expand-fin-eq i1))))))
          (\lam i1 => rewrite append-context-right-end (unfold subst-composition (rewrite append-context-right-end {?})))
          i

    \func untransport {env : FSignature} {context-b context-c context-add : List Sort} {s s' : Sort} {mc : MetaContext Sort}
                      (eq : s = s')
                      (t : Term env context-b s mc)
                      (subst-b : Substitution context-b context-c mc)
      :
      Substitution.apply
          (weakening (transport (\lam (p0 : env.Sort) => Term env context-b p0 mc) (eq) (t))
              (SubList.extend-right-single SubList.identity {context-add})) (append-context-right subst-b) = weakening (transport (\lam (p0 : env.Sort) => Term env context-c p0 mc) (eq) (Substitution.apply (t) subst-b))
                                                                                                                 (SubList.extend-right-single SubList.identity) \elim eq
      | idp => {?}
  }

\func equating-lemma {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                     (subst : Substitution context-a context-b ms) (i : Fin (length context-c))
  : Substitution.apply ((weakening-as-substitution (SubList.extend-left-single SubList.identity {context-a})) i) (append-context-right subst) =
(weakening-as-substitution (SubList.extend-left-single SubList.identity)) i => {?}

\func double-apply {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                   (subst : Substitution context-a context-b ms) (subst2 : Substitution context-b context-c ms)
                   (t : Term env context-a s ms) : Term env context-c s ms =>
  Substitution.apply (Substitution.apply t subst) subst2

\func double-apply-ext {env : FSignature} {context-a context-b context-c context-d : List Sort} {s : Sort} {ms : MetaContext Sort}
                       (subst : Substitution context-a context-b ms) (subst2 : Substitution context-b context-c ms)
                       (subst3 : Substitution context-a context-d ms) (subst4 : Substitution context-d context-c ms)
                       (ext' : \Pi (i : Fin (length (context-a))) -> Substitution.apply (subst i) subst2 = Substitution.apply (subst3 i) subst4)
                       (t : Term env context-a s ms)
  : double-apply subst subst2 t = double-apply subst3 subst4 t \elim t
  | var index idp => unfold double-apply (ext' index)
  | metavar m choosing => {?}
  | func f choosing => unfold double-apply (pmap (func f)
      (ext (\lam index => double-apply-ext (append-context-right subst) (append-context-right subst2) (append-context-right subst3) (append-context-right subst4) (\lam i => {?}) (choosing index))))
  \where {
    \func double-apply-lemma {env : FSignature} {context-a context-b context-c context-d context-add : List Sort} {s : Sort} {ms : MetaContext Sort}
                             (subst : Substitution context-a context-b ms) (subst2 : Substitution context-b context-c ms)
                             (subst3 : Substitution context-a context-d ms) (subst4 : Substitution context-d context-c ms)
                             (ext' :  \Pi (i : Fin (length (context-a))) -> Substitution.apply (subst i) subst2 = Substitution.apply (subst3 i) subst4)
                             (i : Fin (length (context-a ++ context-add))) : Substitution.apply (append-context-right subst i) (append-context-right subst2) = Substitution.apply (append-context-right subst3 i) (append-context-right subst4) =>
      partial-fin-induction
          (\lam fin => Substitution.apply (append-context-right subst fin) (append-context-right subst2) = Substitution.apply (append-context-right subst3 fin) (append-context-right subst4))
          (\lam i1 => \let fromext => ext' i1 \in rewrite append-context-right-begin (rewrite append-context-right-begin {?}))
          {?}
          i

    \func untransport {env : FSignature} {context-b context-c context-d context-add : List Sort} {s s' : Sort} {mc : MetaContext Sort}
                      (subst2 : Substitution context-b context-c mc)
                      (subst4 : Substitution context-d context-c mc)
                      (eq : s = s')
                      (t : Term env context-b s mc)
                      (t' : Term env context-d s mc)
      :
      Substitution.apply
          (weakening (transport (\lam (p0 : env.Sort) => Term env context-b p0 mc) (eq) (t))
              (SubList.extend-right-single SubList.identity {context-add})) (append-context-right subst2) =
      Substitution.apply
          (weakening (transport (\lam (p0 : env.Sort) => Term env context-d p0 mc) (eq) (t'))
              (SubList.extend-right-single SubList.identity)) (append-context-right subst4) \elim eq
      | idp => unfold transport (rewrite weakening-as-substitution-eq (rewrite weakening-as-substitution-eq {?}))
  }
