\import Arith.Nat
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.List
\import TRS.Union
\import TRS.Union.TopLevel
\import TRS.Utils

\func plain-identity {env : FSignature} {context : List Sort} {mc : MetaContext Sort} : Substitution context context mc =>
  \lam i => var i idp

\func wide-identity {env : FSignature} {context wide-context : List Sort} (sublist : SubList context wide-context) {mc : MetaContext Sort} : Substitution context wide-context mc =>
  \lam i => weakening (var i idp) sublist

\lemma plain-identity-effect {env : FSignature} {context : List Sort} {s : Sort} {mc : MetaContext Sort}
                             (t : Term env context s mc)
  : Substitution.apply t plain-identity = t \elim t
  | var index p => \case \elim s, \elim p \with {
    | s, idp => idp
  }
  | metavar m choosing => pmap (metavar m) (ext (\lam index => plain-identity-effect (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => rewrite append-context-right-to-identity.ext' (plain-identity-effect (choosing index))))

\func append-context-left
  {env : FSignature} {old-context new-context : List Sort} {mc : MetaContext Sort}
  {additional-context : List Sort}
  (subst : Substitution old-context new-context mc)
  (index : Fin (length (additional-context ++ old-context)))
  : Term env (additional-context ++ new-context) ((additional-context ++ old-context) !! index) mc
\elim additional-context, index
  | nil, index => subst index
  | :: a additional-context, zero => var zero idp
  | :: a additional-context, suc index => weakening (append-context-left subst index) (sublist-skip SubList.identity)

\func append-context-right
  {env : FSignature} {old-context new-context : List Sort} {mc : MetaContext Sort}
  (subst : Substitution old-context new-context mc)
  {additional-context : List Sort}
  (index : Fin (length (old-context ++ additional-context)))
  : Term env (new-context ++ additional-context) ((old-context ++ additional-context) !! index) mc
\elim old-context, index
  | nil, index => weakening (var index idp) (SubList.extend-left-single SubList.identity)
  | :: a old-context, zero => weakening (subst 0) (SubList.extend-right-single SubList.identity)
  | :: a old-context, suc index => append-context-right (\lam i => subst (suc i)) index

\lemma append-context-right-begin  {env : FSignature} {old-context new-context : List Sort} {mc : MetaContext Sort}
                                   {additional-context : List Sort}
                                   (subst : Substitution old-context new-context mc)
                                   (index : Fin (length (old-context)))
  : append-context-right subst (expand-fin index) =
weakening (transport (Term env (new-context) __ mc) (inv (expand-fin-eq {_} {_} {additional-context} index)) (subst index)) (SubList.extend-right-single SubList.identity) \elim old-context, index
  | :: a old-context, 0 => idp
  | :: a old-context, suc index => append-context-right-begin (\lam i => subst (suc i)) index

\lemma append-context-right-end
  {env : FSignature} {old-context new-context : List Sort} {mc : MetaContext Sort}
  {additional-context : List Sort}
  (subst : Substitution old-context new-context mc)
  (index : Fin (length (additional-context)))
  : append-context-right subst (expand-fin-late {_} {old-context} {additional-context} index) =
weakening (var index (expand-fin-eq-late index)) (SubList.extend-left-single SubList.identity) \elim old-context
  | nil => idp
  | :: a old-context => append-context-right-end (\lam i => subst (suc i)) index

\func weakening {env : FSignature} {s' : Sort} {narrow-context wide-context : List Sort} {mc : MetaContext Sort}
                (t : Term env narrow-context s' mc)
                (sublist : SubList narrow-context wide-context)
  : Term env wide-context s' mc \elim t
  | var index p => to-var (recalculate-index sublist index p)
  | metavar m choosing => metavar m (\lam i1 => weakening (choosing i1) sublist)
  | func f choosing => func f (\lam i1 => weakening (choosing i1) (SubList.extend-right-both sublist))
  \where {
    \func recalculate-index {A : \Set} {a b : List A} {point : A} (sublist : SubList a b) (ind : Fin (length a)) (p : point = a !! ind) : \Sigma (ind' : Fin (length b)) (point = b !! ind') \elim a, b, sublist, ind, p
      | :: x xs, :: y ys, sublist-match p sublist, zero, idp => (zero, p)
      | :: x xs, :: y ys, sublist-match p sublist, suc ind, idp => \let (ind', p') => recalculate-index sublist ind idp \in (suc ind', p')
      | l, :: y ys, sublist-skip sublist, ind, idp => \let (ind', p') => recalculate-index sublist ind idp \in (suc ind', p')

    \func recalculate-index-fpr {A : \Set} {a b : List A} (sublist : SubList a b) (ind : Fin (length a)) : Fin (length b) \elim a, b, sublist, ind
      | :: x xs, :: y ys, sublist-match p sublist, zero => zero
      | :: x xs, :: y ys, sublist-match p sublist, suc ind => suc (recalculate-index-fpr sublist ind)
      | l, :: y ys, sublist-skip sublist, ind => suc (recalculate-index-fpr sublist ind)

    \func recalculate-index-to-fpr  {A : \Set} {a b : List A} {point : A} (sublist : SubList a b) (ind : Fin (length a)) (p : point = a !! ind) : (recalculate-index sublist ind p).1 = recalculate-index-fpr sublist ind \elim a, b, sublist, ind, p
      | :: x a, :: y b, sublist-match p sublist, 0, idp => idp
      | :: x a, :: y b, sublist-match p sublist, suc ind, idp => rewriteI (recalculate-index-to-fpr sublist ind idp) idp
      | :: a a1, :: y b, sublist-skip sublist, ind, idp => rewriteI (recalculate-index-to-fpr sublist ind idp) idp

    \lemma recalculate-index-over-identity {A : \Set} {a : List A} (ind : Fin (length a)) : recalculate-index SubList.identity ind idp = (ind, idp) \elim a, ind
      | :: a a1, zero => idp
      | :: a a1, suc ind => rewrite recalculate-index-over-identity idp

    \lemma recalculate-index-over-shrink {A : \Set} {x : A} {p : A} {a b : List A} (sublist : SubList (x :: a) b) (ind : Fin (length a)) (eq : p = a !! ind)
      : recalculate-index (SubList.shrink sublist) ind eq = recalculate-index sublist (suc ind) eq
    \elim a, b, sublist, ind, eq
      | nil, :: y b, sublist-match p1 sublist, ind, idp => idp
      | :: a a1, :: y b, sublist-match p1 sublist, ind, idp => idp
      | nil, :: y b, sublist-skip sublist, (), eq
      | :: a a1, :: y b, sublist-skip sublist, ind, idp => rewrite (recalculate-index-over-shrink sublist ind idp) idp

    \lemma recalculate-index-over-right-extension {A : \Set} {a b : List A} (ind : Fin (length a)) :
      \Sigma (eq : (a !! ind) = (a ++ b) !! expand-fin ind) (recalculate-index {A} {a} {a ++ b} (SubList.extend-right-single SubList.identity {b}) ind idp = (expand-fin {A} {a} {b} ind, eq)) \elim a, ind
      | :: a a1, 0 => (idp, idp)
      | :: a a1, suc ind => \let | (eq-custom, b-eq) => recalculate-index-over-right-extension {_} {a1} {b} ind
                                 | (ind', q') => recalculate-index (SubList.extend-right-single SubList.identity {b}) ind idp
                            \in (eq-custom, rewrite b-eq idp)

    \lemma recalculate-index-over-right-extension' {A : \Set} {a b : List A} (ind : Fin (length a)) :
      \Sigma (eq : (a ++ b) !! expand-fin ind = (a !! ind)) (recalculate-index {A} {a} {a ++ b} (SubList.extend-right-single SubList.identity {b}) ind eq = (expand-fin {A} {a} {b} ind, idp)) \elim a, ind
      | :: a a1, 0 => (idp, idp)
      | :: a a1, suc ind => \let | (eq-custom, b-eq) => recalculate-index-over-right-extension' {_} {a1} {b} ind
                                 | (ind', q') => recalculate-index (SubList.extend-right-single SubList.identity {b}) ind idp
                            \in (eq-custom, recalculate-over-match {A} {a1} {a1 ++ b} (SubList.extend-right-single SubList.identity {b}) ind eq-custom *> (rewrite b-eq idp))

    \lemma recalculate-index-over-left-extension {A : \Set} {a b : List A} (ind : Fin (length b)) :
      (recalculate-index {A} {b} {a ++ b} (SubList.extend-left-single SubList.identity {a}) ind (expand-fin-eq-late {_} {a} ind) = (expand-fin-late ind, idp)) \elim a
      | nil => (recalculate-index-over-identity ind)
      | :: a a1 => \let | b-eq => recalculate-index-over-left-extension {_} {a1} {b} ind
                   \in (rewrite (recalculate-over-skip {A} {b} {a1 ++ b} {_} {a} (SubList.extend-left-single SubList.identity) ind (expand-fin-eq-late ind)) (rewrite b-eq idp))

    \lemma recalculate-index-over-left-extension' {A : \Set} {a b : List A} (ind : Fin (length b)) :
      (recalculate-index {A} {b} {a ++ b} (SubList.extend-left-single SubList.identity {a}) ind (idp) = (expand-fin-late ind, inv (expand-fin-eq-late {_} {a} ind))) \elim a
      | nil => (recalculate-index-over-identity ind)
      | :: a a1 => \let b-eq => recalculate-index-over-left-extension' {_} {a1} {b} ind \in rewrite (recalculate-over-skip {A} {b} {a1 ++ b} {_} {a} (SubList.extend-left-single SubList.identity) ind idp) (rewrite b-eq idp)

    \lemma recalculate-over-skip {A : \Set} {a b : List A} {point point' : A} (sublist : SubList a b) (ind : Fin (length a)) (eq : point = a !! ind) :
      recalculate-index {A} {a} {point' :: b} {point} (sublist-skip sublist) ind eq = (\let (ind', eq') => recalculate-index sublist ind eq \in (suc ind', eq')) \elim a, b, sublist, ind, eq
      | :: x a, :: y b, sublist-match p sublist, 0, idp => idp
      | :: x a, :: y b, sublist-match p sublist, suc ind, idp => idp
      | nil, :: y b, sublist-skip sublist, ind, idp => idp
      | :: a a1, :: y b, sublist-skip sublist, ind, idp => idp

    \lemma recalculate-over-match {A : \Set} {a b : List A} {point point' : A} (sublist : SubList a b) (ind : Fin (length a)) (eq : point = a !! (ind)) :
      recalculate-index {A} {point' :: a} {point' :: b} {point} (sublist-match idp sublist) (suc ind) eq = (\let (ind', eq') => recalculate-index sublist ind eq \in (suc ind', eq')) \elim a, b, sublist, ind, eq
      | :: x a, :: y b, sublist-match p sublist, 0, idp => idp
      | :: x a, :: y b, sublist-match p sublist, suc ind, idp => idp
      | nil, :: y b, sublist-skip sublist, ind, idp => idp
      | :: a a1, :: y b, sublist-skip sublist, ind, idp => idp
  }

\func extend-substitution-right
  {env : FSignature} {left-context right-context some-context : List Sort} {mc : MetaContext Sort}
  (sublist : SubList right-context some-context)
  (chooser : Substitution left-context some-context mc)
  (j : Fin (length (left-context ++ right-context)))
  : Term env some-context ((left-context ++ right-context) !! j) mc
\elim left-context, j
  | nil, j => to-var (produce-inner-term sublist j)
  | :: a narrow-context, zero => chooser zero
  | :: a narrow-context, suc j => extend-substitution-right sublist (\lam i => chooser (suc i)) j
  \where {
    \func produce-inner-term {A : \Type} {right-context some-context : List A} (sublist : SubList right-context some-context) (j : Fin (length right-context)) :
      \Sigma (ind : Fin (length some-context)) (right-context !! j = some-context !! ind) \elim right-context, some-context, sublist, j
      | :: x xs, :: y ys, sublist-match p sublist, zero => (0, p)
      | :: x xs, :: y ys, sublist-match p sublist, suc j => \let (ind, q) => produce-inner-term sublist j \in (suc ind, q)
      | l, :: y ys, sublist-skip sublist, j => \let (ind, q) => produce-inner-term sublist j \in (suc ind, q)
  }

\func extend-substitution-left
  {env : FSignature} {left-context right-context some-context : List Sort} {mc : MetaContext Sort}
  (sublist : SubList left-context some-context)
  (chooser : Substitution right-context some-context mc)
  (j : Fin (length (left-context ++ right-context)))
  : Term env some-context ((left-context ++ right-context) !! j) mc \elim left-context, j
  | nil, j => chooser j
  | :: a left-context, 0 => weakening (var 0 idp) sublist
  | :: a left-context, suc j => extend-substitution-left (SubList.shrink sublist) chooser j
  \where {
    \lemma for-left-context
      {env : FSignature} {left-context right-context some-context : List Sort} {mc : MetaContext Sort}
      (sublist : SubList left-context some-context)
      (chooser : Substitution right-context some-context mc)
      (j : Fin (length (left-context))) : extend-substitution-left sublist chooser (expand-fin j) = weakening (var j (expand-fin-eq j)) sublist \elim left-context, j
      | :: a left-context, 0 => idp
      | :: a left-context, suc j => \let inductive => for-left-context (SubList.shrink sublist) chooser j \in inductive *> (pmap to-var (weakening.recalculate-index-over-shrink sublist j (expand-fin-eq j)))

    \lemma for-right-context
      {env : FSignature} {left-context right-context some-context : List Sort} {mc : MetaContext Sort}
      (sublist : SubList left-context some-context)
      (chooser : Substitution right-context some-context mc)
      (j : Fin (length (right-context)))
      : extend-substitution-left sublist chooser (expand-fin-late j) = transport (Term env some-context __ mc) (inv (expand-fin-eq-late j)) (chooser j)
    \elim left-context, j
      | nil, j => idp
      | :: a left-context, j => for-right-context (SubList.shrink sublist) chooser j
  }

\func to-var {env : FSignature} {some-context : List Sort} {s : Sort} {msig : MetaContext Sort} (sig : \Sigma (ind : Fin (length some-context)) (s = some-context !! ind))
  : Term env some-context s msig => var sig.1 sig.2

\lemma append-context-right-to-identity
  {env : FSignature} {old-context : List Sort} {mc : MetaContext Sort}
  {additional-context : List Sort} (i : Fin (length (old-context ++ additional-context)))
  : append-context-right {_} {old-context} {_} {mc}  plain-identity {additional-context} i = plain-identity i =>
  partial-fin-induction
      (\lam i => append-context-right {_} {old-context} {_} {mc} plain-identity {additional-context} i = plain-identity i)
      (\lam i1 => append-context-right-begin plain-identity i1 *>
      (rewrite transport-over-weakening (\let | some-lemma => weakening.recalculate-index-over-right-extension {_} {_} {additional-context} i1
                                         \in rewrite (pmap (to-var) some-lemma.2) (unfold (to-var, plain-identity) (lem2 (expand-fin i1) (some-lemma).1 idp (inv (expand-fin-eq i1)))))))
      (\lam i1 => append-context-right-end plain-identity i1 *> (pmap (to-var {env}) (weakening.recalculate-index-over-left-extension i1)))
      i
  \where {
    \lemma transport-over-weakening {env : FSignature} {context context' : List Sort} {s s' : Sort} {mc : MetaContext Sort}
                                    (T : Term env context s mc) (eq : s = s') (sublist : SubList context context')
      : weakening (transport (Term env context __ mc) eq T) sublist = transport (Term env context' __ mc) eq (weakening T sublist) \elim eq
      | idp => idp

    \lemma lem2  {env : FSignature} {context : List Sort} {s s' : Sort} {mc : MetaContext Sort}
                 (index : Fin (length context)) (eq : s = context !! index) (eq' : s' = context !! index) (eq'' : s = s')
      : transport (Term env context __ mc) eq'' (var index eq)  = var index eq' \elim eq''
      | idp => pmap (var index) (Path.inProp eq eq')

    \lemma ext' {env : FSignature} {old-context : List Sort} {mc : MetaContext Sort}
                {additional-context : List Sort} : (\lam (i : Fin (length (old-context ++ additional-context))) => append-context-right {_} {old-context} {_} {mc}  plain-identity {additional-context} i) = plain-identity =>
      ext append-context-right-to-identity
  }

\lemma double-append-context-right {env : FSignature} {context-a context-res context-b context-c : List Sort} {mc : MetaContext Sort}
                                  (subst : Substitution context-a context-res mc) :
  append-context-right (append-context-right subst)
    =
  transport2 (\lam ctx ctx' => \Pi (index : Fin (length ctx)) ->
      Term env ctx' (ctx !! index) mc) (inv ++-assoc) (inv ++-assoc) (append-context-right subst {context-b ++ context-c}) =>
  ext (unext subst)
  \where {
    \lemma unext {env : FSignature} {context-a context-res context-b context-c : List Sort} {mc : MetaContext Sort}
                (subst : Substitution context-a context-res mc) (i : Fin (length ((context-a ++ context-b) ++ context-c)))
      : append-context-right (append-context-right subst) i = transport2 (\lam ctx ctx' => \Pi (index : Fin (length ctx)) ->
        Term env ctx' (ctx !! index) mc) (inv ++-assoc) (inv ++-assoc) (append-context-right subst {context-b ++ context-c}) i =>
      partial-fin-induction
          (\lam fin =>
              append-context-right (append-context-right subst) fin =
              transport2 (\lam ctx ctx' => \Pi (index : Fin (length (ctx))) -> Term env (ctx') ((ctx) !! index) mc) (inv ++-assoc) (inv ++-assoc) (append-context-right subst {context-b ++ context-c}) fin)
          (\lam i1 => rewrite append-context-right-begin {?})
          (\lam i1 => rewrite append-context-right-end {?})
          i
  }

\func weakening-as-substitution {env : FSignature} {narrow-context wide-context : List Sort} (sublist : SubList narrow-context wide-context) {ms : MetaContext Sort}: Substitution narrow-context wide-context ms =>
  \lam i => to-var (weakening.recalculate-index sublist i idp)

\func substitution-ext {env : FSignature} {context-a context-b : List Sort} {ms : MetaContext Sort}
                       (subst-a subst-b : Substitution context-a context-b ms) (eq : \Pi (i : Fin (length context-a)) -> subst-a i = subst-b i) : subst-a = subst-b =>
  ext eq

\func var-extensionality {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort}
                         (i1 i2 : Fin (length context))
                         (eq : i1 = i2)
                         (p1 : s = context !! i1)
                         (p2 : s = context !! i2) : var {_} {_} {_} {ms} i1 p1 = var i2 p2 \elim eq
  | idp => \let eq' : p1 = p2 => Path.inProp _ _ \in pmap (var i1) eq'

\func weakening-as-substitution-eq  {env : FSignature} {narrow-context wide-context : List Sort} {s : Sort} (sublist : SubList narrow-context wide-context) {ms : MetaContext Sort}
                                    (t : Term env narrow-context s ms) : weakening t sublist = Substitution.apply t (weakening-as-substitution sublist) \elim t
  | var index idp => idp
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-as-substitution-eq sublist (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => weakening-as-substitution-eq (SubList.extend-right-both sublist) (choosing index) *> (pmap (Substitution.apply (choosing index)) (ext (\lam index1 => weakening-commutation-lemma sublist index1)))))
  \where {
    \func weakening-commutation-lemma {env : FSignature}
                                      {narrow-context wide-context add-context : List Sort}
                                      (sublist : SubList narrow-context wide-context) {ms : MetaContext Sort}
                                      (index : Fin (length (narrow-context ++ add-context)))
      : weakening-as-substitution (SubList.extend-right-both sublist) {ms} index = append-context-right (weakening-as-substitution sublist) index =>
      partial-fin-induction
          (\lam i => weakening-as-substitution (SubList.extend-right-both sublist) {ms} i = append-context-right (weakening-as-substitution sublist) i)
          (\lam i => rewrite (append-context-right-begin) ((lemma sublist i _ _)))
          (\lam i => rewrite (append-context-right-end) (unfold weakening-as-substitution (var-extensionality (weakening.recalculate-index (SubList.extend-right-both sublist) (expand-fin-late i) idp).1 (weakening.recalculate-index (SubList.extend-left-single SubList.identity) i (expand-fin-eq-late i)).1 (repeat {2} (rewrite weakening.recalculate-index-to-fpr) (recalculate-rb-vs-ls _ _)) _ _)))
          index

    \func lemma {env : FSignature}
                {s : Sort}
                {narrow-context wide-context add-context : List Sort}
                (sublist : SubList narrow-context wide-context) {ms : MetaContext Sort}
                (index : Fin (length (narrow-context)))
                (eq : s = narrow-context !! index)
                (eq' : s = (narrow-context ++ add-context) !! (expand-fin index))
      : to-var (weakening.recalculate-index (SubList.extend-right-both sublist) (expand-fin index) eq') = weakening (transport (\lam (p0 : env.Sort) => Term env wide-context p0 ms) (inv (eq))
        (to-var (weakening.recalculate-index sublist index idp))) (SubList.extend-right-single SubList.identity) \elim eq
      | idp => var-extensionality
          (weakening.recalculate-index (SubList.extend-right-both sublist) (expand-fin index) eq').1
          (weakening.recalculate-index
              (SubList.extend-right-single SubList.identity) (weakening.recalculate-index sublist index idp).1
              (weakening.recalculate-index sublist index idp).2).1
          (repeat {3} (rewrite weakening.recalculate-index-to-fpr) (recalculate-rb-then-sublist _ _))
          _
          _

    \func recalculate-rb-then-sublist {A : \Set} {a b c : List A} (sublist : SubList a b) (index : Fin (length a)) :
      weakening.recalculate-index-fpr (SubList.extend-right-both sublist {c}) (expand-fin index)
        =
      weakening.recalculate-index-fpr
          (SubList.extend-right-single SubList.identity) (weakening.recalculate-index-fpr sublist index) \elim a, b, sublist, index
      | :: x a, :: y b, sublist-match p sublist, 0 => idp
      | :: x a, :: y b, sublist-match p sublist, suc index => pmap fsuc (recalculate-rb-then-sublist sublist index)
      | nil, :: y b, sublist-skip sublist, ()
      | :: a a1, :: y b, sublist-skip sublist, index => pmap fsuc (recalculate-rb-then-sublist sublist index)

    \func recalculate-rb-vs-ls {A : \Set} {a b c : List A} (sublist : SubList a b) (index : Fin (length c)) :
      weakening.recalculate-index-fpr (SubList.extend-right-both sublist {c}) (expand-fin-late index)
        =
      weakening.recalculate-index-fpr
          (SubList.extend-left-single SubList.identity) index \elim a, b, c, sublist, index
      | nil, nil, :: a c, sublist-trivial, 0 => idp
      | nil, nil, :: a c, sublist-trivial, suc index => idp
      | :: x a, :: y b, :: a1 c, sublist-match p sublist, 0 => pmap fsuc (recalculate-rb-vs-ls sublist 0)
      | :: x a, :: y b, :: a1 c, sublist-match idp sublist, suc index => pmap fsuc (recalculate-rb-vs-ls {A} {a} {b} {:: a1 c} sublist (fsuc index))
      | nil, :: y b, :: a1 c, sublist-skip sublist, 0 => pmap fsuc (recalculate-rb-vs-ls sublist 0)
      | :: a a2, :: y b, :: a1 c, sublist-skip sublist, 0 => pmap fsuc (recalculate-rb-vs-ls sublist 0)
      | nil, :: y b, :: a1 c, sublist-skip sublist, suc index => pmap fsuc (recalculate-rb-vs-ls {A} {nil} {b} {:: a1 c} sublist (suc index))
      | :: a a2, :: y b, :: a1 c, sublist-skip sublist, suc index => pmap fsuc (recalculate-rb-vs-ls {A} {:: a a2} {b} {:: a1 c} sublist (suc index))
  }

\func weakening-extend-right {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                             (subst : Substitution context-a context-b ms)
                             (t : Term env context-a s ms)
  : Substitution.apply (weakening t (SubList.extend-right-single SubList.identity {context-c})) (append-context-right subst) = weakening (Substitution.apply t subst) (SubList.extend-right-single SubList.identity) \elim t
  | var index idp => rewrite reapply (rewrite (weakening.recalculate-index-over-right-extension index).2 (rewrite append-context-right-begin (unifying-lemma subst _ _ _)))
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-extend-right subst (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => {?}))
  \where {
    \func reapply {env : FSignature} {context wide-context : List Sort} {s : Sort} {ms : MetaContext Sort} (i : Fin (length context)) (eq : s = context !! i)
                  (subst : Substitution context wide-context ms) : Substitution.apply (var i eq) subst = transport (Term env wide-context __ ms) (inv eq) (subst i) \elim eq
      | idp => idp

    \func unifying-lemma {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                         (subst : Substitution context-a context-b ms)
                         (index : Fin (length context-a))
                         (eq1 eq2 : s = context-a !! index) :
      transport (Term env (context-b ++ context-c) __ ms)
          (eq1)
          (weakening (transport (Term env context-b __ ms) (inv eq2) (subst index))
              (SubList.extend-right-single SubList.identity)) = weakening (subst index) (SubList.extend-right-single SubList.identity) \elim eq1
      | idp => \let q : eq2 = idp => Path.inProp _ _ \in rewrite q idp
  }

\func weakening-extend-left {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                            (subst : Substitution context-a context-b ms)
                            (t : Term env context-c s ms)
  : Substitution.apply (weakening t (SubList.extend-left-single SubList.identity {context-a})) (append-context-right subst) = weakening (t) (SubList.extend-left-single SubList.identity) \elim t
  | var index idp => rewrite weakening-extend-right.reapply (rewrite weakening.recalculate-index-over-left-extension' (rewrite append-context-right-end (unifying-lemma subst _ _)))
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-extend-left subst (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => {?}))
  \where {
    \func unifying-lemma {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                         (subst : Substitution context-a context-b ms)
                         (index : Fin (length context-c))
                         (eq : s = context-c !! index)
      : transport (\lam (p0 : env.Sort) => Term env (context-b ++ context-c) p0 ms) (inv (inv (eq)))
        (var (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index (eq)).1
            (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index (eq)).2) = var (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index idp).1
                                                                                                                                  (weakening.recalculate-index (SubList.extend-left-single SubList.identity) index idp).2 \elim eq
      | idp => idp
  }

\func weakening-append-left {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                            (subst : Substitution context-b (context-a ++ context-c) ms)
                            (t : Term env context-a s ms)
  :
  Substitution.apply (weakening t (SubList.extend-right-single SubList.identity)) (extend-substitution-left (SubList.extend-right-single SubList.identity) subst)
    =
  weakening t (SubList.extend-right-single SubList.identity)
\elim t
  | var index idp => unfold {?}
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-append-left subst (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => {?}))

\func weakening-append-right {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {ms : MetaContext Sort}
                             (subst : Substitution context-b (context-a ++ context-c) ms)
                             (t : Term env context-b s ms)
  :
  Substitution.apply (weakening t (SubList.extend-left-single SubList.identity)) (extend-substitution-left (SubList.extend-right-single SubList.identity) subst)
    =
  Substitution.apply t subst
\elim t
  | var index idp => {?}
  | metavar m choosing => pmap (metavar m) (ext (\lam index => weakening-append-right subst (choosing index)))
  | func f choosing => pmap (func f) (ext (\lam index => {?}))
