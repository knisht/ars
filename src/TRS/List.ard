\import Arith.Nat
\import Data.List
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Set
\import TRS.Utils
\open Nat

\func map-fixes-length {A B : \Type} {L : List A} {f : A -> B} : length (map f L) = length L \elim L
  | nil => idp
  | :: a L => pmap suc map-fixes-length

-- | `l` is a sublist of `r`
\data SubList {A : \Type} (l r : List A) \elim l, r
  | nil, nil => sublist-trivial
  | :: x xs, :: y ys => sublist-match (x = y) (SubList xs ys)
  | l, :: y ys => sublist-skip (SubList l ys)
  \where {
    \func identity {A : \Type} {list : List A} : SubList list list \elim list
      | nil => sublist-trivial
      | :: a list => sublist-match idp identity

    \func sublist-trivial-skip {A : \Type} {list : List A} : SubList nil list \elim list
      | nil => sublist-trivial
      | :: a list => sublist-skip sublist-trivial-skip

    -- todo: create a meta that automatically extends current sublist predicate to the expected type
    \func extend-left-both {A : \Type} {l r : List A} (sublist : SubList l r) {add : List A} : SubList (add ++ l) (add ++ r) \elim add
      | nil => sublist
      | :: a add => sublist-match idp (extend-left-both sublist)

    \func extend-right-both {A : \Type} {l r : List A} (sublist : SubList l r) {add : List A} : SubList (l ++ add) (r ++ add) \elim l, r, sublist
      | nil, nil, sublist-trivial => SubList.identity
      | :: x l, :: y r, sublist-match p sublist => sublist-match p (extend-right-both sublist)
      | l, :: y r, sublist-skip sublist => sublist-skip (extend-right-both sublist)

    \func extend-right-single {A : \Type} {l r : List A} (sublist : SubList l r) {add : List A} : SubList l (r ++ add) \elim l, r, sublist
      | nil, nil, sublist-trivial => sublist-trivial-skip
      | :: x xs, :: y ys, sublist-match p sublist => sublist-match p (extend-right-single sublist)
      | l, :: y ys, sublist-skip sublist => sublist-skip (extend-right-single sublist)

    \func extend-left-single {A : \Type} {l r : List A} (sublist : SubList l r) {add : List A} : SubList l (add ++ r) \elim add
      | nil => sublist
      | :: a add => sublist-skip (extend-left-single sublist)

    \func extend-middle {A : \Type} (l r add : List A) : SubList (l ++ r) (l ++ add ++ r) \elim l, add
      | nil, nil => identity
      | nil, :: a add => sublist-skip (extend-middle nil r add)
      | :: a l, add => sublist-match idp (extend-middle l r add)

    \func shift-index {A : \Type} {list list' : List A} (index : Fin (length list)) (sublist : SubList list list') : Fin (length list') \elim list, list', index, sublist
      | :: x xs, :: y ys, zero, sublist-match p sublist => zero
      | :: x xs, :: y ys, suc index, sublist-match p sublist => suc (shift-index index sublist)
      | l, :: y ys, index, sublist-skip sublist => suc (shift-index index sublist)
      | nil, :: y ys, (), _

    \func shift-index-preserves-equality {A : \Type} {list list' : List A}
                                (index : Fin (length list))
                                (sublist : SubList list list') : (list !! index = list' !! (shift-index index sublist)) \elim list, list', index, sublist
      | :: x xs, :: y ys, zero, sublist-match p sublist => p
      | :: x xs, :: y ys, suc index, sublist-match p sublist => shift-index-preserves-equality index sublist
      | :: a l, :: y ys, zero, sublist-skip sublist => shift-index-preserves-equality zero sublist
      | :: x xs, :: y ys, suc index, sublist-skip sublist => shift-index-preserves-equality (suc index) sublist
      | nil, :: y ys, (), _


    \func shrink {A : \Type} {a : A} {list list' : List A} (sublist : SubList (a :: list) list') : SubList list list' \elim list', sublist
      | :: y list', sublist-match p sublist => sublist-skip sublist
      | :: y list', sublist-skip sublist => sublist-skip (shrink sublist)

    \func extend-right-identity-eq {A : \Type} {a b : List A}  : SubList.extend-right-both (SubList.identity {_} {a}) = SubList.identity {_} {a ++ b} \elim a
      | nil => idp
      | :: a a1 => pmap (sublist-match idp) (extend-right-identity-eq)
  }

