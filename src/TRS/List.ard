\import Arith.Nat
\import Data.List
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Set
\import TRS.Utils
\open Nat
\func length {A : \Type} (list : List A) : Nat \elim list
  | nil => 0
  | :: a list => suc (length list)

\func map-fixes-length {A B : \Type} {L : List A} {f : A -> B} : length (map f L) = length L \elim L
  | nil => idp
  | :: a L => pmap suc map-fixes-length

\func \infix 7 !! {A : \Type} (v : List A) (index : Fin (length v)) : A \elim v, index
  | :: a v, suc index => v !! index
  | :: a v, zero => a

-- | `l` is a sublist of `r`
\data SubList {A : \Type} (l r : List A) \elim l, r
  | nil, _ => sublist-trivial
  | :: x xs, :: y ys => sublist-match (x = y) (SubList xs ys)
  | l, :: y ys => sublist-skip (SubList l ys)
  \where {
    \func identity {A : \Type} {list : List A} : SubList list list \elim list
      | nil => sublist-trivial
      | :: a list => sublist-match idp identity
  -- todo: create a meta that automatically extends current sublist predicate to the expected type
    \func extend-left {A : \Type} {l r : List A} (sublist : SubList l r) {add : List A} : SubList (add ++ l) (add ++ r) \elim add
      | nil => sublist
      | :: a add => sublist-match idp (extend-left sublist)

    \func extend-right-single {A : \Type} {l r : List A} (sublist : SubList l r) (add : List A) : SubList l (r ++ add) \elim l, r, sublist
      | nil, r, sublist-trivial => sublist-trivial
      | :: x xs, :: y ys, sublist-match p sublist => sublist-match p (extend-right-single sublist add)
      | l, :: y ys, sublist-skip sublist => sublist-skip (extend-right-single sublist add)

    \func extend-right-single-left {A : \Type} {l r : List A} (sublist : SubList l r) {add : List A} : SubList l (add ++ r) \elim l, r, sublist, add
      | nil, nil, sublist-trivial, _ => sublist-trivial
      | nil, :: a r, sublist-trivial, nil => sublist-trivial
      | nil, r, sublist-trivial, :: a x => sublist-trivial
      | _, _, x, nil => x
      | l, r, x, :: a1 add => sublist-skip (extend-right-single-left x)

    \func extend-middle {A : \Type} (l r add : List A) : SubList (l ++ r) (l ++ add ++ r) \elim l, add
      | nil, nil => identity
      | nil, :: a add => sublist-skip (extend-middle nil r add)
      | :: a l, add => sublist-match idp (extend-middle l r add)

    \func shift-index {A : \Type} {list list' : List A} (index : Fin (length list)) (sublist : SubList list list') : Fin (length list') \elim list, list', index, sublist
      | :: x xs, :: y ys, zero, sublist-match p sublist => zero
      | :: x xs, :: y ys, suc index, sublist-match p sublist => suc (shift-index index sublist)
      | l, :: y ys, index, sublist-skip sublist => suc (shift-index index sublist)
      | nil, :: y ys, (), _

    \func shift-index-preserves-equality {A : \Type} {list list' : List A}
                                (index : Fin (length list))
                                (sublist : SubList list list') : (list !! index = list' !! (shift-index index sublist)) \elim list, list', index, sublist
      | :: x xs, :: y ys, zero, sublist-match p sublist => p
      | :: x xs, :: y ys, suc index, sublist-match p sublist => shift-index-preserves-equality index sublist
      | :: a l, :: y ys, zero, sublist-skip sublist => shift-index-preserves-equality zero sublist
      | :: x xs, :: y ys, suc index, sublist-skip sublist => shift-index-preserves-equality (suc index) sublist
      | nil, :: y ys, (), _
  }

\data DescendingVector (n limit : Nat) \elim n
  | 0 => dv-nil
  | suc n => dv-cons (x : Fin limit) (DescendingVector n x)

\func \infix 4 dv!! {n limit : Nat} (vec : DescendingVector n limit) (index : Fin n) : Fin limit \elim n, vec, index
  | suc n, dv-cons x dvec, zero => x
  | suc n, dv-cons x dvec, suc index => promote-fin (dvec dv!! index)

