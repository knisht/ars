\import ARS
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, map, nil)
\import Data.Or
\import Equiv
\import Equiv.Univalence
\import Function
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import TRS.HRS
\import TRS.List
\import TRS.Substitutions
\import TRS.Utils

-- | Family of functional term symbols
\class FSignature {
  | Sort : \Set
  | symbol : Sort -> \Set
  | domain : \Pi {s : Sort} (symbol s) -> List (\Sigma (List Sort) Sort)
    \func \infix 7 !!param {s : Sort} (m : symbol s) (index : Fin (length (domain m))) : List Sort =>
      (domain m !! index).1

    \func \infix 7 !!sort {s : Sort} (m : symbol s) (index : Fin (length (domain m))) : Sort =>
      (domain m !! index).2
  }

\open FSignature

\record MetaContext (Sort : \Set)
  | metaname : Sort -> \Set
  | m-domain : \Pi {s : Sort} (metaname s) -> List Sort

-- | Term of High-order TRS
\data Term (env : FSignature)
           (context : List Sort)
           (termSort : Sort)
           (mc : MetaContext Sort): \Set
  | var (index : Fin (length context)) (termSort = context !! index) -- | Bound variable
  | metavar (m : mc.metaname termSort) -- | Metavariable
            (choosing : \Pi (index : Fin (length (mc.m-domain m))) -> Term env context (mc.m-domain m !! index) mc)
  | func (f : symbol termSort) -- | Functional symbol
         (choosing : \Pi (index : Fin (length (domain f))) -> Term env (context ++ (f !!param index)) (f !!sort index) mc)

--\data PatternTerm (env : FSignature)
--                  (context : List Sort)
--                  (termSort : Sort)
--                  (mc : MetaContext Sort) : \Set
--  | pattern-var (index : Fin (length context)) (termSort = context !! index)
--  | pattern-metavar (m : mc.metaname termSort)
--                    (arguments : DescendingVector (length (mc.m-domain m)) (length context))
--                    (arguments-coherence : \Pi (index : Fin (length (mc.m-domain m))) -> (mc.m-domain m) !! index = context !! (arguments dv!! index))
--  | pattern-func (f : FunctionalSymbol.symbol termSort)
--                 (choosing : \Pi (index : Fin (length (domain f))) -> PatternTerm env ((f !!param index) ++ context) (f !!sort index) mc)
--  \where {
--    \func convertToTerm {env : FSignature} {context : List Sort} {s : Sort} {mc : MetaContext Sort} (pattern : PatternTerm env context s mc) : Term env context s mc \elim pattern
--      | pattern-var index p => var index p
--      | pattern-metavar m arguments arguments-coherence => metavar m (\lam index => var (arguments dv!! index) (arguments-coherence index))
--      | pattern-func f choosing => func f (\lam index => convertToTerm (choosing index))
--  }

\open Term

-- | Substitution of regular variables
\func Substitution {env : FSignature} (c c' : List Sort) (mc : MetaContext Sort) : \Set =>
  \Pi (index : Fin (length c)) -> Term env c' (c !! index) mc
  \where {
    \func apply {env : FSignature} {s : Sort} {c : List Sort} {mc : MetaContext Sort}
                (t : Term env c s mc)
                {c' : List Sort}
                (map : Substitution c c' mc)
      : Term env c' s mc \elim t
      | var index idp => map index
      | metavar m choosing => metavar m (\lam i => Substitution.apply (choosing i) map)
      | func f choosing => func f (\lam i => Substitution.apply (choosing i) (append-context-right map))

    \func adjustContext {env : FSignature} {s : Sort} {mc : MetaContext Sort} (t : Term env nil s mc) {new-context : List Sort} : Term env new-context s mc =>
      apply t (\lam i => contradiction)
  }

\record RewriteRule (env : FSignature) {s : Sort} {meta-context : MetaContext Sort}
                    (l : Term env nil s meta-context)
                    (r : Term env nil s meta-context)
                    (l-is-func : FunctionalRoot l)

\data FunctionalRoot {env : FSignature} {s : Sort} {context : List Sort} {mc : MetaContext Sort}
                     (T : Term env context s mc) \elim T
  | func _ _ => T-has-functional-root

--\record PatternRewriteRule \extends RewriteRule {
--  | pattern : PatternTerm env nil s mc
--  | l => PatternTerm.convertToTerm pattern
--}

-- | Substitution of metavariables
\func MetaSubstitution (env : FSignature) (new-context : List Sort) (mc mc' : MetaContext Sort): \Set =>
  \Pi {s : Sort} (mvar : mc.metaname s) -> Term env (new-context ++ (mc.m-domain mvar)) s mc'
  \where {
    \func apply {env : FSignature} {context core-context : List Sort} {s : Sort} {mc mc' : MetaContext Sort}
                (t : Term env context s mc)
                (sublist : SubList core-context context)
                (subst : MetaSubstitution env core-context mc mc') : Term env context s mc' \elim t
      | var index p => var index p
      | metavar m choosing => Substitution.apply (subst m) (extend-substitution-left sublist (\lam i => apply (choosing i) sublist subst))
      | func f choosing => func f (\lam i => apply (choosing i) (SubList.extend-right-single sublist) subst)
  }

\record RewriteStep {env : FSignature} {context : List Sort} {s : Sort} {meta-context : MetaContext Sort} (L R : Term env context s meta-context)
  | rule : RewriteRule env {s}
  | substitution : MetaSubstitution env context rule.meta-context meta-context
  | left-coherence : MetaSubstitution.apply (weakening rule.l SubList.sublist-trivial-skip) SubList.identity substitution = L
  | right-coherence : MetaSubstitution.apply (weakening rule.r SubList.sublist-trivial-skip) SubList.identity substitution = R

\record IndexedSet (A : \Type)
  | J : \Set
  | get : J -> A
  \where {
    \func \infix 4 in {A : \Type} (a : A) (set : IndexedSet A) : \Type => \Sigma (point : set.J) (set.get point = a)
  }

\data ReductionAtIndex {env : FSignature} {mc : MetaContext Sort}
                       (Rel : \Pi {context : List Sort} {s : Sort} -> Term env context s mc -> Term env context s mc -> \Type)
                       {n : Nat}
                       (contexts : Fin n -> List Sort)
                       (sorts : Fin n -> Sort)
                       (A B : \Pi (index : Fin n) -> Term env (contexts index) (sorts index) mc) \elim n
  | suc n => head-reduction (Rel (A zero) (B zero)) (\Pi (i : Fin n) -> A (suc i) = B (suc i))
  | suc n => tail-reduction (A zero = B zero)
                            (ReductionAtIndex {env} Rel
                                (\lam i => contexts (suc i))
                                (\lam i => sorts (suc i))
                                (\lam i => A (suc i))
                                (\lam i => B (suc i)))

\func transport-chooser-f {env : FSignature} {s : Sort} {context : List Sort} {mc : MetaContext Sort} {f-A f-B : symbol s} (p : f-A = f-B)
                          (choosing-B : \Pi (index : F-param-index f-B) -> Term env (context ++ (f-B !!param index)) (f-B !!sort index) mc)
  :  \Pi (index : Fin (length (domain f-A))) -> Term env (context ++ (f-A !!param index)) (f-A !!sort index) mc =>
  transport (\lam f => \Pi (index : Fin (length (domain f))) -> Term env (context ++ f !!param index) (f !!sort index) mc) (inv p) choosing-B

\func transport-chooser-m {env : FSignature} {s : Sort} {context : List Sort} {mc : MetaContext Sort} {m-A m-B : mc.metaname s} (p : m-A = m-B)
                          (choosing-B : \Pi (index : Fin (length (mc.m-domain m-B))) -> Term env context ((mc.m-domain m-B) !! index) mc)
  : \Pi (index : Fin (length (mc.m-domain m-A))) -> Term env context ((mc.m-domain m-A) !! index) mc =>
  transport (\lam (m : mc.metaname s) => \Pi (index : Fin (length (mc.m-domain m))) -> Term env context ((mc.m-domain m) !! index) mc) (inv p) choosing-B

\data RewriteRelation
  {env : FSignature}
  {mc : MetaContext Sort}
  (set-of-rules : IndexedSet (RewriteRule env))
  {context : List Sort} {s : Sort}
  (A B : Term env context s mc) \elim A, B
  | A, B =>
  rewrite-with-rule (step : RewriteStep A B) (step.rule IndexedSet.in set-of-rules)

  | func f-A choosing-A, func f-B choosing-B =>
  rewrite-with-parameter-f (p : f-A = f-B)
                           (i : Fin (length (domain f-A)))
                           (reduction : RewriteRelation set-of-rules (choosing-A i) (transport-chooser-f p choosing-B i))
                           (eq : \Pi (j : Fin (length (domain f-A))) (j = i -> Empty) -> (choosing-A j) = (transport-chooser-f p choosing-B j))

  | metavar (m-A : mc.metaname s) choosing-A, metavar (m-B : mc.metaname s) choosing-B =>
  rewrite-with-parameter-m (p : m-A = m-B)
                           (i : Fin (length (m-domain m-A)))
                           (reduction : RewriteRelation set-of-rules (choosing-A i) (transport-chooser-m p choosing-B i))
                           (eq : \Pi (j : Fin (length (m-domain m-A))) (j = i -> Empty) -> (choosing-A j) = (transport-chooser-m p choosing-B j))

\class HigherOrderTermRewritingSystem \noclassifying (env : FSignature) (meta-context : MetaContext Sort) (set-of-rules : IndexedSet (RewriteRule env))  \extends AbstractReductionSystem
  | A => \Sigma (context : List Sort) (sort : Sort) (Term env context sort meta-context)
  | ~> a b => \case \elim a, b \with {
    | (context, sort, A), (context', sort', B) => âˆƒ (p : context' = context) (q : sort' = sort) (RewriteRelation set-of-rules A (transport2 (\lam a b => Term env a b meta-context) p q B))
  }

\class SimpleHigherOrderTermRewritingSystem \extends HigherOrderTermRewritingSystem, SimpleARS
