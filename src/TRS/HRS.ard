\import ARS
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, map, nil)
\import Data.Or
\import Equiv
\import Equiv.Univalence
\import Function
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import TRS.Data.Fin
\import TRS.Data.SubList
\import TRS.HRS
\import TRS.Substitutions
\import TRS.Utils

-- | The family of functional term symbols
\class FSignature {
  -- | All possible groups of functional symbols
  | Sort : \Set

  -- | All functional symbols, gathered by sort
  | symbol : Sort -> \Set

  -- | For each functional symbols, a signature of its arguments: the sort of the argument and the domain of the argument
  | domain : \Pi {s : Sort} (symbol s) -> List (\Sigma (List Sort) Sort)

  \func \infix 7 !!domain {s : Sort} (m : symbol s) (index : Index (domain m)) : List Sort =>
    (domain m !! index).1

  \func \infix 7 !!sort {s : Sort} (m : symbol s) (index : Index (domain m)) : Sort =>
    (domain m !! index).2

  \func arity {s : Sort} (f : symbol s) : Nat => length (domain f)

  \func index-in {s : Sort} (f : symbol s) : \Type => Index (domain f)
}

\open FSignature

\record MetaContext (Sort : \Set) {
  | metaname : Sort -> \Set
  | m-domain : \Pi {s : Sort} (metaname s) -> List Sort

  \func arity {s : Sort} (m : metaname s) : Nat => length (m-domain m)

  \func index-in {s : Sort} (m : metaname s) : \Type => Index (m-domain m)
}

-- | Term of higher-order TRS
\data Term (env : FSignature)
           (context : List Sort)
           (termSort : Sort)
           (mc : MetaContext Sort): \Set
  | var (index : Index context) (termSort = context !! index)
  | metavar
    (m : mc.metaname termSort)
    (arguments : DArray {mc.arity m} (\lam index => Term env context (mc.m-domain m !! index) mc))
  | func
    (f : symbol termSort)
    (arguments : DArray {env.arity f} (\lam index => Term env (context ++ f !!domain index) (f !!sort index) mc))

-- | Substitution of regular variables
\func Substitution {env : FSignature} (old-context new-context : List Sort) (mc : MetaContext Sort) : \Set =>
  \Pi (index : Index old-context) -> Term env new-context (old-context !! index) mc
  \where {
    \func apply {env : FSignature} {s : Sort} {old-context : List Sort} {old-meta-context : MetaContext Sort}
                (target : Term env old-context s old-meta-context)
                {new-context : List Sort}
                (map : Substitution old-context new-context old-meta-context)
      : Term env new-context s old-meta-context \elim target
      | var index idp => map index
      | metavar m arguments => metavar m (\lam i => Substitution.apply (arguments i) map)
      | func f arguments => func f (\lam i => Substitution.apply (arguments i) (append-context-right map))
  }

\record RewriteRule (env : FSignature) {s : Sort} {meta-context : MetaContext Sort}
                    (l : Term env nil s meta-context)
                    (r : Term env nil s meta-context)
                    (l-is-func : FunctionRoot l)

\data FunctionRoot {env : FSignature} {s : Sort} {context : List Sort} {mc : MetaContext Sort}
                   (T : Term env context s mc) : \Prop \elim T
  | func _ _ => T-has-functional-root

-- | Substitution of metavariables
\func MetaSubstitution (env : FSignature) (new-context : List Sort) (old-metacontext new-metacontext : MetaContext Sort): \Set =>
  \Pi {s : Sort} (mvar : old-metacontext.metaname s) -> Term env (new-context ++ old-metacontext.m-domain mvar) s new-metacontext
  \where {
    \func apply {env : FSignature} {context core-context : List Sort} {s : Sort} {old-metacontext new-metacontext : MetaContext Sort}
                (t : Term env context s old-metacontext)
                (sublist : SubList core-context context)
                (subst : MetaSubstitution env core-context old-metacontext new-metacontext) : Term env context s new-metacontext \elim t
      | var index p => var index p
      | metavar m arguments => Substitution.apply (subst m) (extend-substitution-left sublist (\lam i => apply (arguments i) sublist subst))
      | func f arguments => func f (\lam i => apply (arguments i) (SubList.extend-right-single sublist) subst)
  }

\record IndexedSet (A : \Type)
  | J : \Set
  | get : J -> A
  \where {
    \func \infix 4 in {A : \Type} (a : A) (set : IndexedSet A) : \Type => \Sigma (point : set.J) (set.get point = a)
  }

\func arguments-over-f
  {env : FSignature} {s : Sort} {context : List Sort} {mc : MetaContext Sort}
  {f-A f-B : symbol s} (p : f-A = f-B)
  (arguments-B : \Pi (index : index-in f-B) -> Term env (context ++ (f-B !!domain index)) (f-B !!sort index) mc)
  : \Pi (index : Index (domain f-A)) -> Term env (context ++ (f-A !!domain index)) (f-A !!sort index) mc =>
  transport (\lam f => \Pi (index : Index (domain f)) -> Term env (context ++ f !!domain index) (f !!sort index) mc) (inv p) arguments-B

\func arguments-over-m
  {env : FSignature} {s : Sort} {context : List Sort} {mc : MetaContext Sort}
  {m-A m-B : mc.metaname s} (p : m-A = m-B)
  (arguments-B : \Pi (index : Index (mc.m-domain m-B)) -> Term env context (mc.m-domain m-B !! index) mc)
  : \Pi (index : Index (mc.m-domain m-A)) -> Term env context (mc.m-domain m-A !! index) mc =>
  transport (\lam (m : mc.metaname s) => \Pi (index : Index (mc.m-domain m)) -> Term env context (mc.m-domain m !! index) mc) (inv p) arguments-B

\data RewriteRelation
  {env : FSignature}
  {mc : MetaContext Sort}
  (set-of-rules : IndexedSet (RewriteRule env))
  {context : List Sort} {s : Sort}
  (A B : Term env context s mc) \elim A, B
  | A, B =>
  rewrite-with-rule
    (idx : set-of-rules.J)
    (sort-eq : s = RewriteRule.s {set-of-rules.get idx})
    (substitution : MetaSubstitution env context (RewriteRule.meta-context {set-of-rules.get idx}) mc)
    (left-coherence :
    MetaSubstitution.apply (weakening (RewriteRule.l {set-of-rules.get idx}) SubList.sublist-trivial-free) SubList.identity substitution =
    transport (Term env context __ mc) sort-eq A)
    (right-coherence :
    MetaSubstitution.apply (weakening (RewriteRule.r {set-of-rules.get idx}) SubList.sublist-trivial-free) SubList.identity substitution =
    transport (Term env context __ mc) sort-eq B)

  | func f-A arguments-A, func f-B arguments-B =>
  rewrite-with-parameter-f
    (p : f-A = f-B)
    (i : Index (domain f-A))
    (reduction : RewriteRelation set-of-rules (arguments-A i) (arguments-over-f p arguments-B i))
    (other-unchanged : \Pi (j : index-in f-A) (j = i -> Empty) -> arguments-A j = arguments-over-f p arguments-B j)

  | metavar (m-A : mc.metaname s) arguments-A, metavar (m-B : mc.metaname s) arguments-B =>
  rewrite-with-parameter-m
    (p : m-A = m-B)
    (i : Index (m-domain m-A))
    (reduction : RewriteRelation set-of-rules (arguments-A i) (arguments-over-m p arguments-B i))
    (other-unchanged : \Pi (j : mc.index-in m-A) (j = i -> Empty) -> arguments-A j = arguments-over-m p arguments-B j)

\class HigherOrderTermRewritingSystem \noclassifying (env : FSignature) (meta-context : MetaContext Sort) (set-of-rules : IndexedSet (RewriteRule env))  \extends AbstractReductionSystem
  | A => \Sigma (context : List Sort) (sort : Sort) (Term env context sort meta-context)
  | ~> a b => \case \elim a, b \with {
    | (context, sort, A), (context', sort', B) => âˆƒ (p : context' = context) (q : sort' = sort) (RewriteRelation set-of-rules A (transport2 (\lam a b => Term env a b meta-context) p q B))
  }

\class SimpleHigherOrderTermRewritingSystem \extends HigherOrderTermRewritingSystem, SimpleARS
