\import ARS
\import Algebra.Domain.Bezout
\import Data.List (++, ++-assoc, ::, List, map, nil)
\import Data.Or
\import Equiv
\import Equiv.Univalence
\import Function
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import TRS.List
\import Set.Fin

-- | Family of functional term symbols
\record FunctionalSignature (Sort : \Set)
  | symbol : Sort -> \Set
  | domain : \Pi {s : Sort} (symbol s) -> List (\Sigma (List Sort) Sort)
  \where {
    \func \infix 7 !!param {Sort : \Set} {Sig : FunctionalSignature Sort} {s : Sort} (m : Sig.symbol s) (index : Fin (length (Sig.domain m))) : List Sort =>
      (Sig.domain m !! index).1

    \func \infix 7 !!sort {Sort : \Set} {Sig : FunctionalSignature Sort} {s : Sort} (m : Sig.symbol s) (index : Fin (length (Sig.domain m))) : Sort =>
      (Sig.domain m !! index).2
  }

\record MetaSignature (Sort : \Set)
  | metasymbol : Sort -> \Set
  | metadomain : \Pi {s : Sort} (metasymbol s) -> List Sort

\open FunctionalSignature

\class Environment
  | Sort : \Set
  | FunctionalSymbol : FunctionalSignature Sort
  | MetaVariable : MetaSignature Sort

-- | Term of High-order TRS
\data Term (env : Environment)
           (context : List Sort)
           (termSort : Sort) : \Set
  | var (index : Fin (length context)) (termSort = context !! index) -- | Bound variable
  | metavar (m : MetaVariable.metasymbol termSort) -- | Metavariable
            (choosing : \Pi (index : Fin (length (metadomain m))) -> Term env context (metadomain m !! index))
  | func (f : FunctionalSymbol.symbol termSort) -- | Functional symbol
         (choosing : \Pi (index : Fin (length (domain f))) -> Term env ((f !!param index) ++ context) (f !!sort index))
  \where {
    -- | Checks if term `t` contains metavariable `v`
    \func \infix 4 in {env : Environment} {s' s'' : Sort}
                      {context : List Sort}
                      (v : MetaVariable.metasymbol s'')
                      (t : Term env context s') : \Prop \elim t
      | var index p => Empty
      | metavar m choosing =>
        (\Sigma (s=s' : s'' = s') (m = (transport metasymbol s=s' v)))
          ||
        (\Sigma (n : Fin (length (metadomain m))) (v in choosing n))
      | func f choosing => ∃ (n : Fin (length (domain f))) (v in choosing n)
  }

\open Term

-- | Substitution of regular variables
\func Substitution {env : Environment} (context : List Sort) {new-context : List Sort}: \Set =>
  \Pi (index : Fin (length context)) -> Term env new-context (context !! index)
  \where {
    \func apply {env : Environment} {s : Sort} {context : List Sort}
                (t : Term env context s)
                {new-context : List Sort}
                (map : Substitution context {new-context})
      : Term env new-context s \elim t
      | var index p => transport (Term env new-context) (inv p) (map index)
      | metavar m choosing => metavar m (\lam i => Substitution.apply (choosing i) map)
      | func f choosing => func f (\lam i => Substitution.apply (choosing i) (enlarge-substitution (f !!param i) map))
      \where {
        \func enlarge-substitution {env : Environment} {old-context new-context : List Sort}
                                   (additional-context : List Sort)
                                   (subst : Substitution old-context {new-context})
                                   (index : Fin (length (additional-context ++ old-context))) : Term env (additional-context ++ new-context) ((additional-context ++ old-context) !! index) \elim additional-context, index
          | nil, index => subst index
          | :: a additional-context, fzero => var fzero idp
          | :: a additional-context, fsuc index => \let inner-shifting => enlarge-substitution additional-context subst index \in (add-metaindex {_} {_} {nil} a inner-shifting)

        \func add-metaindex {env : Environment} {s' : Sort} {left-context right-context : List Sort} (a : Sort) (t : Term env (left-context ++ right-context) s') : Term env (left-context ++ a :: right-context) s' \elim t
          | var index p => \let (l, r) => address left-context right-context a s' index p \in var l r
          | metavar m choosing => metavar m (\lam i1 => add-metaindex a (choosing i1))
          | func f choosing => func f (\lam i1 => rewriteI ++-assoc (add-metaindex {_} {_} {f !!param i1 ++ left-context} a (rewrite ++-assoc (choosing i1))))
          \where {
            \func address {A : \Set} (a b : List A) (x y : A) (ind : Fin (length (a ++ b))) (p : y = (a ++ b) !! ind) : \Sigma (ind' : Fin (length (a ++ (x :: b)))) (y = (a ++ (x :: b)) !! ind') \elim a, ind, p
              | nil, ind, idp => (fsuc ind, idp)
              | :: a a1, fzero, idp => (fzero, idp)
              | :: a a1, fsuc ind, idp => \let (find, fp) => address a1 b x y ind idp \in (fsuc find, fp)
          }
      }

    \func adjustContext {env : Environment} {s : Sort} (t : Term env nil s) {new-context : List Sort} : Term env new-context s =>
      apply t (\lam i => contradiction)
  }

\record RewriteRule {env : Environment} {s : Sort} (l r : Term env nil s) {
  | r-is-not-generating : \Pi {s'' : Sort} (m : metasymbol s'') (m in r) -> m in l
}

-- | Substitution of metavariables
\func MetaSubstitution (env : Environment) : \Set =>
  \Pi {s : Sort} (m : MetaVariable.metasymbol s) -> Term env (MetaVariable.metadomain m) s
  \where {
    \func apply {env : Environment} {context : List Sort} {s : Sort}
                (t : Term env context s)
                (subst : MetaSubstitution env) : Term env context s \elim t
      | var index p => var index p
      | metavar m choosing => Substitution.apply (subst m) (\lam i => apply (choosing i) subst)
      | func f choosing => func f (\lam i => apply (choosing i) subst)
  }

\record RewriteStep {env : Environment} {context : List Sort} {s : Sort} (L R : Term env context s)
  | rule : RewriteRule {env} {s}
  | substitution : MetaSubstitution env
  | left-coherence : Substitution.adjustContext (MetaSubstitution.apply rule.l substitution) = L
  | right-coherence : Substitution.adjustContext (MetaSubstitution.apply rule.r substitution) = R

\record IndexedSet (A : \Type)
  | J : \Set
  | get : J -> A
  \where {
    \func \infix 4 in {A : \Type} (a : A) (set : IndexedSet A) : \Type => \Sigma (point : set.J) (set.get point = a)
  }

\truncated \data ReductionAtIndex {env : Environment} (set-of-rules : IndexedSet (RewriteRule {env}))
                                  {n : Nat}
                                  (contexts : Fin n -> List Sort)
                                  (sorts : Fin n -> Sort)
                                  (A B : \Pi (index : Fin n) -> Term env (contexts index) (sorts index)) : \Prop \elim n
  | suc n => head-reduction (RewriteRelation {env} set-of-rules (A fzero) (B fzero)) (\Pi (i : Fin n) -> A (fsuc i) = B (fsuc i))
  | suc n => tail-reduction (A fzero = B fzero)
                            (ReductionAtIndex {env} set-of-rules
                                (\lam i => contexts (fsuc i))
                                (\lam i => sorts (fsuc i))
                                (\lam i => A (fsuc i))
                                (\lam i => B (fsuc i)))

\truncated \data RewriteRelation {env : Environment}
                                 (set-of-rules : IndexedSet (RewriteRule {env}))
                                 {s : env.Sort}
                                 {context : List Sort} (A B : Term env context s) : \Prop \elim A, B
  | A, B =>
  rewrite-with-rule (step : RewriteStep {env} A B) (step.rule IndexedSet.in set-of-rules)

  | func f-A choosing-A, func f-B choosing-B =>
  rewrite-with-parameter-f (p : f-A = f-B)
                           (ReductionAtIndex {env} set-of-rules
                               (f-A !!param __ ++ context)
                               (f-A !!sort __)
                               choosing-A
                               (transport (\lam f => \Pi (index : Fin (length (domain f))) -> Term env (f !!param index ++ context) (f !!sort index)) (inv p) choosing-B))

  | metavar m-A choosing-A, metavar m-B choosing-B =>
  rewrite-with-parameter-m (p : m-A = m-B)
                           (ReductionAtIndex {env} set-of-rules
                               (\lam _ => context)
                               (metadomain m-A !! __)
                               choosing-A
                               (transport (\lam m => \Pi (index : Fin (length (metadomain m))) -> Term env context (metadomain m !! index)) (inv p) choosing-B))

\class HigherOrderTermRewritingSystem \noclassifying (env : Environment) (set-of-rules : IndexedSet (RewriteRule {env})) \extends AbstractReductionSystem
  | A => \Sigma (context : List env.Sort) (sort : env.Sort) (Term env context sort)
  | ~> a b => \case \elim a, b \with {
    | (context, sort, A), (context', sort', B) => ∃ (p : context' = context) (q : sort' = sort) (RewriteRelation {env} set-of-rules A (transport2 (Term env) p q B))
  }

\class SimpleHigherOrderTermRewritingSystem \extends HigherOrderTermRewritingSystem, SimpleARS
