\import ARS
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, map, nil)
\import Data.Or
\import Equiv
\import Equiv.Univalence
\import Function
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import TRS.HRS
\import TRS.List
\import TRS.Substitutions
\import TRS.Utils

-- | Family of functional term symbols
\record FunctionalSignature (Sort : \Set)
  | symbol : Sort -> \Set
  | domain : \Pi {s : Sort} (symbol s) -> List (\Sigma (List Sort) Sort)
  \where {
    \func \infix 7 !!param {Sort : \Set} {Sig : FunctionalSignature Sort} {s : Sort} (m : Sig.symbol s) (index : Fin (length (Sig.domain m))) : List Sort =>
      (Sig.domain m !! index).1

    \func \infix 7 !!sort {Sort : \Set} {Sig : FunctionalSignature Sort} {s : Sort} (m : Sig.symbol s) (index : Fin (length (Sig.domain m))) : Sort =>
      (Sig.domain m !! index).2
  }

\open FunctionalSignature

\class Environment
  | Sort : \Set
  | FunctionalSymbol : FunctionalSignature Sort

\record MetaSignature (Sort : \Set)
  | metaname : Sort -> \Set
  | m-domain : \Pi {s : Sort} (metaname s) -> List Sort

-- | Term of High-order TRS
\data Term (env : Environment)
           (context : List Sort)
           (termSort : Sort)
           (meta-signature : MetaSignature Sort): \Set
  | var (index : Fin (length context)) (termSort = context !! index) -- | Bound variable
  | metavar (m : meta-signature.metaname termSort) -- | Metavariable
            (choosing : \Pi (index : Fin (length (meta-signature.m-domain m))) -> Term env context (meta-signature.m-domain m !! index) meta-signature)
  | func (f : FunctionalSymbol.symbol termSort) -- | Functional symbol
         (choosing : \Pi (index : Fin (length (domain f))) -> Term env ((f !!param index) ++ context) (f !!sort index) meta-signature)

\data PatternTerm (env : Environment)
                  (context : List Sort)
                  (termSort : Sort)
                  (meta-signature : MetaSignature Sort) : \Set
  | pattern-var (index : Fin (length context)) (termSort = context !! index)
  | pattern-metavar (m : meta-signature.metaname termSort)
                    (arguments : DescendingVector (length (meta-signature.m-domain m)) (length context))
                    (arguments-coherence : \Pi (index : Fin (length (meta-signature.m-domain m))) -> (meta-signature.m-domain m) !! index = context !! (arguments dv!! index))
  | pattern-func (f : FunctionalSymbol.symbol termSort)
                 (choosing : \Pi (index : Fin (length (domain f))) -> PatternTerm env ((f !!param index) ++ context) (f !!sort index) meta-signature)
  \where {
    \func convertToTerm {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (pattern : PatternTerm env context s meta-signature) : Term env context s meta-signature \elim pattern
      | pattern-var index p => var index p
      | pattern-metavar m arguments arguments-coherence => metavar m (\lam index => var (arguments dv!! index) (arguments-coherence index))
      | pattern-func f choosing => func f (\lam index => convertToTerm (choosing index))
  }

\open Term

-- | Substitution of regular variables
\func Substitution {env : Environment} (context new-context : List Sort) (meta-signature : MetaSignature Sort) : \Set =>
  \Pi (index : Fin (length context)) -> Term env new-context (context !! index) meta-signature
  \where {
    \func apply {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                (t : Term env context s meta-signature)
                {new-context : List Sort}
                (map : Substitution context new-context meta-signature)
      : Term env new-context s meta-signature \elim t
      | var index p => transport (Term env new-context __ meta-signature) (inv p) (map index)
      | metavar m choosing => metavar m (\lam i => Substitution.apply (choosing i) map)
      | func f choosing => func f (\lam i => Substitution.apply (choosing i) (append-context-left map))

    \func adjustContext {env : Environment} {s : Sort} {meta-signature : MetaSignature Sort} (t : Term env nil s meta-signature) {new-context : List Sort} : Term env new-context s meta-signature =>
      apply t (\lam i => contradiction)
  }

\record RewriteRule (env : Environment) {s : env.Sort} {meta-signature : MetaSignature Sort}
                    (l : Term env nil s meta-signature)
                    (r : Term env nil s meta-signature)
                    (l-is-func : FunctionalRoot l)

\data FunctionalRoot {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                     (T : Term env context s meta-signature) \elim T
  | func _ _ => T-has-functional-root

\record PatternRewriteRule \extends RewriteRule {
  | pattern : PatternTerm env nil s meta-signature
  | l => PatternTerm.convertToTerm pattern
}

-- | Substitution of metavariables
\func MetaSubstitution (env : Environment) (new-context : List Sort) (meta-signature new-meta-signature : MetaSignature Sort): \Set =>
  \Pi {s : Sort} (mvar : meta-signature.metaname s) -> Term env ((meta-signature.m-domain mvar) ++ new-context) s new-meta-signature
  \where {
    \func apply {env : Environment} {context core-context : List Sort} {s : Sort} {meta-signature new-meta-signature : MetaSignature Sort}
                (t : Term env context s meta-signature)
                (sublist : SubList core-context context)
                (subst : MetaSubstitution env core-context meta-signature new-meta-signature) : Term env context s new-meta-signature \elim t
      | var index p => var index p
      | metavar m choosing => Substitution.apply (subst m) (extend-substitution-right sublist (\lam i => apply (choosing i) sublist subst))
      | func f choosing => func f (\lam i => apply (choosing i) (SubList.extend-right-single-left sublist) subst)
  }

\record RewriteStep {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (L R : Term env context s meta-signature)
  | rule : RewriteRule env {s}
  | substitution : MetaSubstitution env context rule.meta-signature meta-signature
  | left-coherence : MetaSubstitution.apply (weakening rule.l SubList.sublist-trivial) SubList.identity substitution = L
  | right-coherence : MetaSubstitution.apply (weakening rule.r SubList.sublist-trivial) SubList.identity substitution = R

\record IndexedSet (A : \Type)
  | J : \Set
  | get : J -> A
  \where {
    \func \infix 4 in {A : \Type} (a : A) (set : IndexedSet A) : \Type => \Sigma (point : set.J) (set.get point = a)
  }

\data ReductionAtIndex {env : Environment} {meta-signature : MetaSignature Sort}
                       (Rel : \Pi {context : List Sort} {s : Sort} -> Term env context s meta-signature -> Term env context s meta-signature -> \Type)
                       {n : Nat}
                       (contexts : Fin n -> List Sort)
                       (sorts : Fin n -> Sort)
                       (A B : \Pi (index : Fin n) -> Term env (contexts index) (sorts index) meta-signature) \elim n
  | suc n => head-reduction (Rel (A zero) (B zero)) (\Pi (i : Fin n) -> A (suc i) = B (suc i))
  | suc n => tail-reduction (A zero = B zero)
                            (ReductionAtIndex {env} Rel
                                (\lam i => contexts (suc i))
                                (\lam i => sorts (suc i))
                                (\lam i => A (suc i))
                                (\lam i => B (suc i)))

\func transport-chooser-f {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort} {f-A f-B : FunctionalSymbol.symbol s} (p : f-A = f-B)
                          (choosing-B : \Pi (index : F-param-index f-B) -> Term env ((f-B !!param index) ++ context) (f-B !!sort index) meta-signature)
  :  \Pi (index : Fin (length (domain f-A))) -> Term env ((f-A !!param index) ++ context) (f-A !!sort index) meta-signature =>
  transport (\lam f => \Pi (index : Fin (length (domain f))) -> Term env (f !!param index ++ context) (f !!sort index) meta-signature) (inv p) choosing-B

\func transport-chooser-m {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort} {m-A m-B : meta-signature.metaname s} (p : m-A = m-B)
                          (choosing-B : \Pi (index : Fin (length (meta-signature.m-domain m-B))) -> Term env context ((meta-signature.m-domain m-B) !! index) meta-signature)
  : \Pi (index : Fin (length (meta-signature.m-domain m-A))) -> Term env context ((meta-signature.m-domain m-A) !! index) meta-signature =>
  transport (\lam (m : meta-signature.metaname s) => \Pi (index : Fin (length (meta-signature.m-domain m))) -> Term env context ((meta-signature.m-domain m) !! index) meta-signature) (inv p) choosing-B

\data RewriteRelation {env : Environment}
                                 {meta-signature : MetaSignature Sort}
                                 (set-of-rules : IndexedSet (RewriteRule env))
                                 {context : List Sort} {s : env.Sort}
                                 (A B : Term env context s meta-signature) \elim A, B
  | A, B =>
  rewrite-with-rule (step : RewriteStep {env} A B) (step.rule IndexedSet.in set-of-rules)

  | func f-A choosing-A, func f-B choosing-B =>
  rewrite-with-parameter-f (p : f-A = f-B)
                           (ReductionAtIndex {env} (RewriteRelation {env} set-of-rules)
                               (f-A !!param __ ++ context)
                               (f-A !!sort __)
                               choosing-A
                               (transport-chooser-f {env} p choosing-B))

  | metavar (m-A : meta-signature.metaname s) choosing-A, metavar (m-B : meta-signature.metaname s) choosing-B =>
  rewrite-with-parameter-m (p : m-A = m-B)
                           (ReductionAtIndex {env} (RewriteRelation {env} set-of-rules)
                               (\lam _ => context)
                               ((meta-signature.m-domain m-A) !! __)
                               choosing-A
                               (transport-chooser-m {env} p choosing-B))

\class HigherOrderTermRewritingSystem \noclassifying (env : Environment) (meta-signature : MetaSignature Sort) (set-of-rules : IndexedSet (RewriteRule env))  \extends AbstractReductionSystem
  | A => \Sigma (context : List env.Sort) (sort : env.Sort) (Term env context sort meta-signature)
  | ~> a b => \case \elim a, b \with {
    | (context, sort, A), (context', sort', B) => ∃ (p : context' = context) (q : sort' = sort) (RewriteRelation {env} set-of-rules A (transport2 (\lam a b => Term env a b meta-signature) p q B))
  }

\class SimpleHigherOrderTermRewritingSystem \extends HigherOrderTermRewritingSystem, SimpleARS
