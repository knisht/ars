\import ARS
\import Algebra.Domain.Bezout
\import Data.List (++, ++-assoc, ::, List, map, nil)
\import Data.Or
\import Equiv
\import Equiv.Univalence
\import Function
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import TRS.HRS
\import TRS.List
\import Set.Fin

-- | Family of functional term symbols
\record FunctionalSignature (Sort : \Set)
  | symbol : Sort -> \Set
  | domain : \Pi {s : Sort} (symbol s) -> List (\Sigma (List Sort) Sort)
  \where {
    \func \infix 7 !!param {Sort : \Set} {Sig : FunctionalSignature Sort} {s : Sort} (m : Sig.symbol s) (index : Fin (length (Sig.domain m))) : List Sort =>
      (Sig.domain m !! index).1

    \func \infix 7 !!sort {Sort : \Set} {Sig : FunctionalSignature Sort} {s : Sort} (m : Sig.symbol s) (index : Fin (length (Sig.domain m))) : Sort =>
      (Sig.domain m !! index).2
  }

\record MetaSignature (Sort : \Set)
  | metasymbol : Sort -> \Set
  | metadomain : \Pi {s : Sort} (metasymbol s) -> List Sort

\open FunctionalSignature

\class Environment
  | Sort : \Set
  | FunctionalSymbol : FunctionalSignature Sort
  | MetaVariable : MetaSignature Sort

-- | Term of High-order TRS
\data Term (env : Environment)
           (context : List Sort)
           (termSort : Sort) : \Set
  | var (index : Fin (length context)) (termSort = context !! index) -- | Bound variable
  | metavar (m : MetaVariable.metasymbol termSort) -- | Metavariable
            (choosing : \Pi (index : Fin (length (metadomain m))) -> Term env context (metadomain m !! index))
  | func (f : FunctionalSymbol.symbol termSort) -- | Functional symbol
         (choosing : \Pi (index : Fin (length (domain f))) -> Term env ((f !!param index) ++ context) (f !!sort index))
  \where {
    -- | Checks if term `t` contains metavariable `v`
    \func \infix 4 in {env : Environment} {s' s'' : Sort}
                      {context : List Sort}
                      (v : MetaVariable.metasymbol s'')
                      (t : Term env context s') : \Prop \elim t
      | var index p => Empty
      | metavar m choosing =>
        (\Sigma (s=s' : s'' = s') (m = (transport metasymbol s=s' v)))
          ||
        (\Sigma (n : Fin (length (metadomain m))) (v in choosing n))
      | func f choosing => ∃ (n : Fin (length (domain f))) (v in choosing n)
  }

\open Term

-- | Substitution of regular variables
\func Substitution {env : Environment} (context new-context : List Sort) : \Set =>
  \Pi (index : Fin (length context)) -> Term env new-context (context !! index)
  \where {
    \func apply {env : Environment} {s : Sort} {context : List Sort}
                (t : Term env context s)
                {new-context : List Sort}
                (map : Substitution context new-context)
      : Term env new-context s \elim t
      | var index p => transport (Term env new-context) (inv p) (map index)
      | metavar m choosing => metavar m (\lam i => Substitution.apply (choosing i) map)
      | func f choosing => func f (\lam i => Substitution.apply (choosing i) (enlarge-substitution (f !!param i) map))
      \where {
        \func enlarge-substitution {env : Environment} {old-context new-context : List Sort}
                                   (additional-context : List Sort)
                                   (subst : Substitution old-context new-context)
                                   (index : Fin (length (additional-context ++ old-context))) : Term env (additional-context ++ new-context) ((additional-context ++ old-context) !! index) \elim additional-context, index
          | nil, index => subst index
          | :: a additional-context, fzero => var fzero idp
          | :: a additional-context, fsuc index => \let inner-shifting => enlarge-substitution additional-context subst index
                                                   \in weakening inner-shifting (sublist-skip (SubList.identity (additional-context ++ new-context)))

        \func weakening {env : Environment} {s' : Sort} {narrow-context wide-context : List Sort}
                        (t : Term env narrow-context s')
                        (sublist : SubList narrow-context wide-context)
          : Term env wide-context s' \elim t
          | var index p => \let (index', p') => recalculate-index narrow-context wide-context s' sublist index p \in var index' p'
          | metavar m choosing => metavar m (\lam i1 => weakening (choosing i1) sublist)
          | func f choosing => func f (\lam i1 => weakening (choosing i1) (SubList.extend-left sublist (f !!param i1)))
          \where {
            \func recalculate-index {A : \Set} (a b : List A) (point : A) (sublist : SubList a b) (ind : Fin (length a)) (p : point = a !! ind) : \Sigma (ind' : Fin (length b)) (point = b !! ind') \elim a, b, sublist, ind, p
              | nil, r, sublist-trivial, (), p
              | :: x xs, :: y ys, sublist-match p sublist, fzero, idp => (fzero, p)
              | :: x xs, :: y ys, sublist-match p sublist, fsuc ind, idp => \let (ind', p') => recalculate-index xs ys point sublist ind idp \in (fsuc ind', p')
              | l, :: y ys, sublist-skip sublist, ind, idp => \let (ind', p') => recalculate-index l ys point sublist ind idp \in (fsuc ind', p')
          }
      }

    \func adjustContext {env : Environment} {s : Sort} (t : Term env nil s) {new-context : List Sort} : Term env new-context s =>
      apply t (\lam i => contradiction)
  }

\record RewriteRule {env : Environment} {s : Sort} (l r : Term env nil s) {
  | r-is-not-generating : \Pi {s'' : Sort} (m : metasymbol s'') (m in r) -> m in l
}

-- | Substitution of metavariables
\func MetaSubstitution (env : Environment) (new-context : List Sort): \Set =>
  \Pi {sort : Sort} (mvar : MetaVariable.metasymbol sort) -> Term env ((MetaVariable.metadomain mvar) ++ new-context) sort
  \where {
    \func apply {env : Environment} {context new-context : List Sort} {s : Sort}
                (t : Term env context s)
                (sublist : SubList context new-context)
                (subst : MetaSubstitution env new-context) : Term env new-context s \elim t
      | var index p => var (SubList.shift-index index sublist) (p *> SubList.shift-index-preserves-equality index sublist)

      | metavar m choosing => \let | new-term : Term env (metadomain m ++ new-context) s => subst m
                                   | basic-term-chooser (i : Fin (length (MetaVariable.metadomain m))) : Term env new-context (metadomain m !! i) => apply (choosing i) sublist subst
                              \in Substitution.apply new-term (extend-chooser basic-term-chooser)

      | func f choosing => func f (\lam i =>
          \let | middle-sublist : SubList (f !!param i ++ context) (f !!param i ++ new-context) => (SubList.extend-left sublist (f !!param i))
               | extended-substitution : MetaSubstitution env (f !!param i ++ new-context) =>
                 \lam m => Substitution.apply.weakening (subst m) (SubList.extend-middle (metadomain m) new-context (f !!param i))
          \in apply (choosing i) middle-sublist extended-substitution)

      \where {
        \func extend-chooser {env : Environment} {left-context right-context : List Sort}
                             (chooser : \Pi (i : Fin (length left-context)) -> Term env right-context (left-context !! i))
                             (j : Fin (length (left-context ++ right-context)))
          : Term env right-context ((left-context ++ right-context) !! j) \elim left-context, j
          | nil, j => var j idp
          | :: a narrow-context, fzero => chooser fzero
          | :: a narrow-context, fsuc j => extend-chooser (\lam i => chooser (fsuc i)) j
      }
  }

\record RewriteStep {env : Environment} {context : List Sort} {s : Sort} (L R : Term env context s)
  | rule : RewriteRule {env} {s}
  | substitution : MetaSubstitution env context
  | left-coherence : MetaSubstitution.apply rule.l sublist-trivial substitution = L
  | right-coherence : MetaSubstitution.apply rule.r sublist-trivial substitution = R

\record IndexedSet (A : \Type)
  | J : \Set
  | get : J -> A
  \where {
    \func \infix 4 in {A : \Type} (a : A) (set : IndexedSet A) : \Type => \Sigma (point : set.J) (set.get point = a)
  }

\truncated \data ReductionAtIndex {env : Environment} (set-of-rules : IndexedSet (RewriteRule {env}))
                                  {n : Nat}
                                  (contexts : Fin n -> List Sort)
                                  (sorts : Fin n -> Sort)
                                  (A B : \Pi (index : Fin n) -> Term env (contexts index) (sorts index)) : \Prop \elim n
  | suc n => head-reduction (RewriteRelation {env} set-of-rules (A fzero) (B fzero)) (\Pi (i : Fin n) -> A (fsuc i) = B (fsuc i))
  | suc n => tail-reduction (A fzero = B fzero)
                            (ReductionAtIndex {env} set-of-rules
                                (\lam i => contexts (fsuc i))
                                (\lam i => sorts (fsuc i))
                                (\lam i => A (fsuc i))
                                (\lam i => B (fsuc i)))

\truncated \data RewriteRelation {env : Environment}
                                 (set-of-rules : IndexedSet (RewriteRule {env}))
                                 {s : env.Sort}
                                 {context : List Sort} (A B : Term env context s) : \Prop \elim A, B
  | A, B =>
  rewrite-with-rule (step : RewriteStep {env} A B) (step.rule IndexedSet.in set-of-rules)

  | func f-A choosing-A, func f-B choosing-B =>
  rewrite-with-parameter-f (p : f-A = f-B)
                           (ReductionAtIndex {env} set-of-rules
                               (f-A !!param __ ++ context)
                               (f-A !!sort __)
                               choosing-A
                               (transport (\lam f => \Pi (index : Fin (length (domain f))) -> Term env (f !!param index ++ context) (f !!sort index)) (inv p) choosing-B))

  | metavar m-A choosing-A, metavar m-B choosing-B =>
  rewrite-with-parameter-m (p : m-A = m-B)
                           (ReductionAtIndex {env} set-of-rules
                               (\lam _ => context)
                               (metadomain m-A !! __)
                               choosing-A
                               (transport (\lam m => \Pi (index : Fin (length (metadomain m))) -> Term env context (metadomain m !! index)) (inv p) choosing-B))

\class HigherOrderTermRewritingSystem \noclassifying (env : Environment) (set-of-rules : IndexedSet (RewriteRule {env})) \extends AbstractReductionSystem
  | A => \Sigma (context : List env.Sort) (sort : env.Sort) (Term env context sort)
  | ~> a b => \case \elim a, b \with {
    | (context, sort, A), (context', sort', B) => ∃ (p : context' = context) (q : sort' = sort) (RewriteRelation {env} set-of-rules A (transport2 (Term env) p q B))
  }

\class SimpleHigherOrderTermRewritingSystem \extends HigherOrderTermRewritingSystem, SimpleARS
