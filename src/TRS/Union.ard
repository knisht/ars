\import Confluence
\import Data.List (++, List, nil)
\import Data.Or
\import Logic
\import Paths
\import Paths.Meta
\import Relation
\import TRS.HRS
\import Set.Fin
\import TRS.List
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointMetaSignature (Sort : \Set) (A B : MetaSignature Sort) : MetaSignature Sort \cowith
  | metasymbol s => A.metasymbol s `Or` B.metasymbol s
  | metadomain metavar => \case \elim metavar \with {
    | inl a => A.metadomain a
    | inr b => B.metadomain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol
  | MetaVariable => JointMetaSignature Sort A.MetaVariable B.MetaVariable

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort}
                         (term : Term envL c s) : Term (JointEnvironment envL envR) c s \elim term
    | var index p => var index p
    | metavar m choosing => metavar (inl m) (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          (term : Term envR c s) : Term (JointEnvironment envL envR) c s \elim term
    | var index p => var index p
    | metavar m choosing => metavar (inr m) (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | r-is-not-generating m m-in-r => \case \elim m, \elim m-in-r \with {
      | inl m', m-in-r => \let | q => uninject-in envL envR rule.r m' m-in-r
                               | q' => rule.r-is-not-generating m' q \in {?}
      | inr b, m-in-r => {?}
    }
    \where {
      \func uninject-in {Sort : \Set}
                        (envL envR : Environment Sort)
                        {s s'' : Sort}
                        (term : Term envL nil s)
                        (m' : envL.MetaVariable.metasymbol s'')
                        (rel : (inl m') Term.in {JointEnvironment envL envR} (inject-term-left envL envR term))
        : m' Term.in term \elim term, rel
        | metavar m choosing, byLeft a => {?}
        | metavar m choosing, byRight b => {?}
        | func f choosing, inP a => {?}

      \func inject-in {Sort : \Set}
                      (envL envR : Environment Sort)
                      {s s'' : Sort}
                      (term : Term envL nil s)
                      (m' : envL.MetaVariable.metasymbol s'')
                      (rel : m' Term.in term)
        : (inl m') Term.in {JointEnvironment envL envR} (inject-term-left envL envR term) \elim term, rel
        | metavar m choosing, byLeft (q, p) => byLeft (q, {?})
        | metavar m choosing, byRight (n, prf) => byRight (n, inject-in envL envR (choosing n) m' prf)
        | func f choosing, inP a => {?}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | r-is-not-generating => {?}

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL)
                   (R : SimpleHigherOrderTermRewritingSystem envR)
: SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules =>
    \let
      | injected-left-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-left {_} {envL} {envR} L.set-of-rules
      | injected-right-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-right {_} {envL} {envR} R.set-of-rules
    \in JointIndexedSet injected-left-set injected-right-set

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL)
                                  (R : SimpleHigherOrderTermRewritingSystem envR)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort}
                                         {context : List Sort} (A B : Term env context s) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {s} {context}) A B

\module Confluence \where {
  \class TheoremContext {
    | Sort : \Set
    | envL : Environment Sort
    | envR : Environment Sort
    | L : SimpleHigherOrderTermRewritingSystem envL
    | R : SimpleHigherOrderTermRewritingSystem envR
  } \where {
    \func env {tc : TheoremContext} : Environment => JointEnvironment envL envR
  }

  \open TheoremContext

  \cons red {A B : \Type} (a : A) : A `Or` B => inl a

  \cons blue {A B : \Type} (b : B) : A `Or` B => inr b

  \data hasRedRoot {tc : TheoremContext}
                   {s : Sort} {context : List Sort} (t : Term env context s) \elim t
    | func (red _) _ => red-func
    | metavar (red _) _ => red-mvar

  \data hasBlueRoot {tc : TheoremContext}
                    {s : Sort} {context : List Sort} (t : Term env context s) \elim t
    | func (blue _) _ => blue-func
    | metavar (blue _) _ => blue-mvar

  \truncated \data ColoredParallelReduction {tc : TheoremContext}
                                            {s : Sort} {context : List Sort} (A B : Term env context s) : \Prop
    | leave-untouched
    | reduce-in-place-red (hasRedRoot A) (transitive-closure RedRewriteRelation A B)
    | reduce-in-place-blue (hasBlueRoot B) (transitive-closure BlueRewriteRelation A B)
    | spread-reduction (SpreadTransition A B)

  \data SpreadTransition {tc : TheoremContext}
                         {s : Sort} {context : List Sort} (A B : Term env context s) : \Set \elim A, B
    | func (red f-A) choosing-A, func (red f-B) choosing-B => distributed-reduction-red-f-f
      (p : f-A = f-B)
      (\Pi (i : F-param-index f-A) ->
          SingularTransition:Red->Blue {tc}
              (choosing-A i)
              ((transport-chooser-f {env {tc}} (pmap red p) choosing-B) i))
    | metavar (red m-A) choosing-A, metavar (red m-B) choosing-B => distributed-reduction-red-m-m
      (p : m-A = m-B)
      (\Pi (i : M-param-index m-A) ->
          SingularTransition:Red->Blue {tc}
              (choosing-A i)
              ((transport-chooser-m {env {tc}} (pmap red p) choosing-B) i))
    | func (blue f-A) choosing-A, func (blue f-B) choosing-B => distributed-reduction-blue-f-f
      (p : f-A = f-B)
      (\Pi (i : F-param-index f-A) ->
          SingularTransition:Blue->Red {tc}
              (choosing-A i)
              ((transport-chooser-f {env {tc}} (pmap blue p) choosing-B) i))
    | metavar (blue m-A) choosing-A, metavar (blue m-B) choosing-B => distributed-reduction-blue-m-m
      (p : m-A = m-B)
      (\Pi (i : M-param-index m-A) ->
          SingularTransition:Blue->Red {tc}
              (choosing-A i)
              ((transport-chooser-m {env {tc}} (pmap blue p) choosing-B) i))

  \data SingularTransition:Red->Blue {tc : TheoremContext}
                                     {s : Sort} {context : List Sort}
                                     (A B : Term env context s) : \Set
    | start-blue-reduction (hasBlueRoot A) (ColoredParallelReduction A B)
    | continue-red-spread (hasRedRoot A) (SpreadTransition A B)

  \data SingularTransition:Blue->Red {tc : TheoremContext}
                                     {s : Sort} {context : List Sort}
                                     (A B : Term env context s) : \Set
    | start-red-reduction (hasRedRoot A) (ColoredParallelReduction A B)
    | continue-blue-spread (hasBlueRoot A) (SpreadTransition A B)

  \truncated \data RedReductionAtIndex {tc : TheoremContext}
                                       {n : Nat}
                                       (contexts : Fin n -> List Sort)
                                       (sorts : Fin n -> Sort)
                                       (A B : \Pi (index : Fin n) -> Term env (contexts index) (sorts index)) : \Prop \elim n
    | suc n => head-reduction-red (RedRewriteRelation {tc} (A fzero) (B fzero)) (\Pi (i : Fin n) -> A (fsuc i) = B (fsuc i))
    | suc n => tail-reduction-red (A fzero = B fzero)
                                  (RedReductionAtIndex {tc}
                                      (\lam i => contexts (fsuc i))
                                      (\lam i => sorts (fsuc i))
                                      (\lam i => A (fsuc i))
                                      (\lam i => B (fsuc i)))

  \truncated \data RedRewriteRelation {tc : TheoremContext} {s : Sort} {context : List Sort} (A B : Term env context s) : \Prop \elim A, B
    | A, B => rewrite-with-rule-red (hasRedRoot {tc} A)
                                    (step : RewriteStep {env {tc}} A B)
                                    (step.rule IndexedSet.in (Injections.promote-indexed-set-left {Sort} {envL} {envR} L.set-of-rules))
    | func (red f-A) choosing-A, func (red f-B) choosing-B =>
    rewrite-with-parameter-f-red (p : f-A = f-B)
                                 (RedReductionAtIndex {tc}
                                     (f-A FunctionalSignature.!!param __ ++ context)
                                     (f-A FunctionalSignature.!!sort __)
                                     choosing-A
                                     (transport-chooser-f {env {tc}} (pmap red p) choosing-B))

    | metavar (red m-A) choosing-A, metavar (red m-B) choosing-B =>
    rewrite-with-parameter-m-red (p : m-A = m-B)
                                 (RedReductionAtIndex {tc}
                                     (\lam _ => context)
                                     (metadomain m-A !! __)
                                     choosing-A
                                     (transport-chooser-m {env {tc}} (pmap red p) choosing-B))

  \truncated \data BlueReductionAtIndex {tc : TheoremContext}
                                        {n : Nat}
                                        (contexts : Fin n -> List Sort)
                                        (sorts : Fin n -> Sort)
                                        (A B : \Pi (index : Fin n) -> Term env (contexts index) (sorts index)) : \Prop \elim n
    | suc n => head-reduction-blue (BlueRewriteRelation {tc} (A fzero) (B fzero)) (\Pi (i : Fin n) -> A (fsuc i) = B (fsuc i))
    | suc n => tail-reduction-blue (A fzero = B fzero)
                                   (BlueReductionAtIndex {tc}
                                       (\lam i => contexts (fsuc i))
                                       (\lam i => sorts (fsuc i))
                                       (\lam i => A (fsuc i))
                                       (\lam i => B (fsuc i)))

  \truncated \data BlueRewriteRelation {tc : TheoremContext} {s : Sort} {context : List Sort} (A B : Term env context s) : \Prop \elim A, B
    | A, B => rewrite-with-rule-blue (hasBlueRoot {tc} A)
                                     (step : RewriteStep {env {tc}} A B)
                                     (step.rule IndexedSet.in (Injections.promote-indexed-set-right {Sort} {envL} {envR} R.set-of-rules))
    | func (blue f-A) choosing-A, func (blue f-B) choosing-B =>
    rewrite-with-parameter-f-blue (p : f-A = f-B)
                                  (BlueReductionAtIndex {tc}
                                      (f-A FunctionalSignature.!!param __ ++ context)
                                      (f-A FunctionalSignature.!!sort __)
                                      choosing-A
                                      (transport-chooser-f {env {tc}} (pmap blue p) choosing-B))

    | metavar (blue m-A) choosing-A, metavar (blue m-B) choosing-B =>
    rewrite-with-parameter-m-blue (p : m-A = m-B)
                                  (BlueReductionAtIndex {tc}
                                      (\lam _ => context)
                                      (metadomain m-A !! __)
                                      choosing-A
                                      (transport-chooser-m {env {tc}} (pmap blue p) choosing-B))
}
