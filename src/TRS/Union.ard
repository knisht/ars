\import Algebra.Ring.Localization
\import Confluence
\import Data.Bool
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.Union.TopLevel
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort} {meta-signature : MetaSignature Sort}
                         (term : Term envL c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          {meta-signature : MetaSignature Sort}
                          (term : Term envR c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | l-is-func => promote-injection-left {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-left {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envL context s meta-signature)
                                   (t-is-func : FunctionalRoot {envL} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-left envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | l-is-func => promote-injection-right {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-right {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envR context s meta-signature)
                                   (t-is-func : FunctionalRoot {envR} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-right envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\func JointRules {Sort : \Set} {envL envR : Environment Sort}
                 (L-rules : IndexedSet (RewriteRule envL))
                 (R-rules : IndexedSet (RewriteRule envR))
  : IndexedSet (RewriteRule (JointEnvironment envL envR)) =>
  \let
    | injected-left-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-left {_} {envL} {envR} L-rules
    | injected-right-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-right {_} {envL} {envR} R-rules
  \in JointIndexedSet injected-left-set injected-right-set

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                   (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
: SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules => JointRules {_} {envL} {envR} L.set-of-rules R.set-of-rules
  | meta-signature => meta-signature

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                                  (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort} {meta-signature : MetaSignature Sort}
                                         {context : List Sort} (A B : Term env context s meta-signature) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {context} {s}) A B

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red

    \func flip-contradiction {c : Color} (eq : c = flip c) : Empty \elim c
      | red => contradiction
      | blue => contradiction
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : Environment Sort'
    | envR : Environment Sort'
    | L-rules : IndexedSet (RewriteRule envL)
    | R-rules : IndexedSet (RewriteRule envR)
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (RewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term (colored-env {tc} color) context s meta-signature): \Prop
    \elim color
      | red => RewriteRelation {envL} L-rules A B
      | blue => RewriteRelation {envR} R-rules A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (t : Term (colored-env color) context s meta-signature) : Term env context s meta-signature \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t
      \where {
        \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {msig : MetaSignature Sort'} (t : Term env context s msig) \elim t
          | func f choosing => iw-func (color-of-root {tc} f = color)
                                       (\Pi (i : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> InjectionWitness {tc} color (choosing i))
          | metavar m choosing => iw-mvar (\Pi (i : Fin (length (msig.m-domain m))) -> InjectionWitness {tc} color (choosing i))
          | var _ _ => iw-var
      }

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (term : Term env context s meta-signature) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      \where {
        \func equalize-colors {tc : TheoremContext} (color color' : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                              (f : env.FunctionalSymbol.symbol s)
                              (choosing choosing' : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                              (hcl1 : HasColoredRoot color (func f choosing))
                              (hcl2 : HasColoredRoot color' (func f choosing'))
                              : color = color' \elim color, color', f, hcl1, hcl2
          | red, red, inl s1, red-func-root, red-func-root => idp
          | blue, blue, inr s1, blue-func-root, blue-func-root => idp
          | red, blue, inr b, (), hcl2
          | blue, red, inl a, (), hcl2

        \func reorganize {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                         {f : env.FunctionalSymbol.symbol s}
                         {choosing : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                         (hcl : HasColoredRoot color (func f choosing))
                         : color-of-root f = color \elim color, f, hcl
          | red, inl s1, red-func-root => idp
          | blue, inr s1, blue-func-root => idp
      }
--      | _, metavar _ _ => uncolored-metavar-root

    \data HasMetaRoot {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (term : Term env context s meta-signature) \elim term
      | metavar _ _ => has-meta-root

    \func color-of-root {_ : TheoremContext} {s : Sort'} (f : env.FunctionalSymbol.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR

    \func colored-rules {tc : TheoremContext} (color : Color) : IndexedSet (RewriteRule (env {tc})) \elim color
      | red => Injections.promote-indexed-set-left {tc.Sort'} {tc.envL} {tc.envR} (L-rules)
      | blue => Injections.promote-indexed-set-right {tc.Sort'} {tc.envL} {tc.envR} (R-rules)
  }

  \open TheoremContext

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} (A B : Term env context s meta-signature) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot {tc} color A) (step : LinearRewriteStep {env {tc}} A B) --(step.rule IndexedSet.in {LinearRewriteRule step.env} (colored-rules coor)) todo
    | func (f-A : symbol {FunctionalSymbol {env {tc}}} s) choosing-A, func (f-B : symbol {FunctionalSymbol {env {tc}}} s) choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root {tc} f-A = color)
                                     (ReductionAtIndex {env {tc}}
                                         (TopLevelColoredReduction {tc} color {meta-signature})
                                         (\lam i => (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i ++ {Sort {env {tc}}} context))
                                         (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} __)
                                         choosing-A
                                         (transport-chooser-f {env {tc}} p choosing-B))
    \where {
      \func extract-root-coloring {tc : TheoremContext} {color : Color} {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} {A B : Term env context s meta-signature} (tlcr : TopLevelColoredReduction color A B) : HasColoredRoot color A
        \elim color, A, B, tlcr
        | color, A, B, rewrite-with-rule-colored h _ => h
        | color, func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => \case \elim color, \elim f-A, \elim choosing-A, \elim p1 \with {
          | red, inl a, choosing-A, p1 => red-func-root
          | blue, inr b, choosing-A, p1 => blue-func-root
        }
    }

  \data BorderedParallelReduction {tc : TheoremContext}
                                  (global-color : Color)
                                  (color : Maybe Color)
                                  {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
                                  (A B : Term (env {tc}) context s meta-signature) \elim A
    | A => equal-trees (A = B)
    | func f choosing =>
    parallelization-f
      (mediator : \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) ->
          Term (env {tc}) ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
      (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f) -> \Sigma
        (someColor : Maybe Color)
        ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f))))
        (BorderedParallelReduction {tc} global-color someColor (choosing i) (mediator i)))
      (ColorwiseReduction {tc} global-color color (func f mediator) B)
  --    | metavar m choosing =>
  --    parallelization-m
  --      (mediator : \Pi (index : Fin (length (m-domain m))) -> Term (env {tc}) (context) (m-domain m !! index) meta-signature)
  --      (\Pi (i : Fin (length (m-domain m))) -> (BorderedParallelReduction {tc} global-color color (choosing i) (mediator i)))
  --      (metavar {env {tc}} m mediator = B)

  \data ColorwiseReduction {tc : TheoremContext}
                           {context : List Sort'}
                           {s : Sort'}
                           {meta-signature : MetaSignature Sort'}
                           (global-color : Color)
                           (color : Maybe Color) (A B : Term env context s meta-signature) \elim color
    | nothing => cr-skip (A = B)
    | just color => cr-rewrite (TClosure (TopLevelColoredReduction {tc} color) A B) (global-color = color)

  \func TrichromaticParallelReduction {tc : TheoremContext} {meta-signature : MetaSignature Sort'} {context : List tc.Sort'} {s : Sort'} (A B : Term env context s meta-signature) : \Type =>
    \Sigma (global-color : Color) (color : Maybe Color) (BorderedParallelReduction global-color color A B)

  \func ConfluentialSystem (env : Environment) (rules : IndexedSet (RewriteRule env)) : \Type =>
    \Pi {meta-signature : MetaSignature Sort} {context : List Sort} {s : Sort}
        (A B C : Term env context s meta-signature)
        (RewriteRelation rules A B)
        (RewriteRelation rules A C) -> StraightJoin B C ((RewriteRelation rules))

  \func bpr-confluence {tc : TheoremContext} {gc1 gc2 : Color} (color1 color2 : Maybe Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  {A B C : Term env context s meta-signature}
                       (A~>B : BorderedParallelReduction gc1 color1 A B)
                       (A~>C : BorderedParallelReduction gc2 color2 A C)
                       (left-confluence : ConfluentialSystem envL L-rules)
                       (right-confluence : ConfluentialSystem envR R-rules)
    : \Sigma (D : Term env context s meta-signature)
             (color3 : Maybe Color)
             ((color3 = color2))
             (color4 : Maybe Color)
             ((color4 = color1))
             (BorderedParallelReduction gc2 color3 B D)
             (BorderedParallelReduction gc1 color4 C D) \elim color1, color2, A, B, C, A~>B, A~>C
    | color1, color2, A, B, C, equal-trees p, rd => (C, color2, idp, color1, idp, rewriteI p rd, equal-trees idp)
    | color1, color2, A, B, C, rd, equal-trees p => (B, color2, idp, color1, idp, equal-trees idp, rewriteI p rd)
    | nothing, nothing, func f choosing, B, C, parallelization-f mediator choosing->med (cr-skip famed=B), parallelization-f mediator' choosing->med' (cr-skip famed'=C)
    => \let | inner-confluences i => bpr-confluence (choosing->med i).1 (choosing->med' i).1 (choosing->med i).3 (choosing->med' i).3 left-confluence right-confluence
            | D => func {env} f (\lam i => (inner-confluences i).1)
       \in (func f (\lam i => (inner-confluences i).1),
            nothing,
            idp,
            nothing,
            idp,
            rewriteI famed=B (parallelization-f (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).2, rewrite (inner-confluences i).3 (choosing->med' i).2, (inner-confluences i).6)) (cr-skip idp)),
            rewriteI famed'=C (parallelization-f (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).4, rewrite (inner-confluences i).5 (choosing->med i).2, (inner-confluences i).7)) (cr-skip idp)))
    | nothing, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-skip p), parallelization-f mediator' choosing=>med' (cr-rewrite med'~>C gc2=right-color) =>
      \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
           | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
           | (rightmost-reduct, flr~>rr, mcl, C=>rr) => unify-top right-color gc1 f mediator' (\lam i => (joined-mediators i).1) C med'~>C (\lam index => ((joined-mediators index).4, rewrite (joined-mediators index).5 (choosing=>med index).2, (joined-mediators index).7))
      \in (rightmost-reduct,
           just right-color,
           idp,
           mcl,
           {?},
           rewriteI p (parallelization-f (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (rewrite (joined-mediators i).3 (choosing=>med' i).2), (joined-mediators i).6)) (cr-rewrite flr~>rr gc2=right-color)),
           C=>rr)
    | just left-color, nothing, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-skip p) =>
      \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
           | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
           | (leftmost-reduct, flr~>lr, mcl, B=>lr) => unify-top left-color gc2 f mediator (\lam i => (joined-mediators i).1) B med~>B (\lam index => ((joined-mediators index).2, (rewrite (joined-mediators index).3 (choosing=>med' index).2), (joined-mediators index).6))
      \in (leftmost-reduct,
           mcl,
           {?},
           just left-color,
           idp,
           B=>lr,
           rewriteI p (parallelization-f (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).4, (rewrite (joined-mediators i).5 (choosing=>med i).2), (joined-mediators i).7)) (cr-rewrite flr~>lr gc1=left-color)))
    | just left-color, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-rewrite med~>C gc2=right-color)
    => \let
        | hcl-f-left : HasColoredRoot left-color (func f mediator) => TopLevelColoredReduction.extract-root-coloring (TClosure.extract med~>B).2
        | hcl-f-right : HasColoredRoot right-color (func f mediator') => TopLevelColoredReduction.extract-root-coloring (TClosure.extract med~>C).2
        | lcolor=rcolor : left-color = right-color => HasColoredRoot.equalize-colors left-color right-color f mediator mediator' hcl-f-left hcl-f-right
        | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
        | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
        | (leftmost-reduct, flr~>lr, clr-b, B=>lr) => unify-top left-color left-color f mediator (\lam i => (joined-mediators i).1) B med~>B (\lam index => ((joined-mediators index).2, (rewrite (joined-mediators index).3 (choosing=>med' index).2), rewrite (lcolor=rcolor *> inv gc2=right-color) (joined-mediators index).6))
        | (rightmost-reduct, flr~>rr, clr-c, C=>rr) => unify-top right-color right-color f mediator' (\lam i => (joined-mediators i).1) C med~>C (\lam index => ((joined-mediators index).4, (rewrite (joined-mediators index).5 (choosing=>med index).2), rewrite (inv lcolor=rcolor *> inv gc1=left-color) (joined-mediators index).7))
        | (common-reduct, lr~>cr, rr~>cr) => join-different-tlcrs left-color right-color flr~>lr flr~>rr left-confluence right-confluence
        | reorganized-colors-l => reorganize-colors-here B=>lr
        | reorganized-colors-r => reorganize-colors-here C=>rr
       \in (common-reduct,
            just gc2,
            rewrite gc2=right-color (idp),
            just gc1,
            rewrite gc1=left-color (idp),
            gather-reduction gc2 (reorganized-colors-l.1) (rewrite (gc2=right-color *> inv lcolor=rcolor) reorganized-colors-l.2) (rewriteI (lcolor=rcolor *> inv gc2=right-color) (reorganized-colors-l.3)) (rewrite gc2=right-color lr~>cr),
            gather-reduction gc1 (reorganized-colors-r.1) (rewrite (gc1=left-color *> lcolor=rcolor) reorganized-colors-r.2) (rewriteI (inv lcolor=rcolor *> inv gc1=left-color) (reorganized-colors-r.3)) (rewrite gc1=left-color rr~>cr))
    \where {
      \func reorganize-colors-here {tc : TheoremContext} {gc : Color} {someColor : Maybe Color} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                   {A B : Term env context s meta-signature} (A~>B : BorderedParallelReduction gc someColor A B)
        : \Sigma (someColor' : Maybe Color) (Or (someColor' = nothing) (someColor' = just gc)) (BorderedParallelReduction gc someColor' A B) \elim someColor, A, A~>B
        | _, A, equal-trees p => (nothing, inl idp, equal-trees p)
        | nothing, func f choosing, rd => (nothing, inl idp, rd)
        | just a, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => (just a, rewrite p (inr idp), parallelization-f mediator _x (cr-rewrite t p))

      \func join-different-tlcrs {tc : TheoremContext} (color1 color2 : Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  {A B C : Term env context s meta-signature}
                                 (A~>B : TClosure (TopLevelColoredReduction color1) A B)
                                 (A~>C : TClosure (TopLevelColoredReduction color2) A C)
                                 (left-confluence : ConfluentialSystem envL L-rules)
                                 (right-confluence : ConfluentialSystem envR R-rules)
        : \Sigma (X : Term env context s meta-signature) (TClosure (TopLevelColoredReduction color2) B X) (TClosure (TopLevelColoredReduction color1) C X)
      \elim color1, color2
        | red, red => join-tlcrs red A B C A~>B A~>C left-confluence
        | red, blue => \let | a => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>B).2
                            | b => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>C).2 \in \case \elim A, \elim a, \elim b \with {
          }
        | blue, red => \let | a => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>B).2
                            | b => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>C).2 \in \case \elim A, \elim a, \elim b \with {
          }
        | blue, blue => join-tlcrs blue A B C A~>B A~>C right-confluence

      \func gather-reduction {tc : TheoremContext}
                             (color : Color)
                             (sclr : Maybe Color)
                             (eq : (sclr = nothing) `Or` (sclr = just color))
                             {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {B lr X : Term env context s meta-signature}
                             (B=>lr : BorderedParallelReduction color sclr B lr)
                             (lr~>X : TClosure (TopLevelColoredReduction color) lr X)
        : BorderedParallelReduction color (just color) B X
        \elim sclr, eq, B, B=>lr
          | sclr, _, B, equal-trees p => \let x => TopLevelColoredReduction.extract-root-coloring (TClosure.extract lr~>X).2 \in \case \elim color, \elim lr, \elim x, \elim p, \elim lr~>X \with {
            | red, func (inl f) choosing, red-func-root, p, lr~>X => rewrite p (parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite lr~>X idp))
            | blue, func (inr f) choosing, blue-func-root, p, lr~>X => rewrite p (parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite lr~>X idp))
          }
          | nothing, inl a, func f choosing, parallelization-f mediator _x (cr-skip p) => parallelization-f mediator _x (cr-rewrite (rewrite p lr~>X) idp)
          | just a1, inl a, func f choosing, parallelization-f mediator _x c => contradiction
          | nothing, inr b, func f choosing, parallelization-f mediator _x c => contradiction
          | just a, inr b, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => parallelization-f mediator _x (cr-rewrite (TClosure.compose (rewriteI (Maybe.unjust-eq b) t) lr~>X) idp)

      \func twist-colors {c1 c2 c3 : Maybe Color} (c1or : Or (c1 = nothing) (c1 = c2)) (c2or : Or (c2 = nothing) (c2 = c3)) : Or (c1 = nothing) (c1 = c3) \elim c1or
        | inl a => inl a
        | inr b => rewrite b c2or

      \func twist-colors' {c1 c2 c3 : Maybe Color} (c1or : Or (c1 = c2) (c1 = nothing)) (c2or : Or (c2 = nothing) (c2 = c3)) : Or (c1 = nothing) (c1 = c3) \elim c1or
        | inl a => rewrite a c2or
        | inr b => inl b
    }

  \func unify-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color color' : Color)
                  (f : env.FunctionalSymbol.symbol s)
                  (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                  (B : Term env context s meta-signature)
                  (A~>B : TClosure (TopLevelColoredReduction color) (func {env} f choosing-A) B)
                  (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f) ->
                      \Sigma (someColor : Maybe Color)
                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
                             (BorderedParallelReduction {tc} color' someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
    : \Sigma (X : Term env context s meta-signature)
             (TClosure (TopLevelColoredReduction color) (func {env} f choosing-C) X)
             (mcolor : Maybe Color)
             (BorderedParallelReduction color' mcolor B X) =>
    \let
      | (t, rho, t[rho]=A, root-colors) => decompose-term color (func f choosing-A)
      | (u, lu[rho]=B, t~>*u) => iterate-decomposition (LinearTerm.convert-to-term {colored-env color} t) rho B t[rho]=A A~>B
      | eqs : LinearMetasignatureT {colored-env color} t = LinearMetasignatureT {env} (inject-linear-term color t) => linear-metasignature-equator
      | eqs2 : (LinearTerm.convert-to-term {env} (inject-linear-term color t)) =  (transport (Term env context s) eqs (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t))) => equate-transported-terms color t -- technical
      | injected-u : Term env context s (LinearMetasignatureT {env} (inject-linear-term color t)) => rewriteI eqs (inject-monochrome-term color u)
      | modified-rho => transport (MetaSubstitution env nil __ meta-signature) eqs rho
      | eqs3 : (func {env} f choosing-A) = (MetaSubstitution.apply {env} (LinearTerm.convert-to-term {env} (inject-linear-term color t)) sublist-trivial modified-rho) => inv t[rho]=A *> {?}
      | witnesses => inject-linear-term.generate-injection-witness color t
      | (sigma, C=t[sigma], reds) => alternate-subst {_} color color' (func f choosing-C) (inject-linear-term {_} color t) witnesses modified-rho ({?}) nothing (inl idp) (rewriteI eqs3 (parallelization-f choosing-C inner-reductions (cr-skip idp)))
      | uni-right => TClosure.lift {_} {_} {monochrome-reduction color} {TopLevelColoredReduction color} (\lam trm => (MetaSubstitution.apply {env} (inject-monochrome-term color trm) sublist-trivial (transport (MetaSubstitution env nil __ meta-signature) (inv eqs) sigma))) (lift-relation color (transport (MetaSubstitution env nil __ meta-signature) (inv eqs) sigma)) (LinearTerm.convert-to-term {colored-env color} t) u t~>*u
      | (mcl, _, uni-left) => unify-left color' color injected-u {?} sublist-trivial modified-rho sigma reds
    \in metasignature-unificator eqs color color' B (func f choosing-C)
        (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t))
        (inject-monochrome-term color u)
        rho
        sigma
        lu[rho]=B
        (rewriteI eqs2 C=t[sigma])
        uni-right
        uni-left
    \where {
      \func iterate-decomposition
        {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-msig meta-signature : MetaSignature Sort'}
        {color : Color}
        (t : Term (colored-env {tc} color) context s inner-msig)
        (rho : MetaSubstitution env nil inner-msig meta-signature)
        {A : Term env context s meta-signature}
        (B : Term env context s meta-signature)
        (teq : (MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist-trivial rho) = A)
        (A~>*B : TClosure (TopLevelColoredReduction color) A B)
        : \Sigma (u : Term (colored-env {tc} color) context s inner-msig)
                 (MetaSubstitution.apply {env} (inject-monochrome-term color u) sublist-trivial rho = B)
                 (TClosure (monochrome-reduction color) (t) u) \elim A~>*B
        | tc-basic A~>B =>
          \let | (u, lu[rho]=B, t~>u) => decompose-along-reduction color t B rho (rewrite teq A~>B)
          \in (u, lu[rho]=B, tc-basic t~>u)
        | tc-connect C A->C C~>*B =>
          \let | (c, meq, rd) => decompose-along-reduction color t C rho (rewrite teq A->C) -- induction on length of closure
          | (u, mu, tcl) => iterate-decomposition c rho B (meq) (C~>*B) \in (u, mu, tc-connect c rd tcl)

      \func linear-metasignature-equator {tc : TheoremContext} {color : Color} {context : List Sort'} {s : Sort'} {t : LinearTerm (colored-env color) context s} : LinearMetasignatureT {colored-env color} t = LinearMetasignatureT {env} (inject-linear-term color t) \elim color, t
        | red, lt-func f choosing => \let ext-lemma : (\lam i => LinearMetasignatureT {envL} (choosing i)) = (\lam i => LinearMetasignatureT {env} (inject-linear-term red (choosing i))) => ext (\lam i => linear-metasignature-equator) \in rewrite ext-lemma idp
        | red, lt-metavar params choosing => \let ext-lemma : (\lam i => LinearMetasignatureT {envL} (choosing i)) = (\lam i => LinearMetasignatureT {env} (inject-linear-term red (choosing i))) => ext (\lam i => linear-metasignature-equator) \in rewrite ext-lemma idp
        | red, lt-full-metavar => idp
        | red, lt-var index p => idp
        | blue, lt-func f choosing => \let ext-lemma : (\lam i => LinearMetasignatureT {envR} (choosing i)) = (\lam i => LinearMetasignatureT {env} (inject-linear-term blue (choosing i))) => ext (\lam i => linear-metasignature-equator) \in rewrite ext-lemma idp
        | blue, lt-metavar params choosing => \let ext-lemma : (\lam i => LinearMetasignatureT {envR} (choosing i)) = (\lam i => LinearMetasignatureT {env} (inject-linear-term blue (choosing i))) => ext (\lam i => linear-metasignature-equator) \in rewrite ext-lemma idp
        | blue, lt-full-metavar => idp
        | blue, lt-var index p => idp

      \func equate-transported-terms {tc : TheoremContext}
                                     (color : Color) {context : List Sort'} {s : Sort'}
                                     (t : LinearTerm (colored-env color) context s)
        : LinearTerm.convert-to-term {env} (inject-linear-term color t) = transport (Term env context s) (linear-metasignature-equator) (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t)) \elim color, t
        | red, lt-func f choosing =>
          \let | inner : (\lam i => LinearTerm.convert-to-term {env} (inject-linear-term red (choosing i))) = (\lam i => transport (Term env (f FunctionalSignature.!!param i ++ context) (f FunctionalSignature.!!sort i)) (linear-metasignature-equator) (Injections.inject-term-left envL envR (LinearTerm.convert-to-term {envL} (choosing i)))) => ext (\lam i => equate-transported-terms red (choosing i))
          \in {?}
        | red, lt-metavar params choosing => {?}
        | red, lt-full-metavar => idp
        | red, lt-var index p => idp
        | blue, lt-func f choosing => {?}
        | blue, lt-metavar params choosing => {?}
        | blue, lt-full-metavar => idp
        | blue, lt-var index p => idp

      \func metasignature-unificator {tc : TheoremContext} {context : List Sort'} {s : Sort'} {left-meta-signature right-meta-signature outer-meta-signature : MetaSignature Sort'}
                                     (meta-signature-equality : left-meta-signature = right-meta-signature)
                                     (color color' : Color)
                                     {mcolor : Maybe Color}
                                     (B C : Term env context s outer-meta-signature)
                                     (inj-t inj-u : Term env context s left-meta-signature)
                                     (rho : MetaSubstitution env nil left-meta-signature outer-meta-signature)
                                     (sigma : MetaSubstitution env nil right-meta-signature outer-meta-signature)
                                     (lu[rho]=b : MetaSubstitution.apply {env} inj-u sublist-trivial rho = B)
                                     (C=t[sigma] : C = MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-t) sublist-trivial sigma)
                                     (uni-right : TClosure (TopLevelColoredReduction color)
                                         (MetaSubstitution.apply {env} (inj-t) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) (inv meta-signature-equality) sigma))
                                         (MetaSubstitution.apply {env} (inj-u) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) (inv meta-signature-equality) sigma)))
                                     (uni-left : BorderedParallelReduction color' mcolor
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) meta-signature-equality rho))
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) sublist-trivial sigma))
        : \Sigma (X : Term env context s outer-meta-signature)
                 (TClosure (TopLevelColoredReduction color) C X)
                 (mcolor : Maybe Color)
                 (BorderedParallelReduction color' mcolor B X) \elim meta-signature-equality
        | idp => (MetaSubstitution.apply {env} inj-u sublist-trivial sigma,
                  rewrite C=t[sigma] uni-right,
                  mcolor,
                  rewriteI lu[rho]=b uni-left)

      \func recreate-coloring-for-root {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {color : Color} {f : env.FunctionalSymbol.symbol s}
                                       {choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                                       (h : HasColoredRoot color (func f choosing-A)) : HasColoredRoot color (func f choosing-C) \elim color, f, h
        | red, inl s1, red-func-root => red-func-root
        | blue, inr s1, blue-func-root => blue-func-root
    }

  \func alternate-subst {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (gc rcolor : Color)
                        (C : Term env context s meta-signature)
                        (t : LinearTerm env context s)
                        (witness : inject-linear-term.InjectionWitness gc t)
                        (rho : MetaSubstitution env nil (LinearMetasignatureT {env} t) meta-signature)
                        (root-colors : \Pi {s1 : Sort'} -> \Pi (m : metaname {LinearMetasignatureT {env} t} s1) -> HasColoredRoot (Color.flip gc) (rho m))
                        (someColor : Maybe Color)
                        (some-color-diff : (someColor = nothing) `Or` (someColor = just (Color.flip gc)))
                        (A=>C : BorderedParallelReduction rcolor someColor (MetaSubstitution.apply {env} ((LinearTerm.convert-to-term {env} t)) sublist-trivial rho) C)
    : \Sigma (sigma : MetaSubstitution env nil (LinearMetasignatureT {env} t) meta-signature)
             (C = MetaSubstitution.apply {env} ((LinearTerm.convert-to-term {env} t)) (sublist-trivial) sigma)
             (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignatureT {env} t} s) ->
                 \Sigma (mcolor : Maybe Color) ((mcolor = nothing) `Or` (mcolor = just (Color.flip gc))) (BorderedParallelReduction rcolor mcolor (rho m) (sigma m)))
    \elim t, someColor, A=>C
      | lt-func f choosing, nothing, parallelization-f mediator inner-reductions (cr-skip p) =>
        \let
          | inner-witnesses => inject-linear-term.extract-from-witness gc f choosing witness
          | inductive-result i => alternate-subst gc rcolor
              (mediator i) (choosing i)
              (inner-witnesses.1 i)
              (\lam m => rho (i, m))
              (\lam {s1} m => root-colors (i, m))
              (inner-reductions i).1 (rewriteI inner-witnesses.2 (inner-reductions i).2)
              (rewrite (modular-commutation {env} (\lam j => LinearMetasignatureT {env} (choosing j)) i sublist-trivial (LinearTerm.convert-to-term {env} (choosing i)) rho)
                  (rewrite (invariant-through-empty-subst {env} rho sublist-trivial (SubList.extend-right-single-left sublist-trivial) (LinearTerm.upgrade-metavariables-t {env}
                      (\lam j => LinearMetasignatureT {env} (choosing j)) (LinearTerm.convert-to-term {env} (choosing i)))) (inner-reductions i).3))
        \in (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2,
             inv p *> (pmap (func {env} f)
                 (ext (\lam index => rewriteI
                     (modular-commutation {env} (\lam j => LinearMetasignatureT {env} (choosing j)) index (SubList.extend-right-single-left sublist-trivial) (LinearTerm.convert-to-term {env} (choosing index)) (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2))
                     (rewrite (invariant-through-empty-subst {env} ) (inductive-result index).2)))),
             \lam {s1} m => (inductive-result (m.1)).3 m.2)
      | lt-func f choosing, just color, parallelization-f mediator inner-reductions (cr-rewrite tlcr p) =>
        \let | inner-witnesses => (inject-linear-term.extract-from-witness gc f choosing witness).2
             | coloring-from-tlcr => HasColoredRoot.reorganize color (TopLevelColoredReduction.extract-root-coloring (TClosure.extract tlcr).2)
             | extracted => Color.flip-contradiction (inv (inner-witnesses) *> coloring-from-tlcr *> extract-from-or some-color-diff)
        \in contradiction
      | lt-func f choosing, someColor, equal-trees p => (rho, inv p, \lam {s1} m => (nothing, inl idp, equal-trees idp))
      | lt-metavar params choosing, someColor, rd => {?}
      | lt-full-metavar, someColor, rd =>
        (\lam {s1} mvar => transport2 (\lam ctx srt => Term env ctx srt meta-signature) (inv ++_nil) (inv mvar) C,
         rewrite (transport2-to-transport) (inv (plain-identity-effect {env} C) *> (apply-subst-with-extended-identity {env} C (\lam i => var i idp))),
         \lam {s1} m => \let | unified => unify-reduction rho C rd m  \in reorganize-colors unified some-color-diff)
      | lt-var index p, someColor, equal-trees p1 => (\lam {s1} mvar => contradiction, inv p1, \lam {s1} m => contradiction)
    \where {
      \func extract-from-or {A : \Type} {a b : A} (or : Or (just a = nothing) (just a = just b)) : a = b
        | inl a1 => contradiction
        | inr b1 => Maybe.unjust-eq b1

      \func unify-reduction {tc : TheoremContext} {gc : Color} {someColor : Maybe Color} {context : List Sort'} {s s' : Sort'} {meta-signature : MetaSignature Sort'}
                            (rho :  MetaSubstitution env nil (SingularMetaSignature {env} s context) meta-signature)
                            (C : Term env context s meta-signature)
                            (bpr : BorderedParallelReduction gc someColor (Substitution.apply {env}
                                (rho idp) (extend-substitution-right {env} sublist-trivial (\lam i => var i idp))) C)
                            (m : s' = s)
        : BorderedParallelReduction gc someColor (rho m)
          (transport2 (\lam (ctx : List Sort') (srt : Sort') => Term env ctx srt meta-signature) (inv ++_nil) (inv m) C) \elim m
        | idp => rewrite transport2-to-transport {?}

      \func reorganize-colors {tc : TheoremContext} {gc gc' : Color} {someColor : Maybe Color} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
        {A B : Term env context s meta-signature} (A~>B : BorderedParallelReduction gc someColor A B) (or : (someColor = nothing) `Or` (someColor = just gc'))
        : \Sigma (someColor' : Maybe Color) (Or (someColor' = nothing) (someColor' = just (gc'))) (BorderedParallelReduction gc someColor' A B) \elim someColor, A, A~>B
        | _, A, equal-trees p => (nothing, inl idp, equal-trees p)
        | nothing, func f choosing, rd => (nothing, inl idp, rd)
        | just a, func f choosing, rd => (just a, or, rd)

      \func pattern-can't-be-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature new-meta-signature : MetaSignature Sort}
                                 (T : Term env nil s meta-signature)
                                 (subst : MetaSubstitution env context meta-signature new-meta-signature)
                                 (someIndex : Fin (length context)) (someProof : s = context !! someIndex)
                                 (eq : MetaSubstitution.apply (weakening T sublist-trivial) SubList.identity subst = var someIndex someProof)
                                 (T-functional : FunctionalRoot T) : Empty \elim T, T-functional
        | func f choosing, T-has-functional-root => contradiction

      \func identify-context-mapping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                     (sublist : SubList right-context (left-context ++ right-context))
                                     (sublist' : SubList left-context (left-context ++ right-context))
                                     (ind : Fin (length (left-context ++ right-context))) :
        (extend-substitution-right {env} {_} {_} {_} {meta-signature} sublist (wide-identity sublist')) ind = var ind idp
      \elim left-context, right-context, ind
        | nil, :: a right-context, zero => {?}
        | nil, :: a right-context, suc ind => {?} -- rewrite (extension-over-identity-is-identity ind) idp
        | :: a left-context, nil, zero => {?}
        | :: a left-context, r, suc ind => {?}
        | :: a left-context, :: a1 right-context, zero => {?}
        \where {
          \func outer-equality-to-identity {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                           (sublist : SubList right-context (left-context ++ right-context))
                                           (sublist' : SubList left-context (left-context ++ right-context)) (i : Fin (length (left-context ++ right-context))) : extend-substitution-right sublist (wide-identity sublist') i = plain-identity {_} {_} {meta-signature} i =>
            {?}

          \func extension-over-identity-is-identity {A : \Type} {some-context : List A} (j : Fin (length some-context)) : extend-substitution-right.produce-inner-term SubList.identity j = (j, idp) \elim some-context, j
            | :: a some-context, zero => idp
            | :: a some-context, suc j => rewrite (extension-over-identity-is-identity j) idp

          \func extension-over-skipping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort} {a : Sort}
                                        (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                        (j : Fin (length (left-context ++ right-context)))
                                        (eq : extend-substitution-right {_} {_} {_} {_} {meta-signature} (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j = var j idp)
            : extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j = var (suc j) idp =>
            \let | rrr => pmap (weakening {_} {_} {_} {a :: (left-context ++ right-context)} __ (sublist-skip SubList.identity)) eq
                 | qqq : rrr @ right = var (suc j) idp => \let internal => recalculate-over-skipping {_} {a} j \in pmap sigma-to-var internal
                 | zzz : rrr @ left = extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j => weakining-extension-comms index-calculator j
            \in inv zzz *> rrr *> qqq

          \func sigma-to-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (sig : \Sigma (i : Fin (length context)) (s = context !! i)) : Term env context s meta-signature =>
            var sig.1 sig.2

          \func recalculate-over-skipping {A : \Set} {point' : A} {a : List A} (ind : Fin (length a)) : weakening.recalculate-index {_} {a} {point' :: a} (sublist-skip SubList.identity) ind idp = (suc ind, idp) \elim a, ind
            | :: a a1, zero => idp
            | :: a a1, suc ind => rewrite (weakening.recalculate-index-over-identity ind) idp

          \func weakining-extension-comms {env : Environment} {left-context right-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort}
                                          (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                          (j : Fin (length (left-context ++ right-context)))
            : weakening {_} {_} {_} {_} {meta-signature}
              (extend-substitution-right (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j)
              (sublist-skip SubList.identity) =
          extend-substitution-right {_} {_} {_} {s :: left-context ++ right-context}
              (sublist-skip (SubList.extend-right-single-left SubList.identity))
              (\lam i => \let (index, p) => index-calculator i \in var (suc index) p)
              j => {?}
        }

      \func unwrap-func {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                        (T : Term env context s meta-signature) : Or Nat
          (\Sigma (f : env.FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
              Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) \elim T
        | var index p => inl 0
        | metavar m choosing1 => inl 0
        | func f1 choosing1 => inr (f1, choosing1)

      \func unwrap-func' {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                         {f'' : env.FunctionalSymbol.symbol s}
                         {choosing choosing' : \Pi (index : Fin (length (env.FunctionalSymbol.domain f''))) ->
                             Term env ((f'' FunctionalSignature.!!param index) ++ context) (f'' FunctionalSignature.!!sort index) meta-signature}
                         (eq : func f'' choosing = func f'' choosing') : choosing' = choosing => sigma-set-equalizer (\lam f => \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) (inv (pmap (decomposeTermAsFunctionalSymbol (f'', choosing)) eq))

      \func sigma-set-equalizer {A : \Set} (B : A -> \Type) {a : A} {b b' : B a} (p : (a,b) = {\Sigma (x : A) (B x)} (a,b')) : b = b'
        => pmap (transport B __ b) (Path.inProp idp (pmap __.1 p)) *> pmapd (\lam t => B t.1) __.2 p

      \func decomposeTermAsFunctionalSymbol {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                                            (default : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
                                                Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) (T : Term env context s meta-signature) : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) \elim T
        | var index p => default
        | metavar m choosing => default
        | func f choosing => (f, choosing)

      \func apply-modularity {env : Environment} {context subst-context pattern-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n}
                             (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (pat-sublist : SubList pattern-context context)
                             (t : Term env pattern-context s (producer index)) :
        MetaSubstitution.apply (weakening t pat-sublist) sublist (substitutions index) = MetaSubstitution.apply (weakening (LinearPattern.upgrade-metavariables-p producer t) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim t
        | var index1 p => idp
        | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-right sublist e)) (ext (\lam i => apply-modularity producer substitutions sublist pat-sublist (choosing i)))
        | func f choosing => pmap (func f) (ext (\lam i => apply-modularity producer substitutions (SubList.extend-right-single-left sublist) (SubList.extend-left pat-sublist) (choosing i)))
    }

  \data TClosure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | tc-basic (a `R` b)
    | tc-connect (c : A) (a `R` c) (TClosure R c b)
    \where {
      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : TClosure Rel x y) : TClosure Rel' (map x) (map y) \elim closure
        | tc-basic r => tc-basic (rel-map r)
        | tc-connect c r closure => tc-connect (map c) (rel-map r) (lift map rel-map c y closure)

      \func compose {A : \Type} {R : A -> A -> \Type} {a b c : A} (a->b : TClosure R a b) (b->c : TClosure R b c) : TClosure R a c \elim a->b
        | tc-basic r => tc-connect b r b->c
        | tc-connect c1 r a->b => tc-connect c1 r (compose a->b b->c)

      \func extract  {A : \Type} {R : A -> A -> \Type} {a b : A} (cl : TClosure R a b) : \Sigma (c : A) (R a c) \elim cl
        | tc-basic r => (b, r)
        | tc-connect c r cl => (c, r)
    }

  \data Closure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | c-trivial (a = b)
    | c-basic (a `R` b)
    | c-connect (c : A) (a `R` c) (Closure R c b)
    \where {
      \func concat {A : \Type} {R : A -> A -> \Type} {a b c : A} (a~>b : Closure R a b) (b~>c : Closure R b c) : Closure R a c \elim a~>b, b~>c
        | c-basic r, rx => c-connect b r rx
        | c-connect c1 r a~>b, rx => c-connect c1 r (concat a~>b rx)
        | c-trivial idp, b~>c => b~>c

      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : Closure Rel x y) : Closure Rel' (map x) (map y) \elim closure
        | c-basic r => c-basic (rel-map r)
        | c-connect c r closure => c-connect (map c) (rel-map r) (lift map rel-map c y closure)
        | c-trivial idp => c-trivial idp

      \func flatten {A : \Type} {Rel : A -> A -> \Type}
                    {x y : A}
                    (closure : Closure (Closure Rel) x y) : Closure Rel x y \elim closure
        | c-basic r => r
        | c-connect c r closure => concat r (flatten closure)
        | c-trivial idp => c-trivial idp
    }

  \func unify-left {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature inner-metasignature : MetaSignature Sort'}
                   (gc anti-color : Color)
                   (s : Term env context' s inner-metasignature)
                   (witness : inject-monochrome-term.InjectionWitness anti-color s)
                   (sublist : SubList context context')
                   (rho sigma : MetaSubstitution env context inner-metasignature meta-signature)
                   (rho~>sigma : \Pi {s : Sort'} (m : inner-metasignature.metaname s) ->
                       \Sigma (mcolor : Maybe Color) ((mcolor = nothing) `Or` (mcolor = just (Color.flip anti-color))) (BorderedParallelReduction gc mcolor (rho m) (sigma m))) :
    \Sigma (mcolor : Maybe Color) ((mcolor = nothing) `Or` (mcolor = just (Color.flip anti-color))) (BorderedParallelReduction gc mcolor (MetaSubstitution.apply {env} s sublist rho) (MetaSubstitution.apply {env} s sublist sigma))
  \elim s, witness
    | var index p, _ => (nothing, inl idp, equal-trees idp)
    | metavar m choosing, wit =>
      \let | main-reduction => rho~>sigma m
           | rho-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho))
           | sigma-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma))
           | target-reduction => reduction-over-substitution (rho m) (sigma m) main-reduction.1 main-reduction.3 rho-subst sigma-subst {?} -- extension of substitutions
      \in (main-reduction.1, main-reduction.2, target-reduction)
    | func f choosing, inject-monochrome-term.iw-func p _x =>
      \let | in-indices i => unify-left gc (color-of-root f) (choosing i) (rewrite p (_x i)) (SubList.extend-right-single-left sublist) rho sigma (rewrite p rho~>sigma)
      \in (nothing, inl idp, parallelization-f (\lam i => (MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single-left sublist) sigma)) (\lam i => ((in-indices i).1, (in-indices i).2, (in-indices i).3)) (cr-skip idp))

  \func reduction-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                    (A B : Term env context s meta-signature)
                                    {gc : Color}
                                    (color : Maybe Color)
                                    (A=>B : BorderedParallelReduction gc color A B)
                                    (subst subst' : Substitution {env} context new-context meta-signature)
                                    (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    : BorderedParallelReduction gc color (Substitution.apply {env} A subst) (Substitution.apply {env} B subst') \elim A, A=>B
    | A, equal-trees p => {?}
    | func f choosing, parallelization-f mediator _x c =>
      \let | x => 1
           | medium-reductions i => reduction-over-substitution (choosing i) (mediator i) (_x i).1 (_x i).3 (append-context-left {env} subst) (append-context-left {env} subst') {?}
      \in parallelization-f (\lam i => Substitution.apply {env} (mediator i) (append-context-left {env} subst')) (\lam i => ((_x i).1, (_x i).2, medium-reductions i)) {?}

  --  \func reduction-over-extension {tc : TheoremContext} {basic-context extended-context additional-context : List Sort'} {meta-signature : MetaSignature Sort'}
  --                                 (substA substB : Substitution {env} basic-context extended-context meta-signature)
  --                                 (sublist : SubList additional-context extended-context)
  --                                 (A=>B : \Pi (i : Fin (length basic-context)) -> Closure TrichromaticParallelReduction (substA i) (substB i))
  --                                 (j : Fin (length (basic-context ++ additional-context))) : Closure TrichromaticParallelReduction (extend-substitution-right {env} sublist substA j) (extend-substitution-right {env} sublist substB j) \elim basic-context, j
  --    | nil, j => c-basic (nothing, equal-trees idp)
  --    | :: a basic-context, zero => A=>B zero
  --    | :: a basic-context, suc j => reduction-over-extension (\lam i => substA (suc i)) (\lam i => substB (suc i)) sublist (\lam i => A=>B (suc i)) j

  --  \func apply-reducible-substitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
  --                                     (s : Term env context s meta-signature)
  --                                     (a-subst b-subst : Substitution {env} context context' meta-signature)
  --                                     (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
  --    : Closure TrichromaticParallelReduction (Substitution.apply {env} s a-subst) (Substitution.apply {env} s b-subst)
  --  \elim s
  --    | var index p => \case \elim s, \elim p \with {
  --      | s, idp => a~>b index
  --    }
  --    | metavar m choosing => {?} -- like the bottom one
  --    | func f choosing =>
  --      \let | choosing-a i => (Substitution.apply {env} (choosing i) (append-context-left {env} a-subst))
  --           | choosing-b i => (Substitution.apply {env} (choosing i) (append-context-left {env} b-subst))
  --           | q i => apply-reducible-substitution (choosing i) (append-context-left {env} a-subst) (append-context-left {env} b-subst) (reduction-over-left-append a-subst b-subst a~>b)
  --      \in gather-closure f choosing-a choosing-b q

  --  \func reduction-over-left-append {tc : TheoremContext} {context add-context context' : List Sort'} {meta-signature : MetaSignature Sort'}
  --                                   (a-subst b-subst : Substitution {env} context context' meta-signature)
  --                                   (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
  --                                   (i : Fin (length (add-context ++ context))) : Closure TrichromaticParallelReduction (append-context-left {env} a-subst i) (append-context-left {env} b-subst i) \elim add-context, i
  --    | nil, i => a~>b i
  --    | :: a add-context, zero => c-basic (nothing, equal-trees idp)
  --    | :: a add-context, suc i => \let x => reduction-over-left-append a-subst b-subst a~>b i \in reduction-over-weakening (append-context-left {env} a-subst i) (append-context-left {env} b-subst i) x (sublist-skip SubList.identity)

  \func reduction-over-weakening {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (T S : Term env context s meta-signature)
                                 (T~>S : Closure TrichromaticParallelReduction T S)
                                 (sublist : SubList context new-context)
    : Closure TrichromaticParallelReduction (weakening {env} T sublist) (weakening {env} S sublist) => {?}

  \func gather-closure {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                       (f : env.FunctionalSymbol.symbol s)
                       (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                       (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure TrichromaticParallelReduction (choosing-A index) (choosing-B index))
    : Closure TrichromaticParallelReduction (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- purely technical concatenation of closures

  \func gather-closure-regular {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                               (f : env.FunctionalSymbol.symbol s)
                               (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                               (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (choosing-A index) (choosing-B index))
    : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- similar to above, don't want to think about it rn

}
