\import Algebra.Ring.Localization
\import Confluence
\import Data.Bool
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.Union.TopLevel
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort} {meta-signature : MetaSignature Sort}
                         (term : Term envL c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          {meta-signature : MetaSignature Sort}
                          (term : Term envR c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | l-is-func => promote-injection-left {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-left {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envL context s meta-signature)
                                   (t-is-func : FunctionalRoot {envL} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-left envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | l-is-func => promote-injection-right {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-right {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envR context s meta-signature)
                                   (t-is-func : FunctionalRoot {envR} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-right envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\func JointRules {Sort : \Set} {envL envR : Environment Sort}
                 (L-rules : IndexedSet (RewriteRule envL))
                 (R-rules : IndexedSet (RewriteRule envR))
  : IndexedSet (RewriteRule (JointEnvironment envL envR)) =>
  \let
    | injected-left-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-left {_} {envL} {envR} L-rules
    | injected-right-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-right {_} {envL} {envR} R-rules
  \in JointIndexedSet injected-left-set injected-right-set

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                   (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
: SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules => JointRules {_} {envL} {envR} L.set-of-rules R.set-of-rules
  | meta-signature => meta-signature

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                                  (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort} {meta-signature : MetaSignature Sort}
                                         {context : List Sort} (A B : Term env context s meta-signature) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {context} {s}) A B

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : Environment Sort'
    | envR : Environment Sort'
    | L-rules : IndexedSet (RewriteRule envL)
    | R-rules : IndexedSet (RewriteRule envR)
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (RewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term (colored-env {tc} color) context s meta-signature): \Prop
    \elim color
      | red => RewriteRelation {envL} L-rules A B
      | blue => RewriteRelation {envR} R-rules A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (t : Term (colored-env color) context s meta-signature) : Term env context s meta-signature \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (term : Term env context s meta-signature) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      | _, metavar _ _ => uncolored-metavar-root
      | _, var _ _ => uncolored-var-root

    \data HasMetaRoot {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (term : Term env context s meta-signature) \elim term
      | metavar _ _ => has-meta-root

    \func color-of-root {_ : TheoremContext} {s : Sort'} (f : env.FunctionalSymbol.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR

    \func colored-rules {tc : TheoremContext} (color : Color) : IndexedSet (RewriteRule (env {tc})) \elim color
      | red => Injections.promote-indexed-set-left {tc.Sort'} {tc.envL} {tc.envR} (L-rules)
      | blue => Injections.promote-indexed-set-right {tc.Sort'} {tc.envL} {tc.envR} (R-rules)
  }

  \open TheoremContext

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} (A B : Term env context s meta-signature) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot {tc} color A) (step : LinearRewriteStep {env {tc}} A B) --(step.rule IndexedSet.in {LinearRewriteRule step.env} (colored-rules coor)) todo
    | func (f-A : symbol {FunctionalSymbol {env {tc}}} s) choosing-A, func (f-B : symbol {FunctionalSymbol {env {tc}}} s) choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root {tc} f-A = color)
                                     (ReductionAtIndex {env {tc}}
                                         (TopLevelColoredReduction {tc} color {meta-signature})
                                         (\lam i => (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i ++ {Sort {env {tc}}} context))
                                         (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} __)
                                         choosing-A
                                         (transport-chooser-f {env {tc}} p choosing-B))

  \data BorderedParallelReduction {tc : TheoremContext}
                                  (global-color : Color)
                                  (color : Maybe Color)
                                  {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
                                  (A B : Term (env {tc}) context s meta-signature) \elim A
    | A => equal-trees (A = B)
    | func f choosing =>
    parallelization-f
      (mediator : \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) ->
          Term (env {tc}) ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
      (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f) -> \Sigma
        (someColor : Maybe Color)
        ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f))))
        (BorderedParallelReduction {tc} global-color someColor (choosing i) (mediator i)))
      (ColorwiseReduction {tc} global-color color (func f mediator) B)
  --    | metavar m choosing =>
  --    parallelization-m
  --      (mediator : \Pi (index : Fin (length (m-domain m))) -> Term (env {tc}) (context) (m-domain m !! index) meta-signature)
  --      (\Pi (i : Fin (length (m-domain m))) -> (BorderedParallelReduction {tc} global-color color (choosing i) (mediator i)))
  --      (metavar {env {tc}} m mediator = B)

  \data ColorwiseReduction {tc : TheoremContext}
                           {context : List Sort'}
                           {s : Sort'}
                           {meta-signature : MetaSignature Sort'}
                           (global-color : Color)
                           (color : Maybe Color) (A B : Term env context s meta-signature) \elim color
    | nothing => cr-skip (A = B)
    | just color => cr-rewrite (TopLevelColoredReduction {tc} color A B) (global-color = color)

  \func TrichromaticParallelReduction {tc : TheoremContext} {meta-signature : MetaSignature Sort'} {context : List tc.Sort'} {s : Sort'} (A B : Term env context s meta-signature) : \Type =>
    \Sigma (global-color : Color) (color : Maybe Color) (BorderedParallelReduction global-color color A B)

  \func ConfluentialSystem (env : Environment) (rules : IndexedSet (RewriteRule env)) : \Type =>
    \Pi {meta-signature : MetaSignature Sort} {context : List Sort} {s : Sort}
        (A B C : Term env context s meta-signature)
        (RewriteRelation rules A B)
        (RewriteRelation rules A C) -> StraightJoin B C ((RewriteRelation rules))

  \func bpr-confluence {tc : TheoremContext} {gc1 gc2 : Color} (color1 color2 : Maybe Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  {A B C : Term env context s meta-signature}
                       (A~>B : BorderedParallelReduction gc1 color1 A B)
                       (A~>C : BorderedParallelReduction gc2 color2 A C)
                       (left-confluence : ConfluentialSystem envL L-rules)
                       (right-confluence : ConfluentialSystem envR R-rules)
    : \Sigma (D : Term env context s meta-signature)
             (color3 : Maybe Color)
             ((color3 = nothing) `Or` (color3 = color2) )
             (color4 : Maybe Color)
             ((color4 = color1) `Or` (color4 = nothing))
             (BorderedParallelReduction gc2 color3 B D)
             (BorderedParallelReduction gc1 color4 C D) \elim color1, color2, A, B, C, A~>B, A~>C
    | color1, color2, A, B, C, equal-trees p, equal-trees p1 => (A, color2, inr idp, color1, inl idp, equal-trees (inv p), (equal-trees (inv p1))) -- easy
    | color1, color2, func f choosing, B, C, equal-trees p, parallelization-f mediator _x c => {?} -- easy
    | color1, color2, func f choosing, B, C, parallelization-f mediator _x c, equal-trees p => {?} -- easy
    | nothing, nothing, func f choosing, B, C, parallelization-f mediator choosing->med (cr-skip famed=B), parallelization-f mediator' choosing->med' (cr-skip famed'=C)
    => \let | inner-confluences i => bpr-confluence (choosing->med i).1 (choosing->med' i).1 (choosing->med i).3 (choosing->med' i).3 left-confluence right-confluence
            | D => func {env} f (\lam i => (inner-confluences i).1)
       \in (func f (\lam i => (inner-confluences i).1),
            nothing,
            inl idp,
            nothing,
            inl idp,
            rewriteI famed=B (parallelization-f (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).2, {?}, (inner-confluences i).6)) (cr-skip idp)), -- get color from choosing-med
            rewriteI famed'=C (parallelization-f (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).4, {?}, (inner-confluences i).7)) (cr-skip idp)))
    | nothing, just a, func f choosing, B, C, parallelization-f mediator _x (cr-skip p), parallelization-f mediator1 _x1 (cr-rewrite t gc2=a) => {?} -- subcases of the last one
    | just a, nothing, func f choosing, B, C, parallelization-f mediator _x (cr-rewrite t gc1=a), parallelization-f mediator1 _x1 (cr-skip p) => {?}
    | just left-color, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-rewrite med~>C gc2=right-color)
    => \let
        | lcolor=rcolor : left-color = right-color => {?} -- as reductions from functional symbol
        | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
        | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
        | (leftmost-reduct, flr~>lr, B=>lr) => unify-top left-color f mediator (\lam i => (joined-mediators i).1) B med~>B (\lam index => ((joined-mediators index).2, {?}, rewrite (lcolor=rcolor *> inv gc2=right-color) (joined-mediators index).6))
        | (rightmost-reduct, flr~>rr, C=>rr) => unify-top right-color f mediator' (\lam i => (joined-mediators i).1) C med~>C (\lam index => ((joined-mediators index).4, {?}, rewrite (inv lcolor=rcolor *> inv gc1=left-color) (joined-mediators index).7))
        | (common-reduct, lr~>cr, rr~>cr) => join-different-tlcrs left-color right-color flr~>lr flr~>rr left-confluence right-confluence
       \in (common-reduct,
            just gc2,
            {?}, -- as all colors are equal
            {?},
            {?},
            gather-reduction gc2 (rewriteI (lcolor=rcolor *> inv gc2=right-color) B=>lr) (rewrite gc2=right-color lr~>cr),
            {?})
    \where {
      \func join-different-tlcrs {tc : TheoremContext} (color1 color2 : Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  {A B C : Term env context s meta-signature}
                                 (A~>B : TopLevelColoredReduction color1 A B)
                                 (A~>C : TopLevelColoredReduction color2 A C)
                                 (left-confluence : ConfluentialSystem envL L-rules)
                                 (right-confluence : ConfluentialSystem envR R-rules)
        : \Sigma (X : Term env context s meta-signature) (TopLevelColoredReduction color2 B X) (TopLevelColoredReduction color1 C X) \elim color1, color2
        | red, red => join-tlcrs red A B C A~>B A~>C left-confluence
        | red, blue => {?} -- colors are equal
        | blue, red => {?}
        | blue, blue => join-tlcrs blue A B C A~>B A~>C right-confluence

      \func gather-reduction {tc : TheoremContext}
                             (color : Color)
                             {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {B lr X : Term env context s meta-signature}
                             (B=>lr : BorderedParallelReduction color nothing B lr)
                             (lr~>X : TopLevelColoredReduction color lr X)
        : BorderedParallelReduction color (just color) B X \elim B, B=>lr
        | B, equal-trees p => {?} -- lr must start from func symbol, as it is lhs of tlcr. So is B. easy. (if it is metavar, same should apply)
        | func f choosing, parallelization-f mediator _x (cr-skip p) => parallelization-f mediator _x (cr-rewrite (rewrite p lr~>X) idp)
    }

  \func unify-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                  (f : env.FunctionalSymbol.symbol s)
                  (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                  (B : Term env context s meta-signature)
                  (A~>B : TopLevelColoredReduction color (func f choosing-A) B)
                  (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f) ->
                      \Sigma (someColor : Maybe Color)
                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
                             (BorderedParallelReduction {tc} color someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
    : \Sigma (X : Term env context s meta-signature)
             (TopLevelColoredReduction color (func f choosing-C) X)
             (BorderedParallelReduction color nothing B X) =>
    \let
      | (t, rho, t[rho]=A, root-colors) => decompose-term color (func f choosing-A)
      | (u, lu[rho]=B, t~>u) => decompose-along-reduction color t B rho (rewrite t[rho]=A A~>B)
      | eqs : LinearMetasignatureT {colored-env color} t = LinearMetasignatureT {env} (inject-linear-term color t) => {?} -- obvious
      | eqs2 : (LinearTerm.convert-to-term {env} (inject-linear-term color t)) =  (transport (Term env context s) eqs (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t))) => {?} -- technical
      | injected-u : Term env context s (LinearMetasignatureT {env} (inject-linear-term color t)) => rewriteI eqs (inject-monochrome-term color u)
      | modified-rho => transport (MetaSubstitution env nil __ meta-signature) eqs rho
      | eqs3 : (func {env} f choosing-A) = (MetaSubstitution.apply {env} (LinearTerm.convert-to-term {env} (inject-linear-term color t)) sublist-trivial modified-rho) => {?}
      | (sigma, C=t[sigma], reds) => alternate-subst {_} color (func f choosing-C) (inject-linear-term {_} color t) modified-rho nothing (inl idp) (rewriteI eqs3 (parallelization-f choosing-C inner-reductions (cr-skip idp)))
      | uni-right => lift-relation color (transport (MetaSubstitution env nil __ meta-signature) (inv eqs) sigma) t~>u
      | uni-left => unify-left color color injected-u sublist-trivial modified-rho sigma reds
    \in metasignature-unificator eqs color B (func f choosing-C)
        (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t))
        (inject-monochrome-term color u)
        rho
        sigma
        lu[rho]=B
        (rewriteI eqs2 C=t[sigma])
        uni-right
        uni-left
    \where {
      \func metasignature-unificator {tc : TheoremContext} {context : List Sort'} {s : Sort'} {left-meta-signature right-meta-signature outer-meta-signature : MetaSignature Sort'}
                                     (meta-signature-equality : left-meta-signature = right-meta-signature)
                                     (color : Color)
                                     (B C : Term env context s outer-meta-signature)
                                     (inj-t inj-u : Term env context s left-meta-signature)
                                     (rho : MetaSubstitution env nil left-meta-signature outer-meta-signature)
                                     (sigma : MetaSubstitution env nil right-meta-signature outer-meta-signature)
                                     (lu[rho]=b : MetaSubstitution.apply {env} inj-u sublist-trivial rho = B)
                                     (C=t[sigma] : C = MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-t) sublist-trivial sigma)
                                     (uni-right : TopLevelColoredReduction color
                                         (MetaSubstitution.apply {env} (inj-t) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) (inv meta-signature-equality) sigma))
                                         (MetaSubstitution.apply {env} (inj-u) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) (inv meta-signature-equality) sigma)))
                                     (uni-left : BorderedParallelReduction color nothing
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) meta-signature-equality rho))
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) sublist-trivial sigma))
        : \Sigma (X : Term env context s outer-meta-signature)
                 (TopLevelColoredReduction color C X)
                 (BorderedParallelReduction color nothing B X) \elim meta-signature-equality
        | idp => (MetaSubstitution.apply {env} inj-u sublist-trivial sigma,
                  rewrite C=t[sigma] uni-right,
                  rewriteI lu[rho]=b uni-left)

      \func recreate-coloring-for-root {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {color : Color} {f : env.FunctionalSymbol.symbol s}
                                       {choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                                       (h : HasColoredRoot color (func f choosing-A)) : HasColoredRoot color (func f choosing-C) \elim color, f, h
        | red, inl s1, red-func-root => red-func-root
        | blue, inr s1, blue-func-root => blue-func-root
    }

  \func alternate-subst {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (gc : Color)
                        (C : Term env context s meta-signature)
                        (t : LinearTerm env context s)
                        (rho : MetaSubstitution env nil (LinearMetasignatureT {env} t) meta-signature)
                        (someColor : Maybe Color)
                        (some-color-diff : (someColor = nothing) `Or` (someColor = just (Color.flip gc)))
                        (A=>C : BorderedParallelReduction gc someColor (MetaSubstitution.apply {env} ((LinearTerm.convert-to-term {env} t)) sublist-trivial rho) C)
    : \Sigma (sigma : MetaSubstitution env nil (LinearMetasignatureT {env} t) meta-signature)
             (C = MetaSubstitution.apply {env} ((LinearTerm.convert-to-term {env} t)) (sublist-trivial) sigma)
             (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignatureT {env} t} s) ->
                 \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (rho m) (sigma m)))
    \elim t, someColor, A=>C
      | lt-func f choosing, nothing, parallelization-f mediator inner-reductions (cr-skip p) =>
        \let inductive-result i => alternate-subst gc (mediator i) (choosing i) (\lam m => rho (i, m)) (inner-reductions i).1 {?} {?}
        \in (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2, inv p *> {?}, \lam {s1} m => (inductive-result (m.1)).3 m.2)
      | lt-func f choosing, just color, parallelization-f mediator inner-reductions (cr-rewrite t p) => {?} -- impossible, color conflict
      | lt-func f choosing, someColor, equal-trees p => (rho, inv p, \lam {s1} m => (nothing, equal-trees idp))
      | lt-metavar params choosing, someColor, rd => {?}
      | lt-full-metavar, someColor, rd =>
        (\lam {s1} mvar => transport2 (\lam ctx srt => Term env ctx srt meta-signature) (inv ++_nil) (inv mvar) C,
         rewrite (transport2-to-transport) (inv (plain-identity-effect {env} C) *> (apply-subst-with-extended-identity {env} C (\lam i => var i idp))),
         {?})
      | lt-var index p, someColor, equal-trees p1 => (\lam {s1} mvar => contradiction, inv p1, \lam {s1} m => contradiction)
    \where {
      \func pattern-can't-be-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature new-meta-signature : MetaSignature Sort}
                                 (T : Term env nil s meta-signature)
                                 (subst : MetaSubstitution env context meta-signature new-meta-signature)
                                 (someIndex : Fin (length context)) (someProof : s = context !! someIndex)
                                 (eq : MetaSubstitution.apply (weakening T sublist-trivial) SubList.identity subst = var someIndex someProof)
                                 (T-functional : FunctionalRoot T) : Empty \elim T, T-functional
        | func f choosing, T-has-functional-root => contradiction

      \func identify-context-mapping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                     (sublist : SubList right-context (left-context ++ right-context))
                                     (sublist' : SubList left-context (left-context ++ right-context))
                                     (ind : Fin (length (left-context ++ right-context))) :
        (extend-substitution-right {env} {_} {_} {_} {meta-signature} sublist (wide-identity sublist')) ind = var ind idp
      \elim left-context, right-context, ind
        | nil, :: a right-context, zero => {?}
        | nil, :: a right-context, suc ind => {?} -- rewrite (extension-over-identity-is-identity ind) idp
        | :: a left-context, nil, zero => {?}
        | :: a left-context, r, suc ind => {?}
        | :: a left-context, :: a1 right-context, zero => {?}
        \where {
          \func outer-equality-to-identity {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                           (sublist : SubList right-context (left-context ++ right-context))
                                           (sublist' : SubList left-context (left-context ++ right-context)) (i : Fin (length (left-context ++ right-context))) : extend-substitution-right sublist (wide-identity sublist') i = plain-identity {_} {_} {meta-signature} i =>
            {?}

          \func extension-over-identity-is-identity {A : \Type} {some-context : List A} (j : Fin (length some-context)) : extend-substitution-right.produce-inner-term SubList.identity j = (j, idp) \elim some-context, j
            | :: a some-context, zero => idp
            | :: a some-context, suc j => rewrite (extension-over-identity-is-identity j) idp

          \func extension-over-skipping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort} {a : Sort}
                                        (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                        (j : Fin (length (left-context ++ right-context)))
                                        (eq : extend-substitution-right {_} {_} {_} {_} {meta-signature} (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j = var j idp)
            : extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j = var (suc j) idp =>
            \let | rrr => pmap (weakening {_} {_} {_} {a :: (left-context ++ right-context)} __ (sublist-skip SubList.identity)) eq
                 | qqq : rrr @ right = var (suc j) idp => \let internal => recalculate-over-skipping {_} {a} j \in pmap sigma-to-var internal
                 | zzz : rrr @ left = extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j => weakining-extension-comms index-calculator j
            \in inv zzz *> rrr *> qqq

          \func sigma-to-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (sig : \Sigma (i : Fin (length context)) (s = context !! i)) : Term env context s meta-signature =>
            var sig.1 sig.2

          \func recalculate-over-skipping {A : \Set} {point' : A} {a : List A} (ind : Fin (length a)) : weakening.recalculate-index {_} {a} {point' :: a} (sublist-skip SubList.identity) ind idp = (suc ind, idp) \elim a, ind
            | :: a a1, zero => idp
            | :: a a1, suc ind => rewrite (weakening.recalculate-index-over-identity ind) idp

          \func weakining-extension-comms {env : Environment} {left-context right-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort}
                                          (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                          (j : Fin (length (left-context ++ right-context)))
            : weakening {_} {_} {_} {_} {meta-signature}
              (extend-substitution-right (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j)
              (sublist-skip SubList.identity) =
          extend-substitution-right {_} {_} {_} {s :: left-context ++ right-context}
              (sublist-skip (SubList.extend-right-single-left SubList.identity))
              (\lam i => \let (index, p) => index-calculator i \in var (suc index) p)
              j => {?}
        }

      \func unwrap-func {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                        (T : Term env context s meta-signature) : Or Nat
          (\Sigma (f : env.FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
              Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) \elim T
        | var index p => inl 0
        | metavar m choosing1 => inl 0
        | func f1 choosing1 => inr (f1, choosing1)

      \func unwrap-func' {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                         {f'' : env.FunctionalSymbol.symbol s}
                         {choosing choosing' : \Pi (index : Fin (length (env.FunctionalSymbol.domain f''))) ->
                             Term env ((f'' FunctionalSignature.!!param index) ++ context) (f'' FunctionalSignature.!!sort index) meta-signature}
                         (eq : func f'' choosing = func f'' choosing') : choosing' = choosing => sigma-set-equalizer (\lam f => \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) (inv (pmap (decomposeTermAsFunctionalSymbol (f'', choosing)) eq))

      \func sigma-set-equalizer {A : \Set} (B : A -> \Type) {a : A} {b b' : B a} (p : (a,b) = {\Sigma (x : A) (B x)} (a,b')) : b = b'
        => pmap (transport B __ b) (Path.inProp idp (pmap __.1 p)) *> pmapd (\lam t => B t.1) __.2 p

      \func decomposeTermAsFunctionalSymbol {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                                            (default : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
                                                Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) (T : Term env context s meta-signature) : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) \elim T
        | var index p => default
        | metavar m choosing => default
        | func f choosing => (f, choosing)

      \func apply-modularity {env : Environment} {context subst-context pattern-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n}
                             (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (pat-sublist : SubList pattern-context context)
                             (t : Term env pattern-context s (producer index)) :
        MetaSubstitution.apply (weakening t pat-sublist) sublist (substitutions index) = MetaSubstitution.apply (weakening (LinearPattern.upgrade-metavariables-p producer t) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim t
        | var index1 p => idp
        | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-right sublist e)) (ext (\lam i => apply-modularity producer substitutions sublist pat-sublist (choosing i)))
        | func f choosing => pmap (func f) (ext (\lam i => apply-modularity producer substitutions (SubList.extend-right-single-left sublist) (SubList.extend-left pat-sublist) (choosing i)))
    }

  \data Closure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | c-trivial (a = b)
    | c-basic (a `R` b)
    | c-connect (c : A) (a `R` c) (Closure R c b)
    \where {
      \func concat {A : \Type} {R : A -> A -> \Type} {a b c : A} (a~>b : Closure R a b) (b~>c : Closure R b c) : Closure R a c \elim a~>b, b~>c
        | c-basic r, rx => c-connect b r rx
        | c-connect c1 r a~>b, rx => c-connect c1 r (concat a~>b rx)
        | c-trivial idp, b~>c => b~>c

      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : Closure Rel x y) : Closure Rel' (map x) (map y) \elim closure
        | c-basic r => c-basic (rel-map r)
        | c-connect c r closure => c-connect (map c) (rel-map r) (lift map rel-map c y closure)
        | c-trivial idp => c-trivial idp

      \func flatten {A : \Type} {Rel : A -> A -> \Type}
                    {x y : A}
                    (closure : Closure (Closure Rel) x y) : Closure Rel x y \elim closure
        | c-basic r => r
        | c-connect c r closure => concat r (flatten closure)
        | c-trivial idp => c-trivial idp
    }

  \func unify-left {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature inner-metasignature : MetaSignature Sort'}
                   (gc anti-color : Color)
                   (s : Term env context' s inner-metasignature)
                   (sublist : SubList context context')
                   (rho sigma : MetaSubstitution env context inner-metasignature meta-signature)
                   (rho~>sigma : \Pi {s : Sort'} (m : inner-metasignature.metaname s) ->
                       \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (rho m) (sigma m))) :
    (BorderedParallelReduction gc nothing (MetaSubstitution.apply {env} s sublist rho) (MetaSubstitution.apply {env} s sublist sigma))
  \elim s
    | var index p => equal-trees idp
    | metavar m choosing =>
      \let | main-reduction => rho~>sigma m
           | rho-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho))
           | sigma-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma))
           | in-indices i => unify-left gc anti-color (choosing i) sublist rho sigma rho~>sigma
           | target-reduction => reduction-over-substitution (rho m) (sigma m) main-reduction.1 main-reduction.2 rho-subst sigma-subst {?} -- extension of substitutions
           | color-is-nothing : main-reduction.1 = nothing => {?}-- this is provable as color of rho is not the same as gc, and we have rewriting of this (not gc) color from rho(m) to sigma(m). So this rewriting has the opposite color and the entire level must be skipped, i.e. color of rewriting is nothing
      \in rewriteI color-is-nothing target-reduction
    | func f choosing => -- f is ALWAYS has color the same as gc
      \let | in-indices i => unify-left gc (color-of-root f) (choosing i) (SubList.extend-right-single-left sublist) rho sigma rho~>sigma
      \in parallelization-f (\lam i => (MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single-left sublist) sigma)) (\lam i => (nothing, inl idp, in-indices i)) (cr-skip idp)

  \func reduction-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                    (A B : Term env context s meta-signature)
                                    {gc : Color}
                                    (color : Maybe Color)
                                    (A=>B : BorderedParallelReduction gc color A B)
                                    (subst subst' : Substitution {env} context new-context meta-signature)
                                    (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    : BorderedParallelReduction gc color (Substitution.apply {env} A subst) (Substitution.apply {env} B subst') \elim A, A=>B
    | A, equal-trees p => {?}
    | func f choosing, parallelization-f mediator _x c =>
      \let | x => 1
           | medium-reductions i => reduction-over-substitution (choosing i) (mediator i) (_x i).1 (_x i).3 (append-context-left {env} subst) (append-context-left {env} subst') {?}
      \in parallelization-f (\lam i => Substitution.apply {env} (mediator i) (append-context-left {env} subst')) (\lam i => ((_x i).1, (_x i).2, medium-reductions i)) {?}

  --  \func reduction-over-extension {tc : TheoremContext} {basic-context extended-context additional-context : List Sort'} {meta-signature : MetaSignature Sort'}
  --                                 (substA substB : Substitution {env} basic-context extended-context meta-signature)
  --                                 (sublist : SubList additional-context extended-context)
  --                                 (A=>B : \Pi (i : Fin (length basic-context)) -> Closure TrichromaticParallelReduction (substA i) (substB i))
  --                                 (j : Fin (length (basic-context ++ additional-context))) : Closure TrichromaticParallelReduction (extend-substitution-right {env} sublist substA j) (extend-substitution-right {env} sublist substB j) \elim basic-context, j
  --    | nil, j => c-basic (nothing, equal-trees idp)
  --    | :: a basic-context, zero => A=>B zero
  --    | :: a basic-context, suc j => reduction-over-extension (\lam i => substA (suc i)) (\lam i => substB (suc i)) sublist (\lam i => A=>B (suc i)) j

  --  \func apply-reducible-substitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
  --                                     (s : Term env context s meta-signature)
  --                                     (a-subst b-subst : Substitution {env} context context' meta-signature)
  --                                     (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
  --    : Closure TrichromaticParallelReduction (Substitution.apply {env} s a-subst) (Substitution.apply {env} s b-subst)
  --  \elim s
  --    | var index p => \case \elim s, \elim p \with {
  --      | s, idp => a~>b index
  --    }
  --    | metavar m choosing => {?} -- like the bottom one
  --    | func f choosing =>
  --      \let | choosing-a i => (Substitution.apply {env} (choosing i) (append-context-left {env} a-subst))
  --           | choosing-b i => (Substitution.apply {env} (choosing i) (append-context-left {env} b-subst))
  --           | q i => apply-reducible-substitution (choosing i) (append-context-left {env} a-subst) (append-context-left {env} b-subst) (reduction-over-left-append a-subst b-subst a~>b)
  --      \in gather-closure f choosing-a choosing-b q

  --  \func reduction-over-left-append {tc : TheoremContext} {context add-context context' : List Sort'} {meta-signature : MetaSignature Sort'}
  --                                   (a-subst b-subst : Substitution {env} context context' meta-signature)
  --                                   (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
  --                                   (i : Fin (length (add-context ++ context))) : Closure TrichromaticParallelReduction (append-context-left {env} a-subst i) (append-context-left {env} b-subst i) \elim add-context, i
  --    | nil, i => a~>b i
  --    | :: a add-context, zero => c-basic (nothing, equal-trees idp)
  --    | :: a add-context, suc i => \let x => reduction-over-left-append a-subst b-subst a~>b i \in reduction-over-weakening (append-context-left {env} a-subst i) (append-context-left {env} b-subst i) x (sublist-skip SubList.identity)

  \func reduction-over-weakening {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (T S : Term env context s meta-signature)
                                 (T~>S : Closure TrichromaticParallelReduction T S)
                                 (sublist : SubList context new-context)
    : Closure TrichromaticParallelReduction (weakening {env} T sublist) (weakening {env} S sublist) => {?}

  \func gather-closure {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                       (f : env.FunctionalSymbol.symbol s)
                       (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                       (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure TrichromaticParallelReduction (choosing-A index) (choosing-B index))
    : Closure TrichromaticParallelReduction (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- purely technical concatenation of closures

  \func gather-closure-regular {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                               (f : env.FunctionalSymbol.symbol s)
                               (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                               (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (choosing-A index) (choosing-B index))
    : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- similar to above, don't want to think about it rn

}
