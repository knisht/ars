\import Algebra.Ring.Localization
\import Confluence
\import Data.Bool
\import Data.List (++, ++-assoc, ::, List, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import TRS.HRS
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.Union.TopLevel
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort} {meta-signature : MetaSignature Sort}
                         (term : Term envL c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          {meta-signature : MetaSignature Sort}
                          (term : Term envR c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | l-is-func => promote-injection-left {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-left {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envL context s meta-signature)
                                   (t-is-func : FunctionalRoot {envL} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-left envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | l-is-func => promote-injection-right {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-right {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envR context s meta-signature)
                                   (t-is-func : FunctionalRoot {envR} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-right envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\func JointRules {Sort : \Set} {envL envR : Environment Sort}
                 (L-rules : IndexedSet (RewriteRule envL))
                 (R-rules : IndexedSet (RewriteRule envR))
  : IndexedSet (RewriteRule (JointEnvironment envL envR)) =>
  \let
    | injected-left-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-left {_} {envL} {envR} L-rules
    | injected-right-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-right {_} {envL} {envR} R-rules
  \in JointIndexedSet injected-left-set injected-right-set

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                   (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
: SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules => JointRules {_} {envL} {envR} L.set-of-rules R.set-of-rules
  | meta-signature => meta-signature

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                                  (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort} {meta-signature : MetaSignature Sort}
                                         {context : List Sort} (A B : Term env context s meta-signature) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {context} {s}) A B

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : Environment Sort'
    | envR : Environment Sort'
    | L-rules : IndexedSet (RewriteRule envL)
    | R-rules : IndexedSet (RewriteRule envR)
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (RewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term (colored-env {tc} color) context s meta-signature): \Prop
    \elim color
      | red => RewriteRelation {envL} L-rules A B
      | blue => RewriteRelation {envR} R-rules A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (t : Term (colored-env color) context s meta-signature) : Term env context s meta-signature \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (term : Term env context s meta-signature) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      | _, metavar _ _ => uncolored-metavar-root
      | _, var _ _ => uncolored-var-root

    \func color-of-root {_ : TheoremContext} {s : Sort'} (f : env.FunctionalSymbol.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR

    \func colored-rules {tc : TheoremContext} (color : Color) : IndexedSet (RewriteRule (env {tc})) \elim color
      | red => Injections.promote-indexed-set-left {tc.Sort'} {tc.envL} {tc.envR} (L-rules)
      | blue => Injections.promote-indexed-set-right {tc.Sort'} {tc.envL} {tc.envR} (R-rules)
  }

  \open TheoremContext

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} (A B : Term env context s meta-signature) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot {tc} color A) (step : LinearRewriteStep {env {tc}} A B) --(step.rule IndexedSet.in {LinearRewriteRule step.env} (colored-rules coor)) todo
    | func (f-A : symbol {FunctionalSymbol {env {tc}}} s) choosing-A, func (f-B : symbol {FunctionalSymbol {env {tc}}} s) choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root {tc} f-A = color)
                                     (ReductionAtIndex {env {tc}}
                                         (TopLevelColoredReduction {tc} color {meta-signature})
                                         (\lam i => (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i ++ {Sort {env {tc}}} context))
                                         (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} __)
                                         choosing-A
                                         (transport-chooser-f {env {tc}} p choosing-B))

  \data BorderedParallelReduction {tc : TheoremContext} (color : Maybe Color) {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
                                  (A B : Term (env {tc}) context s meta-signature) \elim A, B
    | A, B => equal-trees (A = B)
    | func f choosing, B =>
    parallelization-f
      (mediator : \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) ->
          Term (env {tc}) ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
      (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f) -> \Sigma
        (someColor : Maybe Color)
        ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f))))
        (BorderedParallelReduction {tc} someColor (choosing i) (mediator i)))
      (ColorwiseReduction {tc} color (func f mediator) B)

  \data ColorwiseReduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Maybe Color) (A B : Term env context s meta-signature) \elim color
    | nothing => cr-skip (A = B)
    | just color => cr-rewrite (TopLevelColoredReduction {tc} color A B)

  \func TrichromaticParallelReduction {tc : TheoremContext} {meta-signature : MetaSignature Sort'} {context : List tc.Sort'} {s : Sort'} (A B : Term env context s meta-signature) : \Type =>
    \Sigma (color : Maybe Color) (BorderedParallelReduction color A B)

  \func ConfluentialSystem (env : Environment) (rules : IndexedSet (RewriteRule env)) : \Type =>
    \Pi {meta-signature : MetaSignature Sort} {context : List Sort} {s : Sort}
        (A B C : Term env context s meta-signature)
        (RewriteRelation rules A B)
        (RewriteRelation rules A C) -> StraightJoin B C (Closure (RewriteRelation rules))

  \func bpr-confluence {tc : TheoremContext} (color1 color2 : Maybe Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  {A B C : Term env context s meta-signature}
                       (A~>B : BorderedParallelReduction color1 A B)
                       (A~>C : BorderedParallelReduction color2 A C)
                       (left-confluence : ConfluentialSystem envL L-rules)
                       (right-confluence : ConfluentialSystem envR R-rules)
    : \Sigma (D : Term env context s meta-signature)
             (color3 : Maybe Color)
             ((color3 = color2) `Or` (color3 = nothing))
             (color4 : Maybe Color)
             ((color4 = color1) `Or` (color4 = nothing))
             (BorderedParallelReduction color3 B D)
             (BorderedParallelReduction color4 C D) \elim color1, color2, A, B, C, A~>B, A~>C
    | color1, color2, A, B, C, equal-trees p, equal-trees p1 => {?} -- easy
    | color1, color2, func f choosing, B, C, equal-trees p, parallelization-f mediator _x c => {?} -- easy
    | color1, color2, func f choosing, B, C, parallelization-f mediator _x c, equal-trees p => {?} -- easy
    | nothing, nothing, func f choosing, B, C, parallelization-f mediator choosing->med (cr-skip famed=B), parallelization-f mediator' choosing->med' (cr-skip famed'=C)
    => \let | inner-confluences i => bpr-confluence (choosing->med i).1 (choosing->med' i).1 (choosing->med i).3 (choosing->med' i).3 left-confluence right-confluence
            | D => func {env} f (\lam i => (inner-confluences i).1)
       \in (func f (\lam i => (inner-confluences i).1),
            nothing,
            inl idp,
            nothing,
            inl idp,
            rewriteI famed=B (parallelization-f (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).2, {?}, (inner-confluences i).6)) (cr-skip idp)),
            rewriteI famed'=C (parallelization-f (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).4, {?}, (inner-confluences i).7)) (cr-skip idp)))
    | nothing, just a, func f choosing, B, C, parallelization-f mediator _x (cr-skip p), parallelization-f mediator1 _x1 (cr-rewrite t) => {?} -- subcases of the last one
    | just a, nothing, func f choosing, B, C, parallelization-f mediator _x (cr-rewrite t), parallelization-f mediator1 _x1 (cr-skip p) => {?}
    | just left-color, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B), parallelization-f mediator' choosing=>med' (cr-rewrite med~>C)
    => \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
            | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
            | (leftmost-reduct, flr~>lr, B=>lr) => unify-top left-color f mediator (\lam i => (joined-mediators i).1) B med~>B (\lam index => ((joined-mediators index).2, {?}, (joined-mediators index).6))
            | (rightmost-reduct, flr~>rr, C=>rr) => unify-top right-color f mediator' (\lam i => (joined-mediators i).1) C med~>C (\lam index => ((joined-mediators index).4, {?}, (joined-mediators index).7))
            | (common-reduct, lr~>cr, rr~>cr) => join-different-tlcrs left-color right-color flr~>lr flr~>rr left-confluence right-confluence
       \in (common-reduct,
            just right-color,
            {?},
            {?},
            {?},
            gather-reduction right-color B=>lr lr~>cr,
            gather-reduction left-color C=>rr rr~>cr)
    \where {
      \func join-different-tlcrs {tc : TheoremContext} (color1 color2 : Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  {A B C : Term env context s meta-signature}
                                 (A~>B : TopLevelColoredReduction color1 A B)
                                 (A~>C : TopLevelColoredReduction color2 A C)
                                 (left-confluence : ConfluentialSystem envL L-rules)
                                 (right-confluence : ConfluentialSystem envR R-rules)
        : \Sigma (X : Term env context s meta-signature) (TopLevelColoredReduction color2 B X) (TopLevelColoredReduction color1 C X) \elim color1, color2
        | red, red => join-tlcrs red A B C A~>B A~>C left-confluence
        | red, blue => {?}
        | blue, red => {?}
        | blue, blue => join-tlcrs blue A B C A~>B A~>C right-confluence

      \func gather-reduction {tc : TheoremContext} (color : Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {B lr X : Term env context s meta-signature}
                             (B=>lr : BorderedParallelReduction nothing B lr)
                             (lr~>X : TopLevelColoredReduction color lr X)
                             : BorderedParallelReduction (just color) B X \elim B, B=>lr
        | B, equal-trees p => {?} -- lr must start from func symbol, as it is lhs of tlcr. So is B. easy.
        | func f choosing, parallelization-f mediator _x (cr-skip p) => parallelization-f mediator _x (cr-rewrite (rewrite p lr~>X))
    }

  \func extract-top-level {tc : TheoremContext} (global-context : List tc.Sort') {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                          (color : Color)
                          (sublist : SubList global-context context)
                          (A : Term env context s meta-signature) : \Sigma (internal-ms : MetaSignature Sort')
                                                                           (t : Term env context s internal-ms)
                                                                           (subst : MetaSubstitution env global-context internal-ms meta-signature)
                                                                           (A = MetaSubstitution.apply {env} t sublist subst)
  \elim color, A
    | _, var index p =>
      \let | empty-signature => \new MetaSignature Sort' {
        | metaname _ => Empty
        | m-domain a => contradiction
      }
      \in (empty-signature, var index p, \lam _ => contradiction, idp)
    | color, metavar m choosing =>
      \let | inner-results i => extract-top-level global-context color sublist (choosing i)
           | signature-producer i => (inner-results i).1
           | unified-metasignature => PointedModularMetaSignature {env} m signature-producer
           | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam {s'} m => \case \elim m \with {
             | inl a => \let q => weakening {env} {_} {_} {meta-signature.m-domain m ++ global-context} (metavar {env} m (\lam index => var index idp)) ((SubList.extend-right-single SubList.identity)) \in transport (Term env (meta-signature.m-domain m ++ global-context) __ meta-signature) a q
             | inr b => ((inner-results (b.1)).3 b.2)
           }
      \in (unified-metasignature,
           metavar (inl idp) (\lam i => upgrade-metavariables-to-pointed {env} m signature-producer (inner-results i).2),
           unified-substitution,
           {?}) -- provable, technical
    | red, func (inl f) choosing =>
      \let | inner-results (i : F-param-index {_} {env.FunctionalSymbol} (inl f)) => extract-top-level global-context red (SubList.extend-right-single-left sublist) (choosing i)
           | signature-producer i => (inner-results i).1
           | unified-metasignature => ModularMetaSignature {env} signature-producer
           | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam m => ((inner-results (m.1)).3 m.2)
      \in (unified-metasignature,
           func (inl f) (\lam index => upgrade-metavariables {env {tc}} signature-producer (inner-results index).2),
           unified-substitution,
           pmap (func {env {tc}} (inl f)) (ext (\lam i =>
               (inner-results i).4 *>
               inv ((apply-modular-inside {env {tc}} signature-producer (\lam ind => (inner-results ind).3) ((SubList.extend-right-single-left sublist)) (inner-results i).2)))))
    | red, func (inr f-b) choosing =>
      \let | singular-signature =>
        \new MetaSignature Sort' {
          | metaname s' => s = s'
          | m-domain p => context
        }
           | singular-term : Term env context s singular-signature => metavar idp (\lam i => var i idp)
           | singular-metasubstitution : MetaSubstitution env global-context singular-signature meta-signature =>
             \lam m => weakening {env {tc}} (transport (Term env context __ meta-signature) m (func {env {tc}} (inr (f-b : tc.envR.FunctionalSymbol.symbol s)) choosing)) (SubList.extend-right-single SubList.identity)
      \in (singular-signature, singular-term, singular-metasubstitution, pmap (func {env} (inr f-b)) (ext (\lam i => {?}))) -- provable, but technical; not interesting now
    | blue, func f choosing => {?}

  \func funExt {A : \Type} {B : A -> \Type} (f g : \Pi (a : A) -> B a) (h : \Pi (a : A) -> f a = g a) : f = g => ext h

  \func apply-modular-inside {env : Environment} {context subst-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n} (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (t : Term env context s (producer index)) :
    MetaSubstitution.apply (upgrade-metavariables producer t) sublist (\lam m => substitutions m.1 m.2) = MetaSubstitution.apply t sublist (substitutions index) \elim t
    | var index1 p => idp
    | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-right sublist e)) (ext (\lam i => apply-modular-inside producer substitutions sublist (choosing i)))
    | func f choosing => pmap (func f) (ext (\lam i => apply-modular-inside producer substitutions (SubList.extend-right-single-left sublist) (choosing i)))

  \func ModularMetaSignature {env : Environment} {n : Nat} (producer : \Pi (Fin n) -> MetaSignature Sort) : MetaSignature Sort \cowith
    | metaname s => \Sigma (i : Fin n) (metaname {producer i} s)
    | m-domain m => m-domain {(producer (m.1))} m.2

  \func PointedModularMetaSignature {env : Environment} {n : Nat} {pointed-signature : MetaSignature Sort} {s : Sort} (m : pointed-signature.metaname s)
                                    (producer : Fin n -> MetaSignature Sort) : MetaSignature Sort \cowith
    | metaname s' => (s = s') `Or` (\Sigma  (i : Fin n) (metaname {producer i} s'))
    | m-domain {s'} m => \case \elim m \with {
      | inl a => pointed-signature.m-domain m
      | inr b => m-domain {(producer (b.1))} b.2
    }

  \func upgrade-metavariables {env : Environment} {context : List Sort} {s : Sort} {n : Nat} {index : Fin n}
                              (producer : \Pi (Fin n) -> MetaSignature Sort)
                              (A : Term env context s (producer index))
    : Term env context s (ModularMetaSignature producer) \elim A
    | var index p => var index p
    | metavar m choosing => metavar (index, m) (\lam i => upgrade-metavariables producer (choosing i))
    | func f choosing => func f (\lam i => upgrade-metavariables producer (choosing i))

  \func upgrade-metavariables-to-pointed {env : Environment} {context : List Sort} {s s' : Sort} {n : Nat} {index : Fin n} {meta-signature : MetaSignature Sort}
                                         (m' : meta-signature.metaname s')
                                         (producer : \Pi (Fin n) -> MetaSignature Sort)
                                         (A : Term env context s (producer index))
    : Term env context s (PointedModularMetaSignature m' producer) \elim A
    | var index p => var index p
    | metavar m choosing => metavar (inr (index, m)) (\lam i => upgrade-metavariables-to-pointed m' producer (choosing i))
    | func f choosing => func f (\lam i => upgrade-metavariables-to-pointed m' producer (choosing i))

  \func unify-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                  (f : env.FunctionalSymbol.symbol s)
                  (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                  (B : Term env context s meta-signature)
                  (A~>B : TopLevelColoredReduction color (func f choosing-A) B)
                  (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f) ->
                      \Sigma (someColor : Maybe Color)
                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
                             (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
    : \Sigma (X : Term env context s meta-signature)
             (color2 : Maybe Color)
             ((color2 = nothing) `Or` (color2 = just (Color.flip color)))
             (TopLevelColoredReduction color (func f choosing-C) X)
             (BorderedParallelReduction color2 B X) =>
    \let
      | (t, rho, t[rho]=A, root-colors) => decompose-term color SubList.identity (func f choosing-A)
      | (u, lu[rho]=B, t~>u) => decompose-along-reduction color (LinearPattern.convert-to-term {colored-env color} t) B rho (rewrite t[rho]=A A~>B)
      | eqs : LinearMetasignature {colored-env color} t = LinearMetasignature {env} (inject-linear-pattern color t) => {?}
      | eqs2 : (LinearPattern.convert-to-term {env} (inject-linear-pattern color t)) =  (transport (Term env context s) eqs (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} t))) => {?}
      | injected-u : Term env context s (LinearMetasignature {env} (inject-linear-pattern color t)) => rewriteI eqs (inject-monochrome-term color u)
      | modified-rho => transport (MetaSubstitution env context __ meta-signature) eqs rho
      | (sigma, C=t[sigma], reds) => alternate-subst {_} {nil} {context} (func f choosing-A) (func f choosing-C) sublist-trivial SubList.identity idp (inject-linear-pattern {_} color t) modified-rho {?} nothing (parallelization-f choosing-C inner-reductions (cr-skip idp))
      | uni-right => unify-right color (inject-linear-pattern color t) injected-u sigma {?}
      | uni-left => unify-left color injected-u SubList.identity modified-rho sigma reds
    \in metasignature-unificator eqs color B (func f choosing-C)
        (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} t))
      (inject-monochrome-term color u)
      rho
      sigma
      lu[rho]=B
      (rewriteI eqs2 C=t[sigma])
      (rewriteI eqs2 uni-right)
      uni-left.3
    \where {
      \func metasignature-unificator {tc : TheoremContext} {context : List Sort'} {s : Sort'} {left-meta-signature right-meta-signature outer-meta-signature : MetaSignature Sort'}
                                     (meta-signature-equality : left-meta-signature = right-meta-signature)
                                     (color : Color)
                                     (B C : Term env context s outer-meta-signature)
                                     (inj-t inj-u : Term env context s left-meta-signature)
                                     (rho : MetaSubstitution env context left-meta-signature outer-meta-signature)
                                     (sigma : MetaSubstitution env context right-meta-signature outer-meta-signature)
                                     (lu[rho]=b : MetaSubstitution.apply {env} inj-u SubList.identity rho = B)
                                     (C=t[sigma] : C = MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-t) SubList.identity sigma)
                                     (uni-right : TopLevelColoredReduction color
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-t) SubList.identity sigma)
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) SubList.identity sigma))
                                     (uni-left : BorderedParallelReduction nothing
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) SubList.identity (transport (MetaSubstitution env context __ outer-meta-signature) meta-signature-equality rho))
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) SubList.identity sigma))
        : \Sigma (X : Term env context s outer-meta-signature)
                 (color2 : Maybe Color)
                 ((color2 = nothing) `Or` (color2 = just (Color.flip color)))
                 (TopLevelColoredReduction color C X)
                 (BorderedParallelReduction color2 B X) \elim meta-signature-equality
        | idp => (MetaSubstitution.apply {env} inj-u SubList.identity sigma, nothing, {?}, rewrite C=t[sigma] uni-right, rewriteI lu[rho]=b uni-left)

      \func recreate-coloring-for-root {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {color : Color} {f : env.FunctionalSymbol.symbol s}
                                       {choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                                       (h : HasColoredRoot color (func f choosing-A)) : HasColoredRoot color (func f choosing-C) \elim color, f, h
        | red, inl s1, red-func-root => red-func-root
        | blue, inr s1, blue-func-root => blue-func-root
    }

  \data LinearPattern (env : Environment)
                      (context : List Sort)
                      (termSort : Sort)
    | lp-func (f : FunctionalSymbol.symbol termSort)
              (choosing : \Pi (index : Fin (length (domain f))) -> LinearPattern env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index))
    | lp-metavar
    \where {
      \func upgrade-metavariables-p {env : Environment} {context : List Sort} {s : Sort} {n : Nat} {index : Fin n}
                                    (producer : \Pi (Fin n) -> MetaSignature Sort)
                                    (A : Term env context s (producer index))
        : Term env context s (ModularMetaSignature producer) \elim A
        | var index p => var index p
        | metavar m choosing => metavar (index, m) (\lam i => upgrade-metavariables-p producer (choosing i))
        | func f choosing => func f (\lam i => upgrade-metavariables-p producer (choosing i))

      \func convert-to-term {env : Environment} {context : List Sort} {s : Sort} (pattern : LinearPattern env context s) : Term env context s (LinearMetasignature pattern) \elim pattern
        | lp-func f choosing => func f (\lam i => upgrade-metavariables-p (\lam i => LinearMetasignature (choosing i)) (convert-to-term (choosing i)))
        | lp-metavar => metavar idp (\lam index => var index idp)
    }

  \record LinearRewriteRule \extends RewriteRule {
    | linear-pattern : LinearPattern env nil s
    | meta-signature => LinearMetasignature linear-pattern
    | l => LinearPattern.convert-to-term linear-pattern
  }

  \record LinearRewriteStep \extends RewriteStep {
    \override  rule : LinearRewriteRule env {s}
  }

  \func LinearMetasignature {env : Environment} {context : List Sort} {s : Sort} (pattern : LinearPattern env context s) : MetaSignature Sort \elim pattern
    | lp-func f choosing => \new MetaSignature {
      | metaname s => \Sigma (i : Fin (length (domain f))) (metaname {LinearMetasignature (choosing i)} s)
      | m-domain m => m-domain {LinearMetasignature (choosing m.1)} m.2
    }
    | lp-metavar => \new MetaSignature {
      | metaname s' => s = s'
      | m-domain m => context
    }

  \func alternate-subst {tc : TheoremContext} {pattern-context global-context context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (A C : Term env (context) s meta-signature)
                        (pattern-sublist : SubList pattern-context context)
                        (glb-sublist : SubList global-context context)
                        (eq : pattern-context ++ global-context = context)
                        (t : LinearPattern env context s)
                        (rho : MetaSubstitution env global-context (LinearMetasignature {env} t) meta-signature)
                        (A=t[rho] : A = MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-term {env} t) SubList.identity) (glb-sublist) rho)
                        (someColor : Maybe Color)
                        (A=>C : BorderedParallelReduction someColor A C)
    : \Sigma (sigma : MetaSubstitution env global-context (LinearMetasignature {env} t) meta-signature)
             (C = MetaSubstitution.apply {env} (LinearPattern.convert-to-term {env} t) (glb-sublist) sigma)
             (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignature {env} t} s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m))) =>
    {?}
    --  \elim A, C, t, someColor, A=>C
    --    | A, C, lp-var index p, someColor, rd => \case \elim someColor, \elim A, \elim A=t[rho], \elim C, \elim rd \with {
    --      | someColor, A, idp, C, equal-trees idp => (\lam {s1} mvar => contradiction, idp, \lam {s1} m => (nothing, contradiction))
    --      | just color1, A, idp, C, reduction-top-level t => (\lam {s1} mvar => contradiction, \case \elim t \with {
    --        | rewrite-with-rule-colored h1 (((rule : LinearRewriteRule env),m,t,t1)) => \let q => pattern-can't-be-var {env} (rule.l) m ((weakening.recalculate-index (pattern-sublist) index p).1) ((weakening.recalculate-index (pattern-sublist) index p).2) t (rule.l-is-func) \in contradiction
    --      }, \lam {s1} m => contradiction)
    --    }
    --    | A, C, lp-metavar, someColor, rd => \case \elim context, \elim C, \elim pattern-sublist, \elim glb-sublist, \elim eq, \elim A, \elim rd, \elim rho, \elim A=t[rho] \with {
    --      | context, C, pattern-sublist, glb-sublist, idp, A, rd, rho, A=t[rho] =>
    --            \let | context-mapping => (extend-substitution-right {env} glb-sublist
    --                (\lam i => (\let (index', p') => weakening.recalculate-index (pattern-sublist) i idp \in var index' p')))
    --                 | context-mapping-is-identical : context-mapping = plain-identity {env} => ext (identify-context-mapping {env} glb-sublist pattern-sublist)
    --                 | res-term : Term env (pattern-context ++ global-context) s meta-signature => Substitution.apply {env} (rho idp) context-mapping
    --                 | modified-rd : BorderedParallelReduction someColor (rho idp) C => transport (BorderedParallelReduction someColor __ C) (A=t[rho] *> (pmap (Substitution.apply {env} (rho idp)) context-mapping-is-identical) *> plain-identity-effect {env} (rho idp)) rd
    --            \in (\lam {s1} mvar => transport (Term env (pattern-context ++ global-context) __ meta-signature) mvar C,
    --                 inv (plain-identity-effect {env} C) *> (pmap (Substitution.apply {env} C) (inv context-mapping-is-identical)),
    --                 \lam {s1} m => (someColor, Jl (\lam _ s=s' => BorderedParallelReduction someColor (rho s=s') (transport (\lam p0 => Term env (pattern-context ++ global-context) p0 meta-signature) s=s' C)) modified-rd m))
    --    }
    --
--    | A, C, lp-func f choosing, someColor, equal-trees A=C => (rho, inv A=C *> A=t[rho], \lam {s1} m => (nothing, equal-trees idp))
    --    | A, C, lp-func f choosing, just color1, reduction-top-level t => {?} -- here should that passed or be useful; color1 must differ from previous color (that was not changed), but color of f is unique.
    --    | func f-A choosing-A, func f-C choosing-C, lp-func f choosing, nothing, reduction-subterms f-A=f-C inner-reductions =>
    --      \let e : f = f-A => pmap (\lam x => (decomposeTermAsFunctionalSymbol {env} (f-A, choosing-A) x).1) (inv A=t[rho])
    --      \in redirection f-A f-C f choosing-A choosing-C pattern-sublist glb-sublist eq choosing e f-A=f-C rho A=t[rho] inner-reductions
    \where {
      \func pattern-can't-be-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature new-meta-signature : MetaSignature Sort}
                                 (T : Term env nil s meta-signature)
                                 (subst : MetaSubstitution env context meta-signature new-meta-signature)
                                 (someIndex : Fin (length context)) (someProof : s = context !! someIndex)
                                 (eq : MetaSubstitution.apply (weakening T sublist-trivial) SubList.identity subst = var someIndex someProof)
                                 (T-functional : FunctionalRoot T) : Empty \elim T, T-functional
        | func f choosing, T-has-functional-root => contradiction

      \func identify-context-mapping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                     (sublist : SubList right-context (left-context ++ right-context))
                                     (sublist' : SubList left-context (left-context ++ right-context))
                                     (ind : Fin (length (left-context ++ right-context))) :
        (extend-substitution-right {env} {_} {_} {_} {meta-signature} sublist (wide-identity sublist')) ind = var ind idp
      \elim left-context, right-context, ind
        | nil, :: a right-context, zero => {?}
        | nil, :: a right-context, suc ind => {?} -- rewrite (extension-over-identity-is-identity ind) idp
        | :: a left-context, nil, zero => {?}
        | :: a left-context, r, suc ind => {?}
        | :: a left-context, :: a1 right-context, zero => {?}
        \where {
          \func outer-equality-to-identity {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                           (sublist : SubList right-context (left-context ++ right-context))
                                           (sublist' : SubList left-context (left-context ++ right-context)) (i : Fin (length (left-context ++ right-context))) : extend-substitution-right sublist (wide-identity sublist') i = plain-identity {_} {_} {meta-signature} i =>
            {?}

          \func extension-over-identity-is-identity {A : \Type} {some-context : List A} (j : Fin (length some-context)) : extend-substitution-right.produce-inner-term SubList.identity j = (j, idp) \elim some-context, j
            | :: a some-context, zero => idp
            | :: a some-context, suc j => rewrite (extension-over-identity-is-identity j) idp

          \func extension-over-skipping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort} {a : Sort}
                                        (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                        (j : Fin (length (left-context ++ right-context)))
                                        (eq : extend-substitution-right {_} {_} {_} {_} {meta-signature} (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j = var j idp)
            : extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j = var (suc j) idp =>
            \let | rrr => pmap (weakening {_} {_} {_} {a :: (left-context ++ right-context)} __ (sublist-skip SubList.identity)) eq
                 | qqq : rrr @ right = var (suc j) idp => \let internal => recalculate-over-skipping {_} {a} j \in pmap sigma-to-var internal
                 | zzz : rrr @ left = extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j => weakining-extension-comms index-calculator j
            \in inv zzz *> rrr *> qqq

          \func sigma-to-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (sig : \Sigma (i : Fin (length context)) (s = context !! i)) : Term env context s meta-signature =>
            var sig.1 sig.2

          \func recalculate-over-skipping {A : \Set} {point' : A} {a : List A} (ind : Fin (length a)) : weakening.recalculate-index {_} {a} {point' :: a} (sublist-skip SubList.identity) ind idp = (suc ind, idp) \elim a, ind
            | :: a a1, zero => idp
            | :: a a1, suc ind => rewrite (weakening.recalculate-index-over-identity ind) idp

          \func weakining-extension-comms {env : Environment} {left-context right-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort}
                                          (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                          (j : Fin (length (left-context ++ right-context)))
            : weakening {_} {_} {_} {_} {meta-signature}
              (extend-substitution-right (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j)
              (sublist-skip SubList.identity) =
          extend-substitution-right {_} {_} {_} {s :: left-context ++ right-context}
              (sublist-skip (SubList.extend-right-single-left SubList.identity))
              (\lam i => \let (index, p) => index-calculator i \in var (suc index) p)
              j => {?}
        }

      --      \func redirection {tc : TheoremContext} {pattern-context global-context context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
      --                        (f-A f-C f : env.FunctionalSymbol.symbol s)
      --                        (choosing-A : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-A))) ->
      --                            Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
      --                        (choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-C))) ->
      --                            Term env ((f-C FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-C FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
      --                        (pattern-sublist : SubList pattern-context context)
      --                        (glb-sublist : SubList global-context context)
      --                        (eq : pattern-context ++ global-context = context)
      --                        (choosing : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
      --                            LinearPattern env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ pattern-context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
      --                        (f=f-A : f = f-A)
      --                        (f-A=f-C : f-A = f-C)
      --                        (rho : MetaSubstitution env global-context (LinearMetasignature {env} (lp-func f choosing)) meta-signature)
      --                        (global-equality : func {env} f-A choosing-A = func f (\lam i => MetaSubstitution.apply {env} (weakening {env} (LinearPattern.upgrade-metavariables-p {env}
      --                            (\lam i => LinearMetasignature {env} (choosing i)) (LinearPattern.convert-to-term {env} (choosing i)))
      --                            (SubList.extend-left pattern-sublist)) (SubList.extend-right-single-left glb-sublist) rho))
      --                        (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f-A) -> \Sigma (someColor : Maybe Color)
      --                                                                                                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f-A))))
      --                                                                                                             (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-C choosing-C i))) :
      --        \Sigma (sigma : MetaSubstitution env global-context (LinearMetasignature {env} (lp-func f choosing)) meta-signature)
      --               ((func {env} f-C choosing-C) = MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-term {env} (lp-func f choosing)) pattern-sublist) (glb-sublist) sigma)
      --               (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignature {env} (lp-func f choosing)} s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m)))
      --      \elim f-A, f-C, f, choosing-A, choosing-C, choosing, f=f-A, f-A=f-C, rho, inner-reductions
      --        | f-A, f-C, f, choosing-A, choosing-C, choosing, idp, idp, rho, inner-reductions =>
      --          \let | equality-of-choosers => inv (unwrap-func' {env} global-equality)
      --
--               | insides i => alternate-subst
      --                   (choosing-A i)
      --                   (choosing-C i)
      --                   (SubList.extend-left pattern-sublist)
      --                   (SubList.extend-right-single-left glb-sublist)
      --                   (rewrite ++-assoc (pmap ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i) ++ __) eq))
      --                   (choosing i)
      --                   (\lam m => rho (i, m))
      --                   ((pmap (__ i) equality-of-choosers) *> (inv
      --                       (apply-modularity {env}
      --                       (\lam ind => LinearMetasignature {env} (choosing ind))
      --                       (\lam ii m => rho (ii, m))
      --                       (SubList.extend-right-single-left glb-sublist)
      --                       (SubList.extend-left pattern-sublist)
      --                       (LinearPattern.convert-to-term {env} (choosing i)))))
      --                   (inner-reductions i).1
      --                   (inner-reductions i).3
      --          \in (\lam {s1} mvar => (insides mvar.1).1 mvar.2,
      --               pmap (func {env} f-A)
      --                   (ext (\lam index => (insides index).2 *> apply-modularity {env} (\lam ind => LinearMetasignature {env} (choosing ind)) (\lam ind => (insides ind).1) (SubList.extend-right-single-left glb-sublist) (SubList.extend-left pattern-sublist) (LinearPattern.convert-to-term {env} (choosing index)))),
      --               \lam {s1} m => (insides m.1).3 m.2)

      \func unwrap-func {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                        (T : Term env context s meta-signature) : Or Nat
          (\Sigma (f : env.FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
              Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) \elim T
        | var index p => inl 0
        | metavar m choosing1 => inl 0
        | func f1 choosing1 => inr (f1, choosing1)

      \func unwrap-func' {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                         {f'' : env.FunctionalSymbol.symbol s}
                         {choosing choosing' : \Pi (index : Fin (length (env.FunctionalSymbol.domain f''))) ->
                             Term env ((f'' FunctionalSignature.!!param index) ++ context) (f'' FunctionalSignature.!!sort index) meta-signature}
                         (eq : func f'' choosing = func f'' choosing') : choosing' = choosing => sigma-set-equalizer (\lam f => \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) (inv (pmap (decomposeTermAsFunctionalSymbol (f'', choosing)) eq))

      \func sigma-set-equalizer {A : \Set} (B : A -> \Type) {a : A} {b b' : B a} (p : (a,b) = {\Sigma (x : A) (B x)} (a,b')) : b = b'
        => pmap (transport B __ b) (Path.inProp idp (pmap __.1 p)) *> pmapd (\lam t => B t.1) __.2 p

      \func decomposeTermAsFunctionalSymbol {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                                            (default : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
                                                Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) (T : Term env context s meta-signature) : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) \elim T
        | var index p => default
        | metavar m choosing => default
        | func f choosing => (f, choosing)

      \func apply-modularity {env : Environment} {context subst-context pattern-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n}
                             (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (pat-sublist : SubList pattern-context context)
                             (t : Term env pattern-context s (producer index)) :
        MetaSubstitution.apply (weakening t pat-sublist) sublist (substitutions index) = MetaSubstitution.apply (weakening (LinearPattern.upgrade-metavariables-p producer t) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim t
        | var index1 p => idp
        | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-right sublist e)) (ext (\lam i => apply-modularity producer substitutions sublist pat-sublist (choosing i)))
        | func f choosing => pmap (func f) (ext (\lam i => apply-modularity producer substitutions (SubList.extend-right-single-left sublist) (SubList.extend-left pat-sublist) (choosing i)))
    }

  \func unify-right {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                    (t : LinearPattern env context s) (s : Term env context s (LinearMetasignature {env} t))
                    (sigma : MetaSubstitution env context (LinearMetasignature {env} t) meta-signature)
    --                    {rho : MetaSubstitution env context (LinearMetasignature {env} t) meta-signature}
    --                    (h : HasColoredRoot color (MetaSubstitution.apply {env} ((LinearPattern.convert-to-term {env} t)) SubList.identity rho))
                    (t-is-func : FunctionalRoot {env} (LinearPattern.convert-to-term {env} t)) :
    TopLevelColoredReduction {tc} color
        (MetaSubstitution.apply {env} ((LinearPattern.convert-to-term {env} t)) SubList.identity sigma)
        (MetaSubstitution.apply {env} (s) SubList.identity sigma) => {?}
  --    rewrite-with-rule-colored (\case \elim t, \elim sigma, \elim rho, \elim h, \elim t-is-func \with {
  --      | lp-func f choosing, sigma, rho, h, T-has-functional-root => unify-top.recreate-coloring-for-root h
  --    }) (\new LinearRewriteStep {
  --      | rule => \new LinearRewriteRule {
  --        | linear-pattern => t
  --        | r => s
  --        | l-is-func => t-is-func
  --      }
  --      | substitution => sigma
  --      | left-coherence => idp
  --      | right-coherence => idp
  --    })

  \data Closure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | c-trivial (a = b)
    | c-basic (a `R` b)
    | c-connect (c : A) (a `R` c) (Closure R c b)
    \where {
      \func concat {A : \Type} {R : A -> A -> \Type} {a b c : A} (a~>b : Closure R a b) (b~>c : Closure R b c) : Closure R a c \elim a~>b, b~>c
        | c-basic r, rx => c-connect b r rx
        | c-connect c1 r a~>b, rx => c-connect c1 r (concat a~>b rx)
        | c-trivial idp, b~>c => b~>c

      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : Closure Rel x y) : Closure Rel' (map x) (map y) \elim closure
        | c-basic r => c-basic (rel-map r)
        | c-connect c r closure => c-connect (map c) (rel-map r) (lift map rel-map c y closure)
        | c-trivial idp => c-trivial idp

      \func flatten {A : \Type} {Rel : A -> A -> \Type}
                    {x y : A}
                    (closure : Closure (Closure Rel) x y) : Closure Rel x y \elim closure
        | c-basic r => r
        | c-connect c r closure => concat r (flatten closure)
        | c-trivial idp => c-trivial idp
    }

  \func unify-left {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature inner-metasignature : MetaSignature Sort'}
                   (anti-color : Color)
                   (s : Term env context' s inner-metasignature)
                   (sublist : SubList context context')
                   (rho sigma : MetaSubstitution env context inner-metasignature meta-signature)
                   (rho~>sigma : \Pi {s : Sort'} (m : inner-metasignature.metaname s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m))) :
    \Sigma (color : Maybe Color)
           ((color = nothing) `Or` (color = just (Color.flip anti-color)))
           (BorderedParallelReduction nothing (MetaSubstitution.apply {env} s sublist rho) (MetaSubstitution.apply {env} s sublist sigma))
  \elim s
    | var index p => {?}
    | metavar m choosing =>
      \let | main-reduction => rho~>sigma m
           | partial-reductions i => unify-left anti-color (choosing i) sublist rho sigma rho~>sigma
           | eq : main-reduction.1 = nothing => {?}
           | rho-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho))
           | sigma-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma))
           | in-indices i => unify-left anti-color (choosing i) sublist rho sigma rho~>sigma
           | target-reduction => reduction-over-substitution (rho m) (sigma m) main-reduction.1 main-reduction.2 rho-subst sigma-subst {?}
      \in {?}
    | func f choosing => {?}
  --      \let | q i => unify-left (choosing i) (SubList.extend-right-single-left sublist) rho sigma rho~>sigma
  --                         \in gather-closure f (\lam i => MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single-left sublist) rho) (\lam i => MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single-left sublist) sigma) q

  \func reduction-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                    (A B : Term env context s meta-signature)
                                    (color : Maybe Color)
                                    (A=>B : BorderedParallelReduction color A B)
                                    (subst subst' : Substitution {env} context new-context meta-signature)
                                    (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction someColor (subst i) (subst' i)))
    : BorderedParallelReduction color (Substitution.apply {env} A subst) (Substitution.apply {env} B subst') \elim A, A=>B
    | A, equal-trees p => {?}
    | func f choosing, parallelization-f mediator _x c =>
      \let | x => 1
        | medium-reductions i => reduction-over-substitution (choosing i) (mediator i) (_x i).1 (_x i).3 (append-context-left {env} subst) (append-context-left {env} subst') {?}
      \in parallelization-f (\lam i => Substitution.apply {env} (mediator i) (append-context-left {env} subst')) (\lam i => ((_x i).1, (_x i).2, medium-reductions i)) {?}

  \func reduction-over-extension {tc : TheoremContext} {basic-context extended-context additional-context : List Sort'} {meta-signature : MetaSignature Sort'}
                                 (substA substB : Substitution {env} basic-context extended-context meta-signature)
                                 (sublist : SubList additional-context extended-context)
                                 (A=>B : \Pi (i : Fin (length basic-context)) -> Closure TrichromaticParallelReduction (substA i) (substB i))
                                 (j : Fin (length (basic-context ++ additional-context))) : Closure TrichromaticParallelReduction (extend-substitution-right {env} sublist substA j) (extend-substitution-right {env} sublist substB j) \elim basic-context, j
    | nil, j => c-basic (nothing, equal-trees idp)
    | :: a basic-context, zero => A=>B zero
    | :: a basic-context, suc j => reduction-over-extension (\lam i => substA (suc i)) (\lam i => substB (suc i)) sublist (\lam i => A=>B (suc i)) j

  \func apply-reducible-substitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                     (s : Term env context s meta-signature)
                                     (a-subst b-subst : Substitution {env} context context' meta-signature)
                                     (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
    : Closure TrichromaticParallelReduction (Substitution.apply {env} s a-subst) (Substitution.apply {env} s b-subst)
  \elim s
    | var index p => \case \elim s, \elim p \with {
      | s, idp => a~>b index
    }
    | metavar m choosing => {?} -- like the bottom one
    | func f choosing =>
      \let | choosing-a i => (Substitution.apply {env} (choosing i) (append-context-left {env} a-subst))
           | choosing-b i => (Substitution.apply {env} (choosing i) (append-context-left {env} b-subst))
           | q i => apply-reducible-substitution (choosing i) (append-context-left {env} a-subst) (append-context-left {env} b-subst) (reduction-over-left-append a-subst b-subst a~>b)
      \in gather-closure f choosing-a choosing-b q

  \func reduction-over-left-append {tc : TheoremContext} {context add-context context' : List Sort'} {meta-signature : MetaSignature Sort'}
                                   (a-subst b-subst : Substitution {env} context context' meta-signature)
                                   (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
                                   (i : Fin (length (add-context ++ context))) : Closure TrichromaticParallelReduction (append-context-left {env} a-subst i) (append-context-left {env} b-subst i) \elim add-context, i
    | nil, i => a~>b i
    | :: a add-context, zero => c-basic (nothing, equal-trees idp)
    | :: a add-context, suc i => \let x => reduction-over-left-append a-subst b-subst a~>b i \in reduction-over-weakening (append-context-left {env} a-subst i) (append-context-left {env} b-subst i) x (sublist-skip SubList.identity)

  \func reduction-over-weakening {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (T S : Term env context s meta-signature)
                                 (T~>S : Closure TrichromaticParallelReduction T S)
                                 (sublist : SubList context new-context)
                                 : Closure TrichromaticParallelReduction (weakening {env} T sublist) (weakening {env} S sublist) => {?}

  \func extend-reduction-to-substitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                         (t s' : Term env context s meta-signature)
                                         (subst : Substitution {env} context context' meta-signature)
                                         (someColor : Maybe Color)
                                         (t~>s : BorderedParallelReduction someColor t s')
    : BorderedParallelReduction someColor (Substitution.apply {env} t subst) (Substitution.apply {env} s' subst) \elim t, s', someColor, t~>s
    | t, s', someColor, equal-trees p => equal-trees (pmap (Substitution.apply {env} __ subst) p)
    | t, s', just color, reduction-top-level tlcr => reduction-top-level (lemma-tlcr t s' subst color tlcr)
    | func f-A choosing-A, func f-B choosing-B, nothing, reduction-subterms f-A=f-B _x => redirection f-A f-B choosing-A choosing-B f-A=f-B _x subst
    \where {
      \func redirection {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (f-A f-C : env.FunctionalSymbol.symbol s)
                        (choosing-A : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-A))) -> Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                        (choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-C))) -> Term env ((f-C FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-C FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                        (f-A=f-C : f-A = f-C)
                        (inner-reductions : \Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f-A) -> \Sigma
                          (someColor : Maybe Color)
                          ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f-A))))
                          (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-C choosing-C i)))
                        (subst : Substitution {env} context context' meta-signature)
        : BorderedParallelReduction nothing (Substitution.apply {env} (func f-A choosing-A) subst) (Substitution.apply {env} (func f-C choosing-C) subst) \elim f-A=f-C
        | idp => reduction-subterms idp (\lam i => \let (col, or, reduct) => inner-reductions i \in
          (col, or, extend-reduction-to-substitution (choosing-A i) (choosing-C i) ((append-context-left {env} subst)) col reduct))

      \func lemma-tlcr {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                       (t s' : Term env context s meta-signature)
                       (subst : Substitution {env} context context' meta-signature)
                       (color : Color)
                       (t~>s : TopLevelColoredReduction color t s') : TopLevelColoredReduction color (Substitution.apply {env} t subst) (Substitution.apply {env} s' subst) \elim t, s', t~>s
        | t, s', rewrite-with-rule-colored h (rule,metasubst,m[l]=t,m[r]=s') => rewrite-with-rule-colored {?} (\new LinearRewriteStep {
          | rule => rule
          | substitution m => Substitution.apply {env} (metasubst m) (append-context-left {env} subst)
          | left-coherence => {?}
          | right-coherence => {?}
        })
        | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => {?}

      \func prove-coherence {env : Environment} {context context' pattern-context : List Sort} {s : Sort} {inner-meta-signature meta-signature : MetaSignature Sort}
                            (t : Term env pattern-context s inner-meta-signature)
                            (sublist : SubList pattern-context context)
                            (sublist' : SubList pattern-context context')
                            (subst : Substitution {env} context context' meta-signature)
                            (metasubst : MetaSubstitution env context inner-meta-signature meta-signature)
        : MetaSubstitution.apply (weakening t sublist') SubList.identity (\lam m => Substitution.apply (metasubst m) (append-context-left subst)) = Substitution.apply (MetaSubstitution.apply (weakening t sublist) SubList.identity metasubst) subst \elim t
        | metavar m choosing => \let | initial-term : Term env (inner-meta-signature.m-domain m ++ context) s meta-signature => (metasubst m)
                                     | left-inner-subst : Substitution (inner-meta-signature.m-domain m ++ context) (inner-meta-signature.m-domain m ++ context') meta-signature => (append-context-left subst)

                                     | left-outer-subst : Substitution (inner-meta-signature.m-domain m ++ context') context' meta-signature
                                     => (extend-substitution-right
                                         SubList.identity (\lam i => MetaSubstitution.apply (weakening (choosing i) sublist') SubList.identity
                                             (\lam {s} m => Substitution.apply (metasubst m) (append-context-left subst))))

                                     | right-inner-subst : Substitution (inner-meta-signature.m-domain m ++ context) context meta-signature
                                     => (extend-substitution-right SubList.identity
                                         (\lam i => MetaSubstitution.apply (weakening (choosing i) sublist) SubList.identity metasubst))

                                     | right-outer-subst : Substitution context context' meta-signature => subst
                                     | internal-subst : Substitution (inner-meta-signature.m-domain m) context meta-signature => \lam i => MetaSubstitution.apply (weakening (choosing i) sublist) SubList.identity metasubst

                                     | substituted-metavar => (Substitution.apply (metasubst m) (append-context-left subst))

                                     | applied-to-metavar => (extend-substitution-right
                                         SubList.identity (\lam i => MetaSubstitution.apply (weakening (choosing i) sublist') SubList.identity
                                             (\lam {s} m => Substitution.apply (metasubst m) (append-context-left subst))))
                                     | expanded-A => (Substitution.apply (metasubst m) (extend-substitution-right SubList.identity
                                         (\lam i => MetaSubstitution.apply (weakening (choosing i) sublist) SubList.identity metasubst)))
                                     | result : Substitution.apply substituted-metavar applied-to-metavar = Substitution.apply expanded-A subst => {?} \in result
        | var index p => {?}
        | func f choosing => pmap (func f) (ext (\lam index => \let q => prove-coherence (choosing index) {?} {?} {?} metasubst \in {?}))

      \func rhombic-coherence {env : Environment} {old-left-context old-right-context new-right-context : List Sort} {s : Sort} {old-meta-signature new-meta-signature : MetaSignature Sort}
                              (sublist' : SubList old-left-context new-right-context)
                              (sublist : SubList old-left-context old-right-context)
                              (T : Term env (old-left-context ++ old-right-context) s new-meta-signature)
                              (args : Substitution old-left-context old-left-context old-meta-signature)
                              (subst : Substitution old-right-context new-right-context new-meta-signature)
                              (meta-subst : MetaSubstitution env old-right-context old-meta-signature new-meta-signature)
        : Substitution.apply (Substitution.apply T (append-context-left subst)) (extend-substitution-right SubList.identity (\lam i => MetaSubstitution.apply (weakening (args i) sublist') SubList.identity (\lam m => Substitution.apply (meta-subst m) (append-context-left subst)))) =
      Substitution.apply (Substitution.apply T (extend-substitution-right SubList.identity (\lam i => MetaSubstitution.apply (weakening (args i) sublist) SubList.identity meta-subst))) subst \elim T
        | var index p => \case \elim s, \elim p \with {
          | s, idp => {?}
        }
        | metavar m choosing => pmap (metavar m) (ext (\lam index => {?}))
        | func f choosing => pmap (func f) (ext (\lam index =>
            \let | chosen => rewriteI (++-assoc) (choosing index)
                 | inner-rhombic => rhombic-coherence {?} {?} chosen {?} {?} {?} \in {?}))
    }

  \func gather-closure {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                       (f : env.FunctionalSymbol.symbol s)
                       (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                       (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure TrichromaticParallelReduction (choosing-A index) (choosing-B index))
    : Closure TrichromaticParallelReduction (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- purely technical concatenation of closures

  \func gather-closure-regular {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                               (f : env.FunctionalSymbol.symbol s)
                               (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                               (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (choosing-A index) (choosing-B index))
    : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- similar to above, don't want to think about it rn

}
