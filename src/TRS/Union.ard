\import Confluence
\import Data.Bool
\import Data.List (++, List, nil)
\import Data.Or
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import TRS.HRS
\import TRS.List
\import TRS.Maybe
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort} {meta-signature : MetaSignature Sort}
                         (term : Term envL c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-pattern-term-left {Sort : \Set}
                                 (envL envR : Environment Sort)
                                 {s : Sort}
                                 {c : List Sort}
                                 {meta-signature : MetaSignature Sort}
                                 (term : PatternTerm envL c s meta-signature) : PatternTerm (JointEnvironment envL envR) c s meta-signature \elim term
    | pattern-var index p => pattern-var index p
    | pattern-metavar m arguments coherence => pattern-metavar m arguments coherence
    | pattern-func f choosing => pattern-func (inl f) (\lam i => inject-pattern-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          {meta-signature : MetaSignature Sort}
                          (term : Term envR c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func inject-pattern-term-right {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  {s : Sort}
                                  {c : List Sort}
                                  {meta-signature : MetaSignature Sort}
                                  (term : PatternTerm envR c s meta-signature) : PatternTerm (JointEnvironment envL envR) c s meta-signature \elim term
    | pattern-var index p => pattern-var index p
    | pattern-metavar m arguments coherence => pattern-metavar m arguments coherence
    | pattern-func f choosing => pattern-func (inr f) (\lam i => inject-pattern-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-pattern-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-pattern-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

--\instance JointHRS {Sort : \Set} {envL envR : Environment Sort}
--                   (L : SimpleHigherOrderTermRewritingSystem envL)
--                   (R : SimpleHigherOrderTermRewritingSystem envR)
-- SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
--  | set-of-rules =>
--    \let
--      | injected-left-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-left {_} {envL} {envR} L.set-of-rules
--      | injected-right-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-right {_} {envL} {envR} R.set-of-rules
--    \in JointIndexedSet injected-left-set injected-right-set
--
--\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort}
--                                  (L : SimpleHigherOrderTermRewritingSystem envL)
--                                  (R : SimpleHigherOrderTermRewritingSystem envR)
--                                  (L-confluence : isConfluent L)
--                                  (R-confluence : isConfluent R)
--  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}
--
\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort} {meta-signature : MetaSignature Sort}
                                         {context : List Sort} (A B : Term env context s meta-signature) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {context} {s}) A B

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : Environment Sort'
    | envR : Environment Sort'
    | L-rules : IndexedSet (RewriteRule envL)
    | R-rules : IndexedSet (RewriteRule envR)
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (RewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term (colored-env {tc} color) context s meta-signature): \Prop
    \elim color
      | red => RewriteRelation {envL} L-rules A B
      | blue => RewriteRelation {envR} R-rules A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (t : Term (colored-env color) context s meta-signature) : Term env context s meta-signature \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (term : Term env context s meta-signature) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      | _, metavar _ _ => uncolored-metavar-root
      | _, var _ _ => uncolored-var-root

    \func color-of-root {_ : TheoremContext} {s : Sort'} (f : env.FunctionalSymbol.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR

    \func colored-rules {tc : TheoremContext} (color : Color) : IndexedSet (RewriteRule (env {tc})) \elim color
      | red => Injections.promote-indexed-set-left {tc.Sort'} {tc.envL} {tc.envR} (L-rules)
      | blue => Injections.promote-indexed-set-right {tc.Sort'} {tc.envL} {tc.envR} (R-rules)
  }

  \open TheoremContext

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} (A B : Term env context s meta-signature) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot {tc} color A) (step : RewriteStep {env {tc}} A B) (step.rule IndexedSet.in (colored-rules color))
    | func (f-A : symbol {FunctionalSymbol {env {tc}}} s) choosing-A, func (f-B : symbol {FunctionalSymbol {env {tc}}} s) choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root {tc} f-A = color)
                                     (ReductionAtIndex {env {tc}}
                                         (TopLevelColoredReduction {tc} color {meta-signature})
                                         (\lam i => (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i ++ {Sort {env {tc}}} context))
                                         (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} __)
                                         choosing-A
                                         (transport-chooser-f {env {tc}} p choosing-B))

  \data BorderedParallelReduction {tc : TheoremContext} (color : Maybe Color) {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
                                  (A B : Term (env {tc}) context s meta-signature) \elim color, A, B
    | _, A, B => equal-trees (A = B)
    | just color, A, B => reduction-top-level (HasColoredRoot {tc} color A) (HasColoredRoot {tc} color B) (TopLevelColoredReduction {tc} color A B)
    | nothing, func f-A choosing-A, func f-B choosing-B =>
    reduction-subterms (f-A=f-B : f-A = f-B)
                       (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f-A) -> \Sigma
                         (someColor : Maybe Color)
                         ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f-A))))
                         (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-B choosing-B i)))

  \func TrichromaticParallelReduction {tc : TheoremContext} {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term env context s meta-signature) : \Type =>
    \Sigma (color : Maybe Color) (BorderedParallelReduction color A B)

  \func bpr-confluence {tc : TheoremContext} (color1 color2 : Maybe Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (A B C : Term env context s meta-signature)
                       (A~>B : BorderedParallelReduction color1 A B)
                       (A~>C : BorderedParallelReduction color2 A C)
    : StraightJoin B C (TrichromaticParallelReduction) \elim color1, color2, A, B, C, A~>B, A~>C
    | _, _, A, B, C, equal-trees p, equal-trees p1 => {?} -- easy
    | color, just color1, A, B, B1, equal-trees p, reduction-top-level h h1 A~>B1 => {?} -- easy
    | color, nothing, func f-A choosing-A, B, func f-B choosing-B, equal-trees p, reduction-subterms f-A=f-B _x => {?} -- easy
    | just color, color1, A, B, B1, reduction-top-level h h1 A~>B, equal-trees p => {?} -- easy
    | just color, just color1, A, B, B1, reduction-top-level h h1 A~>B, reduction-top-level h2 h3 A~>B1 => {?} -- ?
    | just color, nothing, func f-A choosing-A, B, func f-C choosing-C, reduction-top-level A-colored B-colored A~>B, reduction-subterms f-A=f-C inner-reduction => {?}
    | nothing, color, func f-A choosing-A, func f-B choosing-B, B, reduction-subterms f-A=f-B red-subterms, equal-trees p => {?} -- easy
    | nothing, just color, func f-A choosing-A, func f-B choosing-B, B, reduction-subterms f-A=f-B _x, reduction-top-level h h1 A~>B' => {?} -- symmetric to 3
    | nothing, nothing, func f-A choosing-A, func f-B choosing-B, func f-B1 choosing-B1, reduction-subterms f-A=f-B _x, reduction-subterms f-A=f-B1 _x1 => {?} -- inductive step, relatively easy

  \func extract-top-level {tc : TheoremContext} (global-context : List tc.Sort') {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                          (color : Color)
                          (sublist : SubList global-context context)
                          (A : Term env context s meta-signature) : \Sigma (internal-ms : MetaSignature Sort')
                                                                           (t : Term env context s internal-ms)
                                                                           (subst : MetaSubstitution env global-context internal-ms meta-signature)
                                                                           (A = MetaSubstitution.apply {env} t sublist subst)
  \elim color, A
    | _, var index p => {?}
    | _, metavar m choosing => {?}
    | red, func (inl f) choosing => \let | inner-results (i : F-param-index {_} {env.FunctionalSymbol} (inl f)) => extract-top-level global-context red (SubList.extend-right-single-left sublist) (choosing i)
                                         | unified-metasignature => \new MetaSignature Sort' { | metaname s => \Sigma (i : F-param-index {_} {env.FunctionalSymbol} (inl f)) (metaname {(inner-results i).1} s)
                                                                                               | m-domain m => m-domain {(inner-results (m.1)).1} m.2
                                         }
                                         | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam m => ((inner-results (m.1)).3 m.2)
                                         | k (ind : F-param-index {_} {env.FunctionalSymbol} (inl f)) => \let | q => (inner-results ind).2
                                                                                                         \in {?}
                                    \in (unified-metasignature,
                                         func (inl f) (\lam index => upgrade-metavariables {env {tc}} ((inner-results index).2) (\lam {s1} m => ((index, m), idp))),
                                         unified-substitution,
                                         pmap (func {env {tc}} (inl f)) (\let | lf => choosing
                                                                              | rf => (\lam i => MetaSubstitution.apply {env}
                                                                                  (upgrade-metavariables {env} {_} {_} {_} {unified-metasignature} (inner-results i).2 (\lam {s1} m => ((i, m), idp))) (SubList.extend-right-single-left sublist)
                                                                                  unified-substitution)
                                                                         \in funExt {_} {\lam (index : Fin (length (domain {env.FunctionalSymbol} (inl f)))) =>
                                                                                             Term env (inl f FunctionalSignature.!!param {_} {env.FunctionalSymbol} index ++ context) (inl f FunctionalSignature.!!sort {_} {env.FunctionalSymbol} index) meta-signature} lf rf (\lam i =>
                                               \let | lfi => lf i
                                                    | rfi => rf i
                                                    | tfi => (inner-results i).4 @ right
                                                    | eq2 => (inner-results i).4
--                                                    | eqq : unified-substitution = (inner-results i).3 => idp
                                                    | q : rf i = tfi => unfold (rf, tfi) {?}
                                               \in {?})))
    | red, func (inr b) choosing => {?}
    | blue, func f choosing => {?}

  \func funExt {A : \Type} {B : A -> \Type} (f g : \Pi (a : A) -> B a) (h : \Pi (a : A) -> f a = g a) : f = g => ext h

  \func upgrade-metavariables {env : Environment} {context : List Sort} {s : Sort} {meta-signature new-meta-signature : MetaSignature Sort} (A : Term env context s meta-signature)
                              (expansion : \Pi {s : Sort} (m : meta-signature.metaname s) -> \Sigma (m' : new-meta-signature.metaname s) (meta-signature.m-domain m = new-meta-signature.m-domain m'))
    : Term env context s new-meta-signature \elim A
    | var index p => var index p
    | metavar m choosing => metavar (expansion m).1 (\lam i => upgrade-metavariables (transport (\lam list => \Pi (index : Fin (length list)) -> Term env context (list !! index) meta-signature) (expansion m).2 (choosing) i) expansion)
    | func f choosing => func f (\lam i => upgrade-metavariables (choosing i) expansion)

  --  \func apply-inner-reduction-after-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color) (f-A : env.FunctionalSymbol.symbol s)
  --                                        (B : Term env context s)
  --                                        (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-A))) -> Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
  --                                        (A~>B : TopLevelColoredReduction color (func f-A choosing-A) B)
  --                                        (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f-A) -> \Sigma (someColor : Maybe Color)
  --                                                                                                                             ((someColor = nothing) `Or` (someColor = just (Color.flip color)))
  --                                                                                                                             (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
  --    : Term env context s \elim B, A~>B
  --    | B, rewrite-with-rule-colored A-colored ((l, r, ring), subst, lc, rc) in-rules => {?}
  --    | func f-B choosing-B, rewrite-with-parameter-f-colored f-A=f-B _ (reduce-at-some-index red-ind rel rest) => func f-A (\lam ind => \case (FinDec red-ind ind) \with {
  --      | yes e => intermediate-reduction color f-A f-B f-A=f-B choosing-A choosing-C choosing-B ind red-ind (inv e) inner-reductions rel
  --      | no n => choosing-C ind
  --    })
  --    \where {
  --      \func replace-matavars-in-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (mcolor : Maybe Color) (l : PatternTerm env context s)
  --                                        (subst : MetaSubstitution env context)
  --                                        (A C : Term env context s)
  --                                        (lc : MetaSubstitution.apply {env} (PatternTerm.convertToTerm {env} l) SubList.identity subst = A) (A~>C : BorderedParallelReduction {tc} mcolor A C) : MetaSubstitution env context \elim mcolor, l, A, C, lc, A~>C
  --        | color, pattern-var index p, A, C, idp, equal-trees p1 => MetaSubstitution.identity {env} context
  --        | color, pattern-metavar m arguments arguments-coherence, A, C, sl=A, equal-trees p => \lam m' => \case (MetaSubstitution.decide-mvar {env} m m') \with {
  --          | yes e => subst m'
  --          | no n => MetaSubstitution.empty-metavar {env} m' context
  --        }
  --        | color, pattern-func f choosing, A, C, sl=A, equal-trees p => {?}
  --        | just color, pattern-var index p, A, C, idp, reduction-top-level h h1 t => {?}
  --        | just color, pattern-metavar m arguments arguments-coherence, A, C, idp, reduction-top-level h h1 t => {?}
  --        | just color, pattern-func f choosing, A, C, idp, reduction-top-level h h1 t => {?}
  --        | nothing, pattern-metavar m arguments arguments-coherence, func f-A choosing-A, func f-C choosing-C, lc, reduction-subterms f-A=f-B _x => {?}
  --        | nothing, pattern-func f choosing, func f-A choosing-A, func f-C choosing-C, lc, reduction-subterms f-A=f-B _x => {?}
  --
--      \func intermediate-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
  --                                   (f-A f-B : env.FunctionalSymbol.symbol s) (p : f-A = f-B)
  --                                   (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-A))) -> Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
  --                                   (choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-B))) -> Term env ((f-B FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-B FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
  --                                   (ind red-ind : F-param-index {_} {env.FunctionalSymbol} f-A)
  --                                   (e : ind = red-ind)
  --                                   (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f-A) -> \Sigma (someColor : Maybe Color)
  --                                                                                                                        ((someColor = nothing) `Or` (someColor = just (Color.flip color)))
  --                                                                                                                        (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
  --                                   (tlrc : TopLevelColoredReduction color (choosing-A red-ind) (transport-chooser-f {env} p choosing-B red-ind))
  --        : Term env (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} ind ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} ind)
  --      \elim p, e
  --        | idp, idp => \let (new-color, neq, border) => inner-reductions ind \in convert-reduction-at-index-to-chooser color f-A ind new-color (choosing-A ind) (choosing-B ind) (choosing-C ind) tlrc neq border
  --
--      \func convert-reduction-at-index-to-chooser {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color) (f-A : env.FunctionalSymbol.symbol s)
  --                                                  (i : F-param-index {_} {env.FunctionalSymbol} f-A)
  --                                                  (someColor : Maybe Color)
  --                                                  (A' B' C' : Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} i))
  --                                                  (A'~>B' : TopLevelColoredReduction color A' B')
  --                                                  (other : Or (someColor = nothing) (someColor = just (Color.flip color)))
  --                                                  (border : BorderedParallelReduction someColor A' C')
  --        : Term env (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} i) \elim someColor, A', C', border
  --        | _, A, C, equal-trees eq => B'
  --        | just a, Ain, Cin, reduction-top-level a-colored c-colored tlcr => \let e => (extract-root-coloring color (Ain) B' A'~>B') \in {?} -- just show that color of root is unique, technical
  --        | nothing, func f-A' ch-A', func f-C' ch-C', reduction-subterms f-A'=f-C' inner-bpr =>
  --          \case \elim f-A', \elim color, \elim ch-A', \elim ch-C', \elim f-A'=f-C', \elim A'~>B', \elim inner-bpr \with {
  --            | inl f-A', red, ch-A', ch-C', f-A'=f-C', rr, inner-bpr => apply-inner-reduction-after-top red (inl f-A') B' ch-A' (transport-chooser-f {env} f-A'=f-C' ch-C') rr inner-bpr
  --            | inl f-A', blue, ch-A', ch-C', f-A'=f-C', rr, inner-bpr => \case (extract-root-coloring blue (func (inl f-A') ch-A') B' rr) \with {
  --            }
  --            | inr f-A', red, ch-A', ch-C', f-A'=f-C', rr, inner-bpr => \case (extract-root-coloring red (func (inr f-A') ch-A') B' rr) \with {
  --            }
  --            | inr f-A', blue, ch-A', ch-C', f-A'=f-C', rr, inner-bpr => apply-inner-reduction-after-top blue (inr f-A') B' ch-A' (transport-chooser-f {env} f-A'=f-C' ch-C') rr inner-bpr
  --          }
  --
--      \func extract-root-coloring {tc : TheoremContext} (color : Color) {context : List env.Sort} {s : env.Sort} (A B : Term env context s) (A~>B : TopLevelColoredReduction color A B) : HasColoredRoot {tc} color A \elim A, B, A~>B
  --        | A, B, rewrite-with-rule-colored h step i => h
  --        | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => \case \elim f-A, \elim choosing-A, \elim color, \elim p1 \with {
  --          | inl a, choosing-A, red, p1 => red-func-root
  --          | inr b, choosing-A, blue, p1 => blue-func-root
  --        }
  --    }
}



