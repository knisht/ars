\import Algebra.Ring.Localization
\import Confluence
\import Data.Bool
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.Union.TopLevel
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort} {meta-signature : MetaSignature Sort}
                         (term : Term envL c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          {meta-signature : MetaSignature Sort}
                          (term : Term envR c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | l-is-func => promote-injection-left {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-left {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envL context s meta-signature)
                                   (t-is-func : FunctionalRoot {envL} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-left envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | l-is-func => promote-injection-right {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-right {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envR context s meta-signature)
                                   (t-is-func : FunctionalRoot {envR} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-right envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\func JointRules {Sort : \Set} {envL envR : Environment Sort}
                 (L-rules : IndexedSet (RewriteRule envL))
                 (R-rules : IndexedSet (RewriteRule envR))
  : IndexedSet (RewriteRule (JointEnvironment envL envR)) =>
  \let
    | injected-left-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-left {_} {envL} {envR} L-rules
    | injected-right-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-right {_} {envL} {envR} R-rules
  \in JointIndexedSet injected-left-set injected-right-set

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                   (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
: SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules => JointRules {_} {envL} {envR} L.set-of-rules R.set-of-rules
  | meta-signature => meta-signature

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                                  (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red

    \func double-flip (c : Color) : Color.flip (Color.flip c) = c \elim c
      | red => idp
      | blue => idp

    \func flip-contradiction {c : Color} (eq : c = flip c) : Empty \elim c
      | red => contradiction
      | blue => contradiction
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : Environment Sort'
    | envR : Environment Sort'
    | L-rules : IndexedSet (LinearRewriteRule envL)
    | R-rules : IndexedSet (LinearRewriteRule envR)
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (LinearRewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term (colored-env {tc} color) context s meta-signature): \Type => RewriteRelation {colored-env color} (colored-set-of-rules color) A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (t : Term (colored-env color) context s meta-signature) : Term env context s meta-signature \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t
      \where {
        \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {msig : MetaSignature Sort'} (t : Term env context s msig) \elim t
          | func f choosing => iw-func (color-of-root {tc} f = color)
                                       (\Pi (i : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> InjectionWitness {tc} color (choosing i))
          | metavar m choosing => iw-mvar (\Pi (i : Fin (length (msig.m-domain m))) -> InjectionWitness {tc} color (choosing i))
          | var _ _ => iw-var
      }

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (term : Term env context s meta-signature) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      \where {
        \func equalize-colors {tc : TheoremContext} (color color' : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                              (f : env.FunctionalSymbol.symbol s)
                              (choosing choosing' : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                              (hcl1 : HasColoredRoot color (func f choosing))
                              (hcl2 : HasColoredRoot color' (func f choosing'))
                              : color = color' \elim color, color', f, hcl1, hcl2
          | red, red, inl s1, red-func-root, red-func-root => idp
          | blue, blue, inr s1, blue-func-root, blue-func-root => idp
          | red, blue, inr b, (), hcl2
          | blue, red, inl a, (), hcl2

        \func reorganize {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                         {f : env.FunctionalSymbol.symbol s}
                         {choosing : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                         (hcl : HasColoredRoot color (func f choosing))
                         : color-of-root f = color \elim color, f, hcl
          | red, inl s1, red-func-root => idp
          | blue, inr s1, blue-func-root => idp
      }
--      | _, metavar _ _ => uncolored-metavar-root

    \data HasMetaRoot {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (term : Term env context s meta-signature) \elim term
      | metavar _ _ => has-meta-root

    \func color-of-root {_ : TheoremContext} {s : Sort'} (f : env.FunctionalSymbol.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR

    \func colored-rules {tc : TheoremContext} (color : Color) : IndexedSet (RewriteRule (env {tc})) \elim color
      | red => Injections.promote-indexed-set-left {tc.Sort'} {tc.envL} {tc.envR} (L-rules)
      | blue => Injections.promote-indexed-set-right {tc.Sort'} {tc.envL} {tc.envR} (R-rules)
  }

  \open TheoremContext

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} (A B : Term env context s meta-signature) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot {tc} color A) (step : LinearRewriteStep {env {tc}} A B) --(step.rule IndexedSet.in {LinearRewriteRule step.env} (colored-rules coor)) todo
    | func (f-A : symbol {FunctionalSymbol {env {tc}}} s) choosing-A, func (f-B : symbol {FunctionalSymbol {env {tc}}} s) choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root {tc} f-A = color)
                                     (ReductionAtIndex {env {tc}}
                                         (TopLevelColoredReduction {tc} color {meta-signature})
                                         (\lam i => (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i ++ {Sort {env {tc}}} context))
                                         (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} __)
                                         choosing-A
                                         (transport-chooser-f {env {tc}} p choosing-B))
    \where {
      \func extract-root-coloring {tc : TheoremContext} {color : Color} {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} {A B : Term env context s meta-signature} (tlcr : TopLevelColoredReduction color A B) : HasColoredRoot color A
        \elim color, A, B, tlcr
        | color, A, B, rewrite-with-rule-colored h _ => h
        | color, func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => \case \elim color, \elim f-A, \elim choosing-A, \elim p1 \with {
          | red, inl a, choosing-A, p1 => red-func-root
          | blue, inr b, choosing-A, p1 => blue-func-root
        }
    }

  \data BorderedParallelReduction {tc : TheoremContext}
                                  (global-color : Color)
                                  (color : Maybe Color)
                                  {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
                                  (A B : Term (env {tc}) context s meta-signature) \elim A
    | A => equal-trees (A = B)
    | func f choosing =>
    parallelization-f
      (mediator : \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) ->
          Term (env {tc}) ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
      (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f) -> \Sigma
        (someColor : Maybe Color)
        ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f))))
        (BorderedParallelReduction {tc} global-color someColor (choosing i) (mediator i)))
      (ColorwiseReduction {tc} global-color color (func f mediator) B)
    \where {
      \func append-tlcr
        {tc : TheoremContext}
        {global-color : Color}
        {color : Maybe Color}
        {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
        (A B : Term env context s meta-signature)
        (bpr : BorderedParallelReduction global-color color A B)
        (C : Term env context s meta-signature)
        (B~>*C : TClosure (TopLevelColoredReduction global-color) B C)
        : \Sigma (someColor : Maybe Color) (BorderedParallelReduction global-color someColor A C) \elim color, A, bpr
        | color, A, equal-trees p => \let hcr => TopLevelColoredReduction.extract-root-coloring (TClosure.extract B~>*C).2 \in \case \elim A, \elim B, \elim global-color, \elim B~>*C, \elim hcr, \elim p \with {
          | A, func (inl s1) choosing, red, B~>*C, red-func-root, idp => (just red, parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite B~>*C idp))
          | A, func (inr s1) choosing, blue, B~>*C, blue-func-root, idp => (just blue, parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite B~>*C idp))
        }
        | nothing, func f choosing, parallelization-f mediator _x (cr-skip p) => (just global-color, parallelization-f mediator _x (cr-rewrite (rewrite p B~>*C) idp))
        | just a, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => (just global-color, parallelization-f mediator _x (cr-rewrite (TClosure.compose (rewrite p t) B~>*C) idp))
    }

  \data ColorwiseReduction {tc : TheoremContext}
                           {context : List Sort'}
                           {s : Sort'}
                           {meta-signature : MetaSignature Sort'}
                           (global-color : Color)
                           (color : Maybe Color) (A B : Term env context s meta-signature) \elim color
    | nothing => cr-skip (A = B)
    | just color => cr-rewrite (TClosure (TopLevelColoredReduction {tc} color) A B) (global-color = color)

  \func TrichromaticParallelReduction {tc : TheoremContext} {meta-signature : MetaSignature Sort'} {context : List tc.Sort'} {s : Sort'} (A B : Term env context s meta-signature) : \Type =>
    \Sigma (global-color : Color) (color : Maybe Color) (BorderedParallelReduction global-color color A B)

  \func ConfluentialSystem (env : Environment) (rules : IndexedSet (RewriteRule env)) : \Type =>
    \Pi {meta-signature : MetaSignature Sort} {context : List Sort} {s : Sort}
        (A B C : Term env context s meta-signature)
        (TClosure (RewriteRelation rules) A B)
        (TClosure (RewriteRelation rules) A C) -> StraightJoin B C (TClosure (RewriteRelation rules))

  \func bpr-confluence {tc : TheoremContext} {gc1 gc2 : Color} (color1 color2 : Maybe Color) {context : List tc.Sort'} {s : Sort'}
                       {A B C : PureTerm env context s}
                       (A~>B : BorderedParallelReduction gc1 color1 A B)
                       (A~>C : BorderedParallelReduction gc2 color2 A C)
                       (left-confluence : ConfluentialSystem envL L-rules)
                       (right-confluence : ConfluentialSystem envR R-rules)
    : \Sigma (D : PureTerm env context s)
             (color3 : Maybe Color)
             (color4 : Maybe Color)
             (BorderedParallelReduction gc2 color3 B D)
             (BorderedParallelReduction gc1 color4 C D) \elim color1, color2, A, B, C, A~>B, A~>C
    | color1, color2, A, B, C, equal-trees p, rd => (C, color2, color1, rewriteI p rd, equal-trees idp)
    | color1, color2, A, B, C, rd, equal-trees p => (B, color2, color1, equal-trees idp, rewriteI p rd)
    | nothing, nothing, func f choosing, B, C, parallelization-f mediator choosing->med (cr-skip famed=B), parallelization-f mediator' choosing->med' (cr-skip famed'=C)
    => \let | inner-confluences i => bpr-confluence (choosing->med i).1 (choosing->med' i).1 (choosing->med i).3 (choosing->med' i).3 left-confluence right-confluence
            | D => func {env} f (\lam i => (inner-confluences i).1)
            | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).2, (inner-confluences i).4))
            | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).3, (inner-confluences i).5))
       \in (func f (\lam i => (inner-confluences i).1),
            color-1,
            color-2,
            rewriteI famed=B (parallelization-f mediator-1 inrd-1 cwr-1),
            rewriteI famed'=C (parallelization-f mediator-2 inrd-2 cwr-2))
    | nothing, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-skip p), parallelization-f mediator' choosing=>med' (cr-rewrite med'~>C gc2=right-color) =>
      \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
           | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
           | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
           | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
           | rd : BorderedParallelReduction gc2 color-1 (func f mediator) (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-1 inrd-1 cwr-1
           | (rightmost-reduct, flr~>rr, mcl, C=>rr) => unify-top right-color gc1 f mediator' mediator-2 C med'~>C inrd-2
           | (X, c1, B=>X, c2, C=>X) => unwrap-cwr (func f mediator) C (func f mediator-2) (first-level-reduct) (rightmost-reduct) cwr-2 (rewrite (gc2=right-color) flr~>rr) rd C=>rr left-confluence right-confluence
      \in (X,
           c1,
           c2,
           rewriteI p B=>X,
           C=>X)
    | just left-color, nothing, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-skip p) =>
      \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
           | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
           | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
           | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
           | (leftmost-reduct, flr~>lr, mcl, B=>lr) => unify-top left-color gc2 f mediator mediator-1 B med~>B inrd-1
           | rd : BorderedParallelReduction gc1 color-2 (func f mediator') (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-2 inrd-2 cwr-2
           | (X, c1, C=>X, c2, B=>X) => unwrap-cwr (func f mediator') B (func f mediator-1) (first-level-reduct) (leftmost-reduct) cwr-1 (rewrite (gc1=left-color) flr~>lr) rd B=>lr left-confluence right-confluence
      \in (X,
           c2,
           c1,
           B=>X,
           rewriteI p C=>X)
    | just left-color, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-rewrite med~>C gc2=right-color)
    => \let
        | hcl-f-left : HasColoredRoot left-color (func f mediator) => TopLevelColoredReduction.extract-root-coloring (TClosure.extract med~>B).2
        | hcl-f-right : HasColoredRoot right-color (func f mediator') => TopLevelColoredReduction.extract-root-coloring (TClosure.extract med~>C).2
        | lcolor=rcolor : left-color = right-color => HasColoredRoot.equalize-colors left-color right-color f mediator mediator' hcl-f-left hcl-f-right
        | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
        | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
        | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
        | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
        | rd : BorderedParallelReduction gc2 color-1 (func f mediator) (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-1 inrd-1 cwr-1
        | rd' : BorderedParallelReduction gc1 color-2 (func f mediator') (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-2 inrd-2 cwr-2
        | (leftmost-reduct, flr~>lr, clr-b, B=>lr) => unify-top left-color left-color f mediator mediator-1 B med~>B (rewrite (lcolor=rcolor *> inv gc2=right-color) inrd-1)
        | (rightmost-reduct, flr~>rr, clr-c, C=>rr) => unify-top right-color right-color f mediator' mediator-2 C med~>C (rewrite (inv lcolor=rcolor *> inv gc1=left-color) inrd-2)
        | (X, c1, B=>X, c2, C=>X) => unwrap-double-cwr B C (func f mediator-1) (func f mediator-2) first-level-reduct leftmost-reduct rightmost-reduct (rewrite (inv gc2=right-color) cwr-1) (rewrite (inv lcolor=rcolor *> inv gc1=left-color) cwr-2) (rewriteI lcolor=rcolor flr~>lr) flr~>rr (rewriteI lcolor=rcolor B=>lr) C=>rr left-confluence right-confluence
       \in (X, c1, c2, (rewrite gc2=right-color B=>X), rewrite (gc1=left-color *> lcolor=rcolor) C=>X)
    \where {
      \func unwrap-cwr
        {tc : TheoremContext} {gc1 gc2 : Color} {color3 color4 : Maybe Color} {context : List tc.Sort'} {s : Sort'}
        (T1 T2 A B C : PureTerm env context s) {color-2 : Maybe Color}
        (cwr : ColorwiseReduction gc1 color-2 A B) (A~>*C : TClosure (TopLevelColoredReduction gc2) A C)
        (T1=>B : BorderedParallelReduction gc2 color3 T1 B) (T2=>C : BorderedParallelReduction gc1 color4 T2 C)
        (left-confluence : ConfluentialSystem envL L-rules)
        (right-confluence : ConfluentialSystem envR R-rules)
        :
        \Sigma (X : PureTerm env context s) (c1 : Maybe Color) (BorderedParallelReduction gc2 c1 T1 X) (c2 : Maybe Color) (BorderedParallelReduction gc1 c2 T2 X) \elim color-2, cwr
        | nothing, cr-skip p => \let (cl-1, t1=>X) => BorderedParallelReduction.append-tlcr T1 B T1=>B C (rewriteI p A~>*C) \in (C, cl-1, t1=>X, color4, T2=>C)
        | just color, cr-rewrite A~>*B p =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs color gc2 A~>*B A~>*C left-confluence right-confluence
               | (cl-1, t1=>X) => BorderedParallelReduction.append-tlcr T1 B T1=>B X B~>*X
               | (cl-2, t2=>X) => BorderedParallelReduction.append-tlcr T2 C T2=>C X (rewrite p C~>*X)
          \in (X, cl-1, t1=>X, cl-2, t2=>X)

      \func unwrap-double-cwr
        {tc : TheoremContext} {gc1 : Color} {color3 color4 : Maybe Color} {context : List tc.Sort'} {s : Sort'}
        (T1 T2 A A' E B C : PureTerm env context s ) {color-2 color-1 : Maybe Color}
        (cwr-1 : ColorwiseReduction gc1 color-2 A E)
        (cwr-2 : ColorwiseReduction gc1 color-1 A' E)
        (A~>*B : TClosure (TopLevelColoredReduction gc1) A B)
        (A'~>*C : TClosure (TopLevelColoredReduction gc1) A' C)
        (T1=>B : BorderedParallelReduction gc1 color3 T1 B)
        (T2=>C : BorderedParallelReduction gc1 color4 T2 C)
        (left-confluence : ConfluentialSystem envL L-rules)
        (right-confluence : ConfluentialSystem envR R-rules)
        :
        \Sigma (X : PureTerm env context s) (c1 : Maybe Color) (BorderedParallelReduction gc1 c1 T1 X) (c2 : Maybe Color) (BorderedParallelReduction gc1 c2 T2 X) \elim color-2, color-1, cwr-1, cwr-2
        | nothing, nothing, cr-skip p, cr-skip p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 A~>*B (rewrite {1} (p *> inv p1) A'~>*C) left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | nothing, just color, cr-skip p, cr-rewrite A'~>*E p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 (TClosure.compose (transport (\lam cl => TClosure (TopLevelColoredReduction cl) A' E) (inv p1) A'~>*E) (rewrite {1} (inv p) A~>*B)) A'~>*C left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | just color, nothing, cr-rewrite A~>*E p, cr-skip p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 A~>*B (TClosure.compose ((transport (\lam cl => TClosure (TopLevelColoredReduction cl) A E) (inv p) A~>*E)) (rewrite {1} (inv p1) A'~>*C)) left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | just color, just color1, cr-rewrite A~>*E p, cr-rewrite A'~>*E p1 =>
          \let | (M1, B~>*M1, E~>*M1) => join-different-tlcrs gc1 gc1 (A~>*B) (rewrite p A~>*E) left-confluence right-confluence
               | (M2, E~>*M2, C~>*M2) => join-different-tlcrs gc1 gc1 (transport (\lam cl => TClosure (TopLevelColoredReduction cl) A' E) (inv p1) A'~>*E) A'~>*C left-confluence right-confluence
               | (X, M1~>*X, M2~>*X) => join-different-tlcrs gc1 gc1 E~>*M1 E~>*M2 left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X (TClosure.compose B~>*M1 M1~>*X)
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X (TClosure.compose C~>*M2 M2~>*X)
          \in (X, c1, T1=>X, c2, T2=>X)

      \func reorganize-colors-here {tc : TheoremContext} {gc : Color} {someColor : Maybe Color} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                   {A B : Term env context s meta-signature} (A~>B : BorderedParallelReduction gc someColor A B)
        : \Sigma (someColor' : Maybe Color) (Or (someColor' = nothing) (someColor' = just gc)) (BorderedParallelReduction gc someColor' A B) \elim someColor, A, A~>B
        | _, A, equal-trees p => (nothing, inl idp, equal-trees p)
        | nothing, func f choosing, rd => (nothing, inl idp, rd)
        | just a, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => (just a, rewrite p (inr idp), parallelization-f mediator _x (cr-rewrite t p))

      \func join-different-tlcrs {tc : TheoremContext} (color1 color2 : Color) {context : List tc.Sort'} {s : Sort'}
                                 {A B C : PureTerm env context s}
                                 (A~>B : TClosure (TopLevelColoredReduction color1) A B)
                                 (A~>C : TClosure (TopLevelColoredReduction color2) A C)
                                 (left-confluence : ConfluentialSystem envL L-rules)
                                 (right-confluence : ConfluentialSystem envR R-rules)
        : \Sigma (X : PureTerm env context s) (TClosure (TopLevelColoredReduction color2) B X) (TClosure (TopLevelColoredReduction color1) C X)
      \elim color1, color2
        | red, red => join-tlcrs red A B C A~>B A~>C left-confluence
        | red, blue => \let | a => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>B).2
                            | b => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>C).2 \in \case \elim A, \elim a, \elim b \with {
          }
        | blue, red => \let | a => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>B).2
                            | b => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>C).2 \in \case \elim A, \elim a, \elim b \with {
          }
        | blue, blue => join-tlcrs blue A B C A~>B A~>C right-confluence

      \func gather-reduction {tc : TheoremContext}
                             (color : Color)
                             (sclr : Maybe Color)
                             (eq : (sclr = nothing) `Or` (sclr = just color))
                             {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {B lr X : Term env context s meta-signature}
                             (B=>lr : BorderedParallelReduction color sclr B lr)
                             (lr~>X : TClosure (TopLevelColoredReduction color) lr X)
        : BorderedParallelReduction color (just color) B X
        \elim sclr, eq, B, B=>lr
          | sclr, _, B, equal-trees p => \let x => TopLevelColoredReduction.extract-root-coloring (TClosure.extract lr~>X).2 \in \case \elim color, \elim lr, \elim x, \elim p, \elim lr~>X \with {
            | red, func (inl f) choosing, red-func-root, p, lr~>X => rewrite p (parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite lr~>X idp))
            | blue, func (inr f) choosing, blue-func-root, p, lr~>X => rewrite p (parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite lr~>X idp))
          }
          | nothing, inl a, func f choosing, parallelization-f mediator _x (cr-skip p) => parallelization-f mediator _x (cr-rewrite (rewrite p lr~>X) idp)
          | just a1, inl a, func f choosing, parallelization-f mediator _x c => contradiction
          | nothing, inr b, func f choosing, parallelization-f mediator _x c => contradiction
          | just a, inr b, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => parallelization-f mediator _x (cr-rewrite (TClosure.compose (rewriteI (Maybe.unjust-eq b) t) lr~>X) idp)

      \func twist-colors {c1 c2 c3 : Maybe Color} (c1or : Or (c1 = nothing) (c1 = c2)) (c2or : Or (c2 = nothing) (c2 = c3)) : Or (c1 = nothing) (c1 = c3) \elim c1or
        | inl a => inl a
        | inr b => rewrite b c2or

      \func twist-colors' {c1 c2 c3 : Maybe Color} (c1or : Or (c1 = c2) (c1 = nothing)) (c2or : Or (c2 = nothing) (c2 = c3)) : Or (c1 = nothing) (c1 = c3) \elim c1or
        | inl a => rewrite a c2or
        | inr b => inl b
    }

  \func unify-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color color' : Color)
                  (f : env.FunctionalSymbol.symbol s)
                  (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> PureTerm env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
                  (B : PureTerm env context s)
                  (A~>B : TClosure (TopLevelColoredReduction color) (func {env} f choosing-A) B)
                  (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f) ->
                      \Sigma (someColor : Maybe Color)
                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
                             (BorderedParallelReduction {tc} color' someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
    : \Sigma (X : PureTerm env context s)
             (TClosure (TopLevelColoredReduction color) (func {env} f choosing-C) X)
             (mcolor : Maybe Color)
             (BorderedParallelReduction color' mcolor B X) =>
    \let
      | (t, rho, t[rho]=A, root-colors) => decompose-term color (func f choosing-A)
      | (u, lu[rho]=B, t~>*u) => iterate-decomposition (LinearTerm.convert-to-term {colored-env color} t) rho B t[rho]=A A~>B root-colors
      | eqs : LinearMetasignatureT {colored-env color} t = LinearMetasignatureT {env} (inject-linear-term color t) => linear-metasignature-equator
      | eqs2 : (LinearTerm.convert-to-term {env} (inject-linear-term color t)) =  (transport (Term env context s) eqs (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t))) => equate-transported-terms color t -- technical
      | injected-u : Term env context s (LinearMetasignatureT {env} (inject-linear-term color t)) => rewriteI eqs (inject-monochrome-term color u)
      | modified-rho => transport (MetaSubstitution env nil __ (EmptyMetasignature {env})) eqs rho
      | eqs3 : (func {env} f choosing-A) = (MetaSubstitution.apply {env} (LinearTerm.convert-to-term {env} (inject-linear-term color t)) sublist-trivial modified-rho) => inv t[rho]=A *> {?}
      | witnesses => inject-linear-term.generate-injection-witness color t
      | (sigma, C=t[sigma], reds) => alternate-subst {_} color color' (func f choosing-C) (inject-linear-term {_} color t) witnesses modified-rho ({?}) nothing (inl idp) (rewriteI eqs3 (parallelization-f choosing-C inner-reductions (cr-skip idp)))
      | uni-right => TClosure.lift {_} {_} {monochrome-reduction color} {TopLevelColoredReduction color} (\lam trm => (MetaSubstitution.apply {env} (inject-monochrome-term color trm) sublist-trivial (transport (MetaSubstitution env nil __ (EmptyMetasignature {env})) (inv eqs) sigma))) (lift-relation color (transport (MetaSubstitution env nil __ (EmptyMetasignature {env})) (inv eqs) sigma)) (LinearTerm.convert-to-term {colored-env color} t) u t~>*u
      | (mcl, uni-left) => unify-left color' color injected-u {?easy} sublist-trivial modified-rho sigma reds
    \in metasignature-unificator eqs color color' B (func f choosing-C)
        (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t))
        (inject-monochrome-term color u)
        rho
        sigma
        lu[rho]=B
        (rewriteI eqs2 C=t[sigma])
        uni-right
        uni-left
    \where {
      \func iterate-decomposition
        {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-msig meta-signature : MetaSignature Sort'}
        {color : Color}
        (t : Term (colored-env {tc} color) context s inner-msig)
        (rho : MetaSubstitution env nil inner-msig meta-signature)
        {A : Term env context s meta-signature}
        (B : Term env context s meta-signature)
        (teq : (MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist-trivial rho) = A)
        (A~>*B : TClosure (TopLevelColoredReduction color) A B)
        (root-colors : \Pi {s : Sort'} (m : inner-msig.metaname s) -> HasColoredRoot (Color.flip color) (rho m))
        : \Sigma (u : Term (colored-env {tc} color) context s inner-msig)
                 (MetaSubstitution.apply {env} (inject-monochrome-term color u) sublist-trivial rho = B)
                 (TClosure (monochrome-reduction color) (t) u) \elim A~>*B
        | tc-basic A~>B =>
          \let | (u, lu[rho]=B, t~>u) => decompose-along-reduction color t B rho root-colors (rewrite teq A~>B)
          \in (u, lu[rho]=B, tc-basic t~>u)
        | tc-connect C A->C C~>*B =>
          \let | (c, meq, rd) => decompose-along-reduction color t C rho root-colors (rewrite teq A->C)
          | (u, mu, tcl) => iterate-decomposition c rho B (meq) (C~>*B) root-colors \in (u, mu, tc-connect c rd tcl)

      \func linear-metasignature-equator {tc : TheoremContext} {color : Color} {context : List Sort'} {s : Sort'} {t : LinearTerm (colored-env color) context s} : LinearMetasignatureT {colored-env color} t = LinearMetasignatureT {env} (inject-linear-term color t) \elim color, t
        | red, lt-func f choosing => \let ext-lemma : (\lam i => LinearMetasignatureT {envL} (choosing i)) = (\lam i => LinearMetasignatureT {env} (inject-linear-term red (choosing i))) => ext (\lam i => linear-metasignature-equator) \in rewrite ext-lemma idp
        | red, lt-metavar params choosing => \let ext-lemma : (\lam i => LinearMetasignatureT {envL} (choosing i)) = (\lam i => LinearMetasignatureT {env} (inject-linear-term red (choosing i))) => ext (\lam i => linear-metasignature-equator) \in rewrite ext-lemma idp
        | red, lt-full-metavar => idp
        | red, lt-var index p => idp
        | blue, lt-func f choosing => \let ext-lemma : (\lam i => LinearMetasignatureT {envR} (choosing i)) = (\lam i => LinearMetasignatureT {env} (inject-linear-term blue (choosing i))) => ext (\lam i => linear-metasignature-equator) \in rewrite ext-lemma idp
        | blue, lt-metavar params choosing => \let ext-lemma : (\lam i => LinearMetasignatureT {envR} (choosing i)) = (\lam i => LinearMetasignatureT {env} (inject-linear-term blue (choosing i))) => ext (\lam i => linear-metasignature-equator) \in rewrite ext-lemma idp
        | blue, lt-full-metavar => idp
        | blue, lt-var index p => idp

      \func equate-transported-terms {tc : TheoremContext}
                                     (color : Color) {context : List Sort'} {s : Sort'}
                                     (t : LinearTerm (colored-env color) context s)
        : LinearTerm.convert-to-term {env} (inject-linear-term color t) = transport (Term env context s) (linear-metasignature-equator) (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t)) \elim color, t
        | red, lt-func f choosing =>
          \let | inner : (\lam i => LinearTerm.convert-to-term {env} (inject-linear-term red (choosing i))) = (\lam i => transport (Term env (f FunctionalSignature.!!param i ++ context) (f FunctionalSignature.!!sort i)) (linear-metasignature-equator) (Injections.inject-term-left envL envR (LinearTerm.convert-to-term {envL} (choosing i)))) => ext (\lam i => equate-transported-terms red (choosing i))
          \in {?}
        | red, lt-metavar params choosing => {?}
        | red, lt-full-metavar => idp
        | red, lt-var index p => idp
        | blue, lt-func f choosing => {?}
        | blue, lt-metavar params choosing => {?}
        | blue, lt-full-metavar => idp
        | blue, lt-var index p => idp

      \func metasignature-unificator {tc : TheoremContext} {context : List Sort'} {s : Sort'} {left-meta-signature right-meta-signature outer-meta-signature : MetaSignature Sort'}
                                     (meta-signature-equality : left-meta-signature = right-meta-signature)
                                     (color color' : Color)
                                     {mcolor : Maybe Color}
                                     (B C : Term env context s outer-meta-signature)
                                     (inj-t inj-u : Term env context s left-meta-signature)
                                     (rho : MetaSubstitution env nil left-meta-signature outer-meta-signature)
                                     (sigma : MetaSubstitution env nil right-meta-signature outer-meta-signature)
                                     (lu[rho]=b : MetaSubstitution.apply {env} inj-u sublist-trivial rho = B)
                                     (C=t[sigma] : C = MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-t) sublist-trivial sigma)
                                     (uni-right : TClosure (TopLevelColoredReduction color)
                                         (MetaSubstitution.apply {env} (inj-t) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) (inv meta-signature-equality) sigma))
                                         (MetaSubstitution.apply {env} (inj-u) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) (inv meta-signature-equality) sigma)))
                                     (uni-left : BorderedParallelReduction color' mcolor
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) sublist-trivial (transport (MetaSubstitution env nil __ outer-meta-signature) meta-signature-equality rho))
                                         (MetaSubstitution.apply {env} (transport (Term env context s) meta-signature-equality inj-u) sublist-trivial sigma))
        : \Sigma (X : Term env context s outer-meta-signature)
                 (TClosure (TopLevelColoredReduction color) C X)
                 (mcolor : Maybe Color)
                 (BorderedParallelReduction color' mcolor B X) \elim meta-signature-equality
        | idp => (MetaSubstitution.apply {env} inj-u sublist-trivial sigma,
                  rewrite C=t[sigma] uni-right,
                  mcolor,
                  rewriteI lu[rho]=b uni-left)

      \func recreate-coloring-for-root {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {color : Color} {f : env.FunctionalSymbol.symbol s}
                                       {choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                                       (h : HasColoredRoot color (func f choosing-A)) : HasColoredRoot color (func f choosing-C) \elim color, f, h
        | red, inl s1, red-func-root => red-func-root
        | blue, inr s1, blue-func-root => blue-func-root
    }

  \func alternate-subst {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (gc rcolor : Color)
                        (C : Term env context s meta-signature)
                        (t : LinearTerm env context s)
                        (witness : inject-linear-term.InjectionWitness gc t)
                        (rho : MetaSubstitution env nil (LinearMetasignatureT {env} t) meta-signature)
                        (root-colors : \Pi {s1 : Sort'} -> \Pi (m : metaname {LinearMetasignatureT {env} t} s1) -> HasColoredRoot (Color.flip gc) (rho m))
                        (someColor : Maybe Color)
                        (some-color-diff : (someColor = nothing) `Or` (someColor = just (Color.flip gc)))
                        (A=>C : BorderedParallelReduction rcolor someColor (MetaSubstitution.apply {env} ((LinearTerm.convert-to-term {env} t)) sublist-trivial rho) C)
    : \Sigma (sigma : MetaSubstitution env nil (LinearMetasignatureT {env} t) meta-signature)
             (C = MetaSubstitution.apply {env} ((LinearTerm.convert-to-term {env} t)) (sublist-trivial) sigma)
             (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignatureT {env} t} s) ->
                 \Sigma (mcolor : Maybe Color) (BorderedParallelReduction rcolor mcolor (rho m) (sigma m)))
    \elim t, someColor, A=>C
      | lt-func f choosing, nothing, parallelization-f mediator inner-reductions (cr-skip p) =>
        \let
          | inner-witnesses => inject-linear-term.extract-from-witness gc f choosing witness
          | inductive-result i => alternate-subst gc rcolor
              (mediator i) (choosing i)
              (inner-witnesses.1 i)
              (\lam m => rho (i, m))
              (\lam {s1} m => root-colors (i, m))
              (inner-reductions i).1 (rewriteI inner-witnesses.2 (inner-reductions i).2)
              (rewrite (modular-commutation {env} (\lam j => LinearMetasignatureT {env} (choosing j)) i sublist-trivial (LinearTerm.convert-to-term {env} (choosing i)) rho)
                  (rewrite (invariant-through-empty-subst {env} rho sublist-trivial (SubList.extend-right-single-left sublist-trivial) (LinearTerm.upgrade-metavariables-t {env}
                      (\lam j => LinearMetasignatureT {env} (choosing j)) (LinearTerm.convert-to-term {env} (choosing i)))) (inner-reductions i).3))
        \in (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2,
             inv p *> (pmap (func {env} f)
                 (ext (\lam index => rewriteI
                     (modular-commutation {env} (\lam j => LinearMetasignatureT {env} (choosing j)) index (SubList.extend-right-single-left sublist-trivial) (LinearTerm.convert-to-term {env} (choosing index)) (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2))
                     (rewrite (invariant-through-empty-subst {env} ) (inductive-result index).2)))),
             \lam {s1} m => (inductive-result (m.1)).3 m.2)
      | lt-func f choosing, just color, parallelization-f mediator inner-reductions (cr-rewrite tlcr p) =>
        \let | inner-witnesses => (inject-linear-term.extract-from-witness gc f choosing witness).2
             | coloring-from-tlcr => HasColoredRoot.reorganize color (TopLevelColoredReduction.extract-root-coloring (TClosure.extract tlcr).2)
             | extracted => Color.flip-contradiction (inv (inner-witnesses) *> coloring-from-tlcr *> extract-from-or some-color-diff)
        \in contradiction
      | lt-func f choosing, someColor, equal-trees p => (rho, inv p, \lam {s1} m => (nothing, equal-trees idp))
      | lt-metavar params choosing, someColor, rd => {?} -- impossible, use patterns
      | lt-full-metavar, someColor, rd =>
        (\lam {s1} mvar => transport2 (\lam ctx srt => Term env ctx srt meta-signature) (inv ++_nil) (inv mvar) C,
         rewrite (transport2-to-transport) (inv (plain-identity-effect {env} C) *> (apply-subst-with-extended-identity {env} C (\lam i => var i idp))),
         \lam {s1} m => \let | unified => unify-reduction rho C rd m  \in (someColor, unified))
      | lt-var index p, someColor, equal-trees p1 => (\lam {s1} mvar => contradiction, inv p1, \lam {s1} m => contradiction)
    \where {
      \func extract-from-or {A : \Type} {a b : A} (or : Or (just a = nothing) (just a = just b)) : a = b
        | inl a1 => contradiction
        | inr b1 => Maybe.unjust-eq b1

      \func unify-reduction {tc : TheoremContext} {gc : Color} {someColor : Maybe Color} {context : List Sort'} {s s' : Sort'} {meta-signature : MetaSignature Sort'}
                            (rho :  MetaSubstitution env nil (SingularMetaSignature {env} s context) meta-signature)
                            (C : Term env context s meta-signature)
                            (bpr : BorderedParallelReduction gc someColor (Substitution.apply {env}
                                (rho idp) (extend-substitution-right {env} sublist-trivial (\lam i => var i idp))) C)
                            (m : s' = s)
        : BorderedParallelReduction gc someColor (rho m)
          (transport2 (\lam (ctx : List Sort') (srt : Sort') => Term env ctx srt meta-signature) (inv ++_nil) (inv m) C) \elim m
        | idp => rewrite transport2-to-transport {?}

      \func reorganize-colors {tc : TheoremContext} {gc gc' : Color} {someColor : Maybe Color} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
        {A B : Term env context s meta-signature} (A~>B : BorderedParallelReduction gc someColor A B) (or : (someColor = nothing) `Or` (someColor = just gc'))
        : \Sigma (someColor' : Maybe Color) (Or (someColor' = nothing) (someColor' = just (gc'))) (BorderedParallelReduction gc someColor' A B) \elim someColor, A, A~>B
        | _, A, equal-trees p => (nothing, inl idp, equal-trees p)
        | nothing, func f choosing, rd => (nothing, inl idp, rd)
        | just a, func f choosing, rd => (just a, or, rd)


      \func identify-context-mapping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                     (sublist : SubList right-context (left-context ++ right-context))
                                     (sublist' : SubList left-context (left-context ++ right-context))
                                     (ind : Fin (length (left-context ++ right-context))) :
        (extend-substitution-right {env} {_} {_} {_} {meta-signature} sublist (wide-identity sublist')) ind = var ind idp
      \elim left-context, right-context, ind
        | nil, :: a right-context, zero => {?}
        | nil, :: a right-context, suc ind => {?} -- rewrite (extension-over-identity-is-identity ind) idp
        | :: a left-context, nil, zero => {?}
        | :: a left-context, r, suc ind => {?}
        | :: a left-context, :: a1 right-context, zero => {?}
        \where {
          \func outer-equality-ext {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                   (sublist : SubList right-context (left-context ++ right-context))
                                   (sublist' : SubList left-context (left-context ++ right-context)) : extend-substitution-right {_} {_} {_} {_} {meta-signature} sublist (wide-identity sublist') = plain-identity => ext (outer-equality-to-identity sublist sublist')

          \func outer-equality-to-identity {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                           (sublist : SubList right-context (left-context ++ right-context))
                                           (sublist' : SubList left-context (left-context ++ right-context)) (i : Fin (length (left-context ++ right-context))) : extend-substitution-right sublist (wide-identity sublist') i = plain-identity {_} {_} {meta-signature} i =>
            {?}

          \func extension-over-identity-is-identity {A : \Type} {some-context : List A} (j : Fin (length some-context)) : extend-substitution-right.produce-inner-term SubList.identity j = (j, idp) \elim some-context, j
            | :: a some-context, zero => idp
            | :: a some-context, suc j => rewrite (extension-over-identity-is-identity j) idp

          \func extension-over-skipping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort} {a : Sort}
                                        (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                        (j : Fin (length (left-context ++ right-context)))
                                        (eq : extend-substitution-right {_} {_} {_} {_} {meta-signature} (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j = var j idp)
            : extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j = var (suc j) idp =>
            \let | rrr => pmap (weakening {_} {_} {_} {a :: (left-context ++ right-context)} __ (sublist-skip SubList.identity)) eq
                 | qqq : rrr @ right = var (suc j) idp => \let internal => recalculate-over-skipping {_} {a} j \in pmap sigma-to-var internal
                 | zzz : rrr @ left = extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j => weakining-extension-comms index-calculator j
            \in inv zzz *> rrr *> qqq

          \func sigma-to-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (sig : \Sigma (i : Fin (length context)) (s = context !! i)) : Term env context s meta-signature =>
            var sig.1 sig.2

          \func recalculate-over-skipping {A : \Set} {point' : A} {a : List A} (ind : Fin (length a)) : weakening.recalculate-index {_} {a} {point' :: a} (sublist-skip SubList.identity) ind idp = (suc ind, idp) \elim a, ind
            | :: a a1, zero => idp
            | :: a a1, suc ind => rewrite (weakening.recalculate-index-over-identity ind) idp

          \func weakining-extension-comms {env : Environment} {left-context right-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort}
                                          (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                          (j : Fin (length (left-context ++ right-context)))
            : weakening {_} {_} {_} {_} {meta-signature}
              (extend-substitution-right (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j)
              (sublist-skip SubList.identity) =
          extend-substitution-right {_} {_} {_} {s :: left-context ++ right-context}
              (sublist-skip (SubList.extend-right-single-left SubList.identity))
              (\lam i => \let (index, p) => index-calculator i \in var (suc index) p)
              j => {?}
        }

      \func unwrap-func {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                        (T : Term env context s meta-signature) : Or Nat
          (\Sigma (f : env.FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
              Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) \elim T
        | var index p => inl 0
        | metavar m choosing1 => inl 0
        | func f1 choosing1 => inr (f1, choosing1)

      \func unwrap-func' {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                         {f'' : env.FunctionalSymbol.symbol s}
                         {choosing choosing' : \Pi (index : Fin (length (env.FunctionalSymbol.domain f''))) ->
                             Term env ((f'' FunctionalSignature.!!param index) ++ context) (f'' FunctionalSignature.!!sort index) meta-signature}
                         (eq : func f'' choosing = func f'' choosing') : choosing' = choosing => sigma-set-equalizer (\lam f => \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) (inv (pmap (decomposeTermAsFunctionalSymbol (f'', choosing)) eq))

      \func sigma-set-equalizer {A : \Set} (B : A -> \Type) {a : A} {b b' : B a} (p : (a,b) = {\Sigma (x : A) (B x)} (a,b')) : b = b'
        => pmap (transport B __ b) (Path.inProp idp (pmap __.1 p)) *> pmapd (\lam t => B t.1) __.2 p

      \func decomposeTermAsFunctionalSymbol {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                                            (default : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
                                                Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) (T : Term env context s meta-signature) : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) \elim T
        | var index p => default
        | metavar m choosing => default
        | func f choosing => (f, choosing)

      \func apply-modularity {env : Environment} {context subst-context pattern-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n}
                             (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (pat-sublist : SubList pattern-context context)
                             (t : Term env pattern-context s (producer index)) :
        MetaSubstitution.apply (weakening t pat-sublist) sublist (substitutions index) = MetaSubstitution.apply (weakening (LinearPattern.upgrade-metavariables-p producer t) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim t
        | var index1 p => idp
        | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-right sublist e)) (ext (\lam i => apply-modularity producer substitutions sublist pat-sublist (choosing i)))
        | func f choosing => pmap (func f) (ext (\lam i => apply-modularity producer substitutions (SubList.extend-right-single-left sublist) (SubList.extend-left pat-sublist) (choosing i)))
    }

  \data TClosure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | tc-basic (a `R` b)
    | tc-connect (c : A) (a `R` c) (TClosure R c b)
    \where {
      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : TClosure Rel x y) : TClosure Rel' (map x) (map y) \elim closure
        | tc-basic r => tc-basic (rel-map r)
        | tc-connect c r closure => tc-connect (map c) (rel-map r) (lift map rel-map c y closure)

      \func compose {A : \Type} {R : A -> A -> \Type} {a b c : A} (a->b : TClosure R a b) (b->c : TClosure R b c) : TClosure R a c \elim a->b
        | tc-basic r => tc-connect b r b->c
        | tc-connect c1 r a->b => tc-connect c1 r (compose a->b b->c)

      \func extract  {A : \Type} {R : A -> A -> \Type} {a b : A} (cl : TClosure R a b) : \Sigma (c : A) (R a c) \elim cl
        | tc-basic r => (b, r)
        | tc-connect c r cl => (c, r)
    }

  \data Closure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | c-trivial (a = b)
    | c-basic (a `R` b)
    | c-connect (c : A) (a `R` c) (Closure R c b)
    \where {
      \func concat {A : \Type} {R : A -> A -> \Type} {a b c : A} (a~>b : Closure R a b) (b~>c : Closure R b c) : Closure R a c \elim a~>b, b~>c
        | c-basic r, rx => c-connect b r rx
        | c-connect c1 r a~>b, rx => c-connect c1 r (concat a~>b rx)
        | c-trivial idp, b~>c => b~>c

      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : Closure Rel x y) : Closure Rel' (map x) (map y) \elim closure
        | c-basic r => c-basic (rel-map r)
        | c-connect c r closure => c-connect (map c) (rel-map r) (lift map rel-map c y closure)
        | c-trivial idp => c-trivial idp

      \func flatten {A : \Type} {Rel : A -> A -> \Type}
                    {x y : A}
                    (closure : Closure (Closure Rel) x y) : Closure Rel x y \elim closure
        | c-basic r => r
        | c-connect c r closure => concat r (flatten closure)
        | c-trivial idp => c-trivial idp
    }

  \func unify-left {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {inner-metasignature : MetaSignature Sort'}
                   (gc anti-color : Color)
                   (s : Term env context' s inner-metasignature)
                   (witness : inject-monochrome-term.InjectionWitness anti-color s)
                   (sublist : SubList context context')
                   (rho sigma : MetaSubstitution env context inner-metasignature (EmptyMetasignature {env}))
                   (rho~>sigma : \Pi {s : Sort'} (m : inner-metasignature.metaname s) ->
                       \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (rho m) (sigma m))) :
    \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (MetaSubstitution.apply {env} s sublist rho) (MetaSubstitution.apply {env} s sublist sigma))
  \elim s, witness
    | var index p, _ => (nothing, equal-trees idp)
    | metavar m choosing, wit =>
      \let | main-reduction => rho~>sigma m
           | rho-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho))
           | sigma-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma))
           | target-reduction => reduction-over-substitution main-reduction.1 (rho m) (sigma m) main-reduction.2 rho-subst sigma-subst {?} -- extension of substitutions
      \in (target-reduction)
    | func f choosing, inject-monochrome-term.iw-func p _x =>
      \let | in-indices i => unify-left gc (color-of-root f) (choosing i) (rewrite p (_x i)) (SubList.extend-right-single-left sublist) rho sigma rho~>sigma
      \in (nothing, parallelization-f (\lam i => (MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single-left sublist) sigma)) (\lam i => ((in-indices i).1, {?}, (in-indices i).2)) (cr-skip idp))

  \func reduction-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'}
                                    {gc : Color}
                                    (color : Maybe Color)
                                    (A B : PureTerm env context s)
                                    (A=>B : BorderedParallelReduction gc color A B)
                                    (subst subst' : Substitution {env} context new-context (EmptyMetasignature {env}))
                                    (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    : \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (Substitution.apply {env} A subst) (Substitution.apply {env} B subst')) \elim color, A, A=>B
    | color, A, equal-trees p => rewrite p (distributed-reduction-for-substitution B color _ _ subst=>subst')
    | nothing, func f choosing, parallelization-f mediator _x (cr-skip p) =>
      \let | medium-reductions i => reduction-over-substitution  (_x i).1 (choosing i) (mediator i) (_x i).3 (append-context-left {env} subst) (append-context-left {env} subst') {?}
           | (sc, med, inrd, cwr) => (collect-reductions-together-raw f (\lam i => Substitution.apply {env} (choosing i) (append-context-left {env} subst)) (\lam i => Substitution.apply {env} (mediator i) (append-context-left {env} subst')) medium-reductions)
      \in rewriteI p (sc, (parallelization-f med inrd cwr))
    | just a, func f choosing, parallelization-f mediator _x (cr-rewrite tlcr p) =>
      \let | medium-reductions i => reduction-over-substitution (_x i).1 (choosing i) (mediator i) (_x i).3 (append-context-left {env} subst) (append-context-left {env} subst') {?}
      \in (collect-reductions-together-tlcr f (\lam i => Substitution.apply {env} (choosing i) (append-context-left {env} subst)) (\lam i => Substitution.apply {env} (mediator i) (append-context-left {env} subst')) medium-reductions (Substitution.apply {env} B subst') (rewrite p (TClosure.lift (\lam t => Substitution.apply {env} t subst') (\lam rel => tlcr-over-substitution subst' rel) (func {env} f mediator) B tlcr)))

  \func tlcr-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                               {A B : Term env context s meta-signature}
                               {color : Color}
                               (subst : Substitution {env} context new-context meta-signature)
                               (A~>B : TopLevelColoredReduction color A B)
    : TopLevelColoredReduction color (Substitution.apply {env} A subst) (Substitution.apply {env} B subst) \elim A, B, A~>B
    | A, B, rewrite-with-rule-colored h ((rule, msubst, msubst[l]=A, msubst[r]=B)) => rewrite-with-rule-colored {?} (\new LinearRewriteStep {
      | rule => rule
      | substitution m => Substitution.apply {env} (msubst m) (append-context-left {env} subst)
      | left-coherence => rewriteI msubst[l]=A {?}
      | right-coherence => rewriteI msubst[r]=B {?}
    })
    | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => {?}

  \func distributed-reduction-for-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'}
                                               (A : PureTerm env context s)
                                               {gc : Color}
                                               (color : Maybe Color)
                                               (subst subst' : Substitution {env} context new-context (EmptyMetasignature {env}))
                                               (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    : \Sigma (color' : Maybe Color) (BorderedParallelReduction gc color' (Substitution.apply {env} A subst) (Substitution.apply {env} A subst')) \elim A
    | var index p => \case \elim s, \elim p \with {
      | s, idp => (subst=>subst' index)
    }
    | metavar m choosing => contradiction
    | func f choosing =>
      \let | inner-reductions i => distributed-reduction-for-substitution (choosing i) {gc} color (append-context-left {env} subst) (append-context-left {env} subst') {?}
           | (sc, med, inrd, cwr) => collect-reductions-together-raw f
               (\lam index => (Substitution.apply {env} (choosing index) (append-context-left {env} subst)))
               (\lam index => (Substitution.apply {env} (choosing index) (append-context-left {env} subst')))
               inner-reductions \in (sc, parallelization-f med inrd cwr)

  \func collect-reductions-together-tlcr
    {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
    {gc : Color}
    (f : env.FunctionalSymbol.symbol s)
    (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
    (tlcrs : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (choosing-A index) (choosing-B index)))
    (C : Term env context s meta-signature)
    (B~>*C : TClosure (TopLevelColoredReduction gc) (func {env} f choosing-B) C)
    : \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (func f choosing-A) C) => {?}

  \func collect-reductions-together-raw
    {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
    {gc : Color}
    (f : env.FunctionalSymbol.symbol s)
    (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
    (tlcrs : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (choosing-A index) (choosing-B index)))
    : \Sigma
    (someColor : Maybe Color)
    (mediator : \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) ->
        Term (env {tc}) ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
    (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f) -> \Sigma
      (someColor : Maybe Color)
      ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f))))
      (BorderedParallelReduction {tc} gc someColor (choosing-A i) (mediator i)))
    (ColorwiseReduction {tc} gc someColor (func f mediator) (func f choosing-B)) => ({?}, choosing-A, {?}, {?})



  --  \func reduction-over-extension {tc : TheoremContext} {basic-context extended-context additional-context : List Sort'} {meta-signature : MetaSignature Sort'}
  --                                 (substA substB : Substitution {env} basic-context extended-context meta-signature)
  --                                 (sublist : SubList additional-context extended-context)
  --                                 (A=>B : \Pi (i : Fin (length basic-context)) -> Closure TrichromaticParallelReduction (substA i) (substB i))
  --                                 (j : Fin (length (basic-context ++ additional-context))) : Closure TrichromaticParallelReduction (extend-substitution-right {env} sublist substA j) (extend-substitution-right {env} sublist substB j) \elim basic-context, j
  --    | nil, j => c-basic (nothing, equal-trees idp)
  --    | :: a basic-context, zero => A=>B zero
  --    | :: a basic-context, suc j => reduction-over-extension (\lam i => substA (suc i)) (\lam i => substB (suc i)) sublist (\lam i => A=>B (suc i)) j

  --  \func apply-reducible-substitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
  --                                     (s : Term env context s meta-signature)
  --                                     (a-subst b-subst : Substitution {env} context context' meta-signature)
  --                                     (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
  --    : Closure TrichromaticParallelReduction (Substitution.apply {env} s a-subst) (Substitution.apply {env} s b-subst)
  --  \elim s
  --    | var index p => \case \elim s, \elim p \with {
  --      | s, idp => a~>b index
  --    }
  --    | metavar m choosing => {?} -- like the bottom one
  --    | func f choosing =>
  --      \let | choosing-a i => (Substitution.apply {env} (choosing i) (append-context-left {env} a-subst))
  --           | choosing-b i => (Substitution.apply {env} (choosing i) (append-context-left {env} b-subst))
  --           | q i => apply-reducible-substitution (choosing i) (append-context-left {env} a-subst) (append-context-left {env} b-subst) (reduction-over-left-append a-subst b-subst a~>b)
  --      \in gather-closure f choosing-a choosing-b q

  --  \func reduction-over-left-append {tc : TheoremContext} {context add-context context' : List Sort'} {meta-signature : MetaSignature Sort'}
  --                                   (a-subst b-subst : Substitution {env} context context' meta-signature)
  --                                   (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
  --                                   (i : Fin (length (add-context ++ context))) : Closure TrichromaticParallelReduction (append-context-left {env} a-subst i) (append-context-left {env} b-subst i) \elim add-context, i
  --    | nil, i => a~>b i
  --    | :: a add-context, zero => c-basic (nothing, equal-trees idp)
  --    | :: a add-context, suc i => \let x => reduction-over-left-append a-subst b-subst a~>b i \in reduction-over-weakening (append-context-left {env} a-subst i) (append-context-left {env} b-subst i) x (sublist-skip SubList.identity)

  \func reduction-over-weakening {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (T S : Term env context s meta-signature)
                                 (T~>S : Closure TrichromaticParallelReduction T S)
                                 (sublist : SubList context new-context)
    : Closure TrichromaticParallelReduction (weakening {env} T sublist) (weakening {env} S sublist) => {?}

  \func gather-closure {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                       (f : env.FunctionalSymbol.symbol s)
                       (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                       (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure TrichromaticParallelReduction (choosing-A index) (choosing-B index))
    : Closure TrichromaticParallelReduction (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- purely technical concatenation of closures

  \func gather-closure-regular {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                               (f : env.FunctionalSymbol.symbol s)
                               (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                               (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (choosing-A index) (choosing-B index))
    : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- similar to above, don't want to think about it rn

}
