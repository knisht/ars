\import Confluence
\import Data.Bool
\import Data.List (++, List, nil)
\import Data.Or
\import Logic
\import Paths
\import Paths.Meta
\import Relation
\import TRS.HRS
\import Set.Fin
\import TRS.List
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort}
                         (term : Term envL c s) : Term (JointEnvironment envL envR) c s \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-pattern-term-left {Sort : \Set}
                                 (envL envR : Environment Sort)
                                 {s : Sort}
                                 {c : List Sort}
                                 (term : PatternTerm envL c s) : PatternTerm (JointEnvironment envL envR) c s \elim term
    | pattern-var index p => pattern-var index p
    | pattern-metavar m arguments coherence => pattern-metavar m arguments coherence
    | pattern-func f choosing => pattern-func (inl f) (\lam i => inject-pattern-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          (term : Term envR c s) : Term (JointEnvironment envL envR) c s \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func inject-pattern-term-right {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  {s : Sort}
                                  {c : List Sort}
                                  (term : PatternTerm envR c s) : PatternTerm (JointEnvironment envL envR) c s \elim term
    | pattern-var index p => pattern-var index p
    | pattern-metavar m arguments coherence => pattern-metavar m arguments coherence
    | pattern-func f choosing => pattern-func (inr f) (\lam i => inject-pattern-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | l => inject-pattern-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | r-is-not-generating m m-in-r => {?} -- technical

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | l => inject-pattern-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | r-is-not-generating => {?} -- technical

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL)
                   (R : SimpleHigherOrderTermRewritingSystem envR)
: SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules =>
    \let
      | injected-left-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-left {_} {envL} {envR} L.set-of-rules
      | injected-right-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-right {_} {envL} {envR} R.set-of-rules
    \in JointIndexedSet injected-left-set injected-right-set

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL)
                                  (R : SimpleHigherOrderTermRewritingSystem envR)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort}
                                         {context : List Sort} (A B : Term env context s) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {s} {context}) A B

\module Confluence \where {
  \class TheoremContext {
    | Sort : \Set
    | envL : Environment Sort
    | envR : Environment Sort
    | L : SimpleHigherOrderTermRewritingSystem envL
    | R : SimpleHigherOrderTermRewritingSystem envR
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (RewriteRule (colored-env color)) \elim color
      | red => L.set-of-rules
      | blue => R.set-of-rules

    \func monochrome-reduction {_ : TheoremContext} (color : Color) {context : List Sort} {s : Sort} (A B : Term (colored-env color) context s): \Prop
    \elim color
      | red => RewriteRelation {envL} L.set-of-rules A B
      | blue => RewriteRelation {envR} R.set-of-rules A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort} {s : Sort} (t : Term (colored-env color) context s) : Term env context s \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort} {s : Sort} (term : Term env context s) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      | _, metavar _ _ => uncolored-metavar-root
      | _, var _ _ => uncolored-var-root

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR
  }

  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red
  }

  \open TheoremContext

  \data ColoredParallelReduction {tc : TheoremContext} (color : Color) (context : List Sort) (s : Sort) (A B : Term env context s)
    | rewrite-top-level (U V : Term (colored-env color) context s)
                        (monochrome-reduction color U V)
                        (subst : MetaSubstitution env context)
                        (\Pi (m : MetaVariable {Sort}) -> HasColoredRoot (Color.flip color) (subst m))
                        (MetaSubstitution.apply {env} (inject-monochrome-term color U) (SubList.identity context) subst = A)
                        (MetaSubstitution.apply {env} (inject-monochrome-term color V) (SubList.identity context) subst = B)
    | rewrite-subterms (U : Term (colored-env color) context s)
                       (substLeft substRight : MetaSubstitution env context)
                       (\Pi (m : MetaVariable {Sort}) ->
                           (ColoredParallelReduction (Color.flip color) (m.m-domain ++ context) m.sort (substLeft m) (substRight m)))
                       (MetaSubstitution.apply {env} (inject-monochrome-term color U) (SubList.identity context) substLeft = A)
                       (MetaSubstitution.apply {env} (inject-monochrome-term color U) (SubList.identity context) substRight = B)
}


