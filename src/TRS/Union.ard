\import Algebra.Ring.Localization
\import Confluence
\import Data.Bool
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.Union.TopLevel
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort} {meta-signature : MetaSignature Sort}
                         (term : Term envL c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          {meta-signature : MetaSignature Sort}
                          (term : Term envR c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | l-is-func => promote-injection-left {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-left {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envL context s meta-signature)
                                   (t-is-func : FunctionalRoot {envL} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-left envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | l-is-func => promote-injection-right {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-right {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envR context s meta-signature)
                                   (t-is-func : FunctionalRoot {envR} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-right envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\func JointRules {Sort : \Set} {envL envR : Environment Sort}
                 (L-rules : IndexedSet (RewriteRule envL))
                 (R-rules : IndexedSet (RewriteRule envR))
  : IndexedSet (RewriteRule (JointEnvironment envL envR)) =>
  \let
    | injected-left-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-left {_} {envL} {envR} L-rules
    | injected-right-set : IndexedSet (RewriteRule (JointEnvironment envL envR)) => Injections.promote-indexed-set-right {_} {envL} {envR} R-rules
  \in JointIndexedSet injected-left-set injected-right-set

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                   (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
: SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules => JointRules {_} {envL} {envR} L.set-of-rules R.set-of-rules
  | meta-signature => meta-signature

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                                  (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red

    \func double-flip (c : Color) : Color.flip (Color.flip c) = c \elim c
      | red => idp
      | blue => idp

    \func flip-contradiction {c : Color} (eq : c = flip c) : Empty \elim c
      | red => contradiction
      | blue => contradiction
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : Environment Sort'
    | envR : Environment Sort'
    | L-rules : IndexedSet (LinearRewriteRule envL)
    | R-rules : IndexedSet (LinearRewriteRule envR)
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (LinearRewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term (colored-env {tc} color) context s meta-signature): \Type =>
      RewriteRelation {colored-env color} (colored-set-of-rules color) A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (t : Term (colored-env color) context s meta-signature) : Term env context s meta-signature \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t
      \where {
        \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {msig : MetaSignature Sort'} (t : Term env context s msig) \elim t
          | func f choosing => iw-func (color-of-root {tc} f = color)
                                       (\Pi (i : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> InjectionWitness {tc} color (choosing i))
          | metavar m choosing => iw-mvar (\Pi (i : Fin (length (msig.m-domain m))) -> InjectionWitness {tc} color (choosing i))
          | var _ _ => iw-var

        \func generate-injection-witness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                         (t : Term (colored-env color) context s meta-signature) : InjectionWitness color (inject-monochrome-term color t) \elim color, t
          | red, func f choosing => iw-func idp (\lam i => generate-injection-witness red (choosing i))
          | red, var index p => iw-var
          | red, metavar m choosing => iw-mvar (\lam i => generate-injection-witness red (choosing i))
          | blue, var index p => iw-var
          | blue, metavar m choosing => iw-mvar (\lam i => generate-injection-witness blue (choosing i))
          | blue, func f choosing => iw-func idp (\lam i => generate-injection-witness blue (choosing i))
      }

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (term : Term env context s meta-signature) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      \where {
        \func equalize-colors {tc : TheoremContext} (color color' : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                              (f : env.FunctionalSymbol.symbol s)
                              (choosing choosing' : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env (context ++ (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index)) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                              (hcl1 : HasColoredRoot color (func f choosing))
                              (hcl2 : HasColoredRoot color' (func f choosing'))
          : color = color' \elim color, color', f, hcl1, hcl2
          | red, red, inl s1, red-func-root, red-func-root => idp
          | blue, blue, inr s1, blue-func-root, blue-func-root => idp
          | red, blue, inr b, (), hcl2
          | blue, red, inl a, (), hcl2

        \func reorganize {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                         {f : env.FunctionalSymbol.symbol s}
                         {choosing : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env (context ++ (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index)) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                         (hcl : HasColoredRoot color (func f choosing))
          : color-of-root f = color \elim color, f, hcl
          | red, inl s1, red-func-root => idp
          | blue, inr s1, blue-func-root => idp
      }
    --      | _, metavar _ _ => uncolored-metavar-root

    \data HasMetaRoot {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (term : Term env context s meta-signature) \elim term
      | metavar _ _ => has-meta-root

    \func color-of-root {_ : TheoremContext} {s : Sort'} (f : env.FunctionalSymbol.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR

    \func colored-rules {tc : TheoremContext} (color : Color) : IndexedSet (RewriteRule (env {tc})) \elim color
      | red => Injections.promote-indexed-set-left {tc.Sort'} {tc.envL} {tc.envR} (L-rules)
      | blue => Injections.promote-indexed-set-right {tc.Sort'} {tc.envL} {tc.envR} (R-rules)
  }

  \open TheoremContext

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} (A B : Term env context s meta-signature) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot {tc} color A) (step : LinearRewriteStep {env {tc}} A B) --(step.rule IndexedSet.in {LinearRewriteRule step.env} (colored-rules coor)) todo
    | func (f-A : symbol {FunctionalSymbol {env {tc}}} s) choosing-A, func (f-B : symbol {FunctionalSymbol {env {tc}}} s) choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root {tc} f-A = color)
                                     (ReductionAtIndex {env {tc}}
                                         (TopLevelColoredReduction {tc} color {meta-signature})
                                         (\lam i => (context ++ {Sort {env {tc}}} f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i))
                                         (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} __)
                                         choosing-A
                                         (transport-chooser-f {env {tc}} p choosing-B))
    \where {
      \func extract-root-coloring {tc : TheoremContext} {color : Color} {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} {A B : Term env context s meta-signature} (tlcr : TopLevelColoredReduction color A B) : HasColoredRoot color A
      \elim color, A, B, tlcr
        | color, A, B, rewrite-with-rule-colored h _ => h
        | color, func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => \case \elim color, \elim f-A, \elim choosing-A, \elim p1 \with {
          | red, inl a, choosing-A, p1 => red-func-root
          | blue, inr b, choosing-A, p1 => blue-func-root
        }
    }

  \data BorderedParallelReduction {tc : TheoremContext}
                                  (global-color : Color)
                                  (color : Maybe Color)
                                  {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
                                  (A B : Term (env {tc}) context s meta-signature) \elim A
    | A => equal-trees (A = B)
    | func f choosing =>
    parallelization-f
      (mediator : \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) ->
          Term (env {tc}) (context ++ (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index)) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
      (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f) -> \Sigma
        (someColor : Maybe Color)
        ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f))))
        (BorderedParallelReduction {tc} global-color someColor (choosing i) (mediator i)))
      (ColorwiseReduction {tc} global-color color (func f mediator) B)
    \where {
      \func append-tlcr
        {tc : TheoremContext}
        {global-color : Color}
        {color : Maybe Color}
        {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
        (A B : Term env context s meta-signature)
        (bpr : BorderedParallelReduction global-color color A B)
        (C : Term env context s meta-signature)
        (B~>*C : TClosure (TopLevelColoredReduction global-color) B C)
        : \Sigma (someColor : Maybe Color) (BorderedParallelReduction global-color someColor A C) \elim color, A, bpr
        | color, A, equal-trees p => \let hcr => TopLevelColoredReduction.extract-root-coloring (TClosure.extract B~>*C).2 \in \case \elim A, \elim B, \elim global-color, \elim B~>*C, \elim hcr, \elim p \with {
          | A, func (inl s1) choosing, red, B~>*C, red-func-root, idp => (just red, parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite B~>*C idp))
          | A, func (inr s1) choosing, blue, B~>*C, blue-func-root, idp => (just blue, parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite B~>*C idp))
        }
        | nothing, func f choosing, parallelization-f mediator _x (cr-skip p) => (just global-color, parallelization-f mediator _x (cr-rewrite (rewrite p B~>*C) idp))
        | just a, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => (just global-color, parallelization-f mediator _x (cr-rewrite (TClosure.compose (rewrite p t) B~>*C) idp))
    }

  \data ColorwiseReduction {tc : TheoremContext}
                           {context : List Sort'}
                           {s : Sort'}
                           {meta-signature : MetaSignature Sort'}
                           (global-color : Color)
                           (color : Maybe Color) (A B : Term env context s meta-signature) \elim color
    | nothing => cr-skip (A = B)
    | just color => cr-rewrite (TClosure (TopLevelColoredReduction {tc} color) A B) (global-color = color)

  \func TrichromaticParallelReduction {tc : TheoremContext} {meta-signature : MetaSignature Sort'} {context : List tc.Sort'} {s : Sort'} (A B : Term env context s meta-signature) : \Type =>
    \Sigma (global-color : Color) (color : Maybe Color) (BorderedParallelReduction global-color color A B)

  \func ConfluentialSystem (env : Environment) (rules : IndexedSet (RewriteRule env)) : \Type =>
    \Pi {meta-signature : MetaSignature Sort} {context : List Sort} {s : Sort}
        (A B C : Term env context s meta-signature)
        (TClosure (RewriteRelation rules) A B)
        (TClosure (RewriteRelation rules) A C) -> StraightJoin B C (TClosure (RewriteRelation rules))

  \func bpr-confluence {tc : TheoremContext} {gc1 gc2 : Color} (color1 color2 : Maybe Color) {context : List tc.Sort'} {s : Sort'}
                       {A B C : PureTerm env context s}
                       (A~>B : BorderedParallelReduction gc1 color1 A B)
                       (A~>C : BorderedParallelReduction gc2 color2 A C)
                       (left-confluence : ConfluentialSystem envL L-rules)
                       (right-confluence : ConfluentialSystem envR R-rules)
    : \Sigma (D : PureTerm env context s)
             (color3 : Maybe Color)
             (color4 : Maybe Color)
             (BorderedParallelReduction gc2 color3 B D)
             (BorderedParallelReduction gc1 color4 C D) \elim color1, color2, A, B, C, A~>B, A~>C
    | color1, color2, A, B, C, equal-trees p, rd => (C, color2, color1, rewriteI p rd, equal-trees idp)
    | color1, color2, A, B, C, rd, equal-trees p => (B, color2, color1, equal-trees idp, rewriteI p rd)
    | nothing, nothing, func f choosing, B, C, parallelization-f mediator choosing->med (cr-skip famed=B), parallelization-f mediator' choosing->med' (cr-skip famed'=C)
    => \let | inner-confluences i => bpr-confluence (choosing->med i).1 (choosing->med' i).1 (choosing->med i).3 (choosing->med' i).3 left-confluence right-confluence
            | D => func {env} f (\lam i => (inner-confluences i).1)
            | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).2, (inner-confluences i).4))
            | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).3, (inner-confluences i).5))
       \in (func f (\lam i => (inner-confluences i).1),
            color-1,
            color-2,
            rewriteI famed=B (parallelization-f mediator-1 inrd-1 cwr-1),
            rewriteI famed'=C (parallelization-f mediator-2 inrd-2 cwr-2))
    | nothing, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-skip p), parallelization-f mediator' choosing=>med' (cr-rewrite med'~>C gc2=right-color) =>
      \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
           | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
           | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
           | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
           | rd : BorderedParallelReduction gc2 color-1 (func f mediator) (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-1 inrd-1 cwr-1
           | (rightmost-reduct, flr~>rr, mcl, C=>rr) => unify-top right-color gc1 f mediator' mediator-2 C med'~>C inrd-2
           | (X, c1, B=>X, c2, C=>X) => unwrap-cwr (func f mediator) C (func f mediator-2) (first-level-reduct) (rightmost-reduct) cwr-2 (rewrite (gc2=right-color) flr~>rr) rd C=>rr left-confluence right-confluence
      \in (X,
           c1,
           c2,
           rewriteI p B=>X,
           C=>X)
    | just left-color, nothing, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-skip p) =>
      \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
           | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
           | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
           | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
           | (leftmost-reduct, flr~>lr, mcl, B=>lr) => unify-top left-color gc2 f mediator mediator-1 B med~>B inrd-1
           | rd : BorderedParallelReduction gc1 color-2 (func f mediator') (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-2 inrd-2 cwr-2
           | (X, c1, C=>X, c2, B=>X) => unwrap-cwr (func f mediator') B (func f mediator-1) (first-level-reduct) (leftmost-reduct) cwr-1 (rewrite (gc1=left-color) flr~>lr) rd B=>lr left-confluence right-confluence
      \in (X,
           c2,
           c1,
           B=>X,
           rewriteI p C=>X)
    | just left-color, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-rewrite med~>C gc2=right-color)
    => \let
        | hcl-f-left : HasColoredRoot left-color (func f mediator) => TopLevelColoredReduction.extract-root-coloring (TClosure.extract med~>B).2
        | hcl-f-right : HasColoredRoot right-color (func f mediator') => TopLevelColoredReduction.extract-root-coloring (TClosure.extract med~>C).2
        | lcolor=rcolor : left-color = right-color => HasColoredRoot.equalize-colors left-color right-color f mediator mediator' hcl-f-left hcl-f-right
        | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
        | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
        | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
        | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
        | rd : BorderedParallelReduction gc2 color-1 (func f mediator) (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-1 inrd-1 cwr-1
        | rd' : BorderedParallelReduction gc1 color-2 (func f mediator') (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-2 inrd-2 cwr-2
        | (leftmost-reduct, flr~>lr, clr-b, B=>lr) => unify-top left-color left-color f mediator mediator-1 B med~>B (rewrite (lcolor=rcolor *> inv gc2=right-color) inrd-1)
        | (rightmost-reduct, flr~>rr, clr-c, C=>rr) => unify-top right-color right-color f mediator' mediator-2 C med~>C (rewrite (inv lcolor=rcolor *> inv gc1=left-color) inrd-2)
        | (X, c1, B=>X, c2, C=>X) => unwrap-double-cwr B C (func f mediator-1) (func f mediator-2) first-level-reduct leftmost-reduct rightmost-reduct (rewrite (inv gc2=right-color) cwr-1) (rewrite (inv lcolor=rcolor *> inv gc1=left-color) cwr-2) (rewriteI lcolor=rcolor flr~>lr) flr~>rr (rewriteI lcolor=rcolor B=>lr) C=>rr left-confluence right-confluence
       \in (X, c1, c2, (rewrite gc2=right-color B=>X), rewrite (gc1=left-color *> lcolor=rcolor) C=>X)
    \where {
      \func unwrap-cwr
        {tc : TheoremContext} {gc1 gc2 : Color} {color3 color4 : Maybe Color} {context : List tc.Sort'} {s : Sort'}
        (T1 T2 A B C : PureTerm env context s) {color-2 : Maybe Color}
        (cwr : ColorwiseReduction gc1 color-2 A B) (A~>*C : TClosure (TopLevelColoredReduction gc2) A C)
        (T1=>B : BorderedParallelReduction gc2 color3 T1 B) (T2=>C : BorderedParallelReduction gc1 color4 T2 C)
        (left-confluence : ConfluentialSystem envL L-rules)
        (right-confluence : ConfluentialSystem envR R-rules)
        :
        \Sigma (X : PureTerm env context s) (c1 : Maybe Color) (BorderedParallelReduction gc2 c1 T1 X) (c2 : Maybe Color) (BorderedParallelReduction gc1 c2 T2 X) \elim color-2, cwr
        | nothing, cr-skip p => \let (cl-1, t1=>X) => BorderedParallelReduction.append-tlcr T1 B T1=>B C (rewriteI p A~>*C) \in (C, cl-1, t1=>X, color4, T2=>C)
        | just color, cr-rewrite A~>*B p =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs color gc2 A~>*B A~>*C left-confluence right-confluence
               | (cl-1, t1=>X) => BorderedParallelReduction.append-tlcr T1 B T1=>B X B~>*X
               | (cl-2, t2=>X) => BorderedParallelReduction.append-tlcr T2 C T2=>C X (rewrite p C~>*X)
          \in (X, cl-1, t1=>X, cl-2, t2=>X)

      \func unwrap-double-cwr
        {tc : TheoremContext} {gc1 : Color} {color3 color4 : Maybe Color} {context : List tc.Sort'} {s : Sort'}
        (T1 T2 A A' E B C : PureTerm env context s) {color-2 color-1 : Maybe Color}
        (cwr-1 : ColorwiseReduction gc1 color-2 A E)
        (cwr-2 : ColorwiseReduction gc1 color-1 A' E)
        (A~>*B : TClosure (TopLevelColoredReduction gc1) A B)
        (A'~>*C : TClosure (TopLevelColoredReduction gc1) A' C)
        (T1=>B : BorderedParallelReduction gc1 color3 T1 B)
        (T2=>C : BorderedParallelReduction gc1 color4 T2 C)
        (left-confluence : ConfluentialSystem envL L-rules)
        (right-confluence : ConfluentialSystem envR R-rules)
        :
        \Sigma (X : PureTerm env context s) (c1 : Maybe Color) (BorderedParallelReduction gc1 c1 T1 X) (c2 : Maybe Color) (BorderedParallelReduction gc1 c2 T2 X) \elim color-2, color-1, cwr-1, cwr-2
        | nothing, nothing, cr-skip p, cr-skip p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 A~>*B (rewrite {1} (p *> inv p1) A'~>*C) left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | nothing, just color, cr-skip p, cr-rewrite A'~>*E p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 (TClosure.compose (transport (\lam cl => TClosure (TopLevelColoredReduction cl) A' E) (inv p1) A'~>*E) (rewrite {1} (inv p) A~>*B)) A'~>*C left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | just color, nothing, cr-rewrite A~>*E p, cr-skip p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 A~>*B (TClosure.compose ((transport (\lam cl => TClosure (TopLevelColoredReduction cl) A E) (inv p) A~>*E)) (rewrite {1} (inv p1) A'~>*C)) left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | just color, just color1, cr-rewrite A~>*E p, cr-rewrite A'~>*E p1 =>
          \let | (M1, B~>*M1, E~>*M1) => join-different-tlcrs gc1 gc1 (A~>*B) (rewrite p A~>*E) left-confluence right-confluence
               | (M2, E~>*M2, C~>*M2) => join-different-tlcrs gc1 gc1 (transport (\lam cl => TClosure (TopLevelColoredReduction cl) A' E) (inv p1) A'~>*E) A'~>*C left-confluence right-confluence
               | (X, M1~>*X, M2~>*X) => join-different-tlcrs gc1 gc1 E~>*M1 E~>*M2 left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X (TClosure.compose B~>*M1 M1~>*X)
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X (TClosure.compose C~>*M2 M2~>*X)
          \in (X, c1, T1=>X, c2, T2=>X)

      \func reorganize-colors-here {tc : TheoremContext} {gc : Color} {someColor : Maybe Color} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                   {A B : Term env context s meta-signature} (A~>B : BorderedParallelReduction gc someColor A B)
        : \Sigma (someColor' : Maybe Color) (Or (someColor' = nothing) (someColor' = just gc)) (BorderedParallelReduction gc someColor' A B) \elim someColor, A, A~>B
        | _, A, equal-trees p => (nothing, inl idp, equal-trees p)
        | nothing, func f choosing, rd => (nothing, inl idp, rd)
        | just a, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => (just a, rewrite p (inr idp), parallelization-f mediator _x (cr-rewrite t p))

      \func join-different-tlcrs {tc : TheoremContext} (color1 color2 : Color) {context : List tc.Sort'} {s : Sort'}
                                 {A B C : PureTerm env context s}
                                 (A~>B : TClosure (TopLevelColoredReduction color1) A B)
                                 (A~>C : TClosure (TopLevelColoredReduction color2) A C)
                                 (left-confluence : ConfluentialSystem envL L-rules)
                                 (right-confluence : ConfluentialSystem envR R-rules)
        : \Sigma (X : PureTerm env context s) (TClosure (TopLevelColoredReduction color2) B X) (TClosure (TopLevelColoredReduction color1) C X)
      \elim color1, color2
        | red, red => join-tlcrs red A B C A~>B A~>C left-confluence
        | red, blue => \let | a => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>B).2
                            | b => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>C).2 \in \case \elim A, \elim a, \elim b \with {
          }
        | blue, red => \let | a => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>B).2
                            | b => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>C).2 \in \case \elim A, \elim a, \elim b \with {
          }
        | blue, blue => join-tlcrs blue A B C A~>B A~>C right-confluence

      \func gather-reduction {tc : TheoremContext}
                             (color : Color)
                             (sclr : Maybe Color)
                             (eq : (sclr = nothing) `Or` (sclr = just color))
                             {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {B lr X : Term env context s meta-signature}
                             (B=>lr : BorderedParallelReduction color sclr B lr)
                             (lr~>X : TClosure (TopLevelColoredReduction color) lr X)
        : BorderedParallelReduction color (just color) B X
      \elim sclr, eq, B, B=>lr
        | sclr, _, B, equal-trees p => \let x => TopLevelColoredReduction.extract-root-coloring (TClosure.extract lr~>X).2 \in \case \elim color, \elim lr, \elim x, \elim p, \elim lr~>X \with {
          | red, func (inl f) choosing, red-func-root, p, lr~>X => rewrite p (parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite lr~>X idp))
          | blue, func (inr f) choosing, blue-func-root, p, lr~>X => rewrite p (parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite lr~>X idp))
        }
        | nothing, inl a, func f choosing, parallelization-f mediator _x (cr-skip p) => parallelization-f mediator _x (cr-rewrite (rewrite p lr~>X) idp)
        | just a1, inl a, func f choosing, parallelization-f mediator _x c => contradiction
        | nothing, inr b, func f choosing, parallelization-f mediator _x c => contradiction
        | just a, inr b, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => parallelization-f mediator _x (cr-rewrite (TClosure.compose (rewriteI (Maybe.unjust-eq b) t) lr~>X) idp)

      \func twist-colors {c1 c2 c3 : Maybe Color} (c1or : Or (c1 = nothing) (c1 = c2)) (c2or : Or (c2 = nothing) (c2 = c3)) : Or (c1 = nothing) (c1 = c3) \elim c1or
        | inl a => inl a
        | inr b => rewrite b c2or

      \func twist-colors' {c1 c2 c3 : Maybe Color} (c1or : Or (c1 = c2) (c1 = nothing)) (c2or : Or (c2 = nothing) (c2 = c3)) : Or (c1 = nothing) (c1 = c3) \elim c1or
        | inl a => rewrite a c2or
        | inr b => inl b
    }

  \func unify-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color color' : Color)
                  (f : env.FunctionalSymbol.symbol s)
                  (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> PureTerm env (context ++ (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index)) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
                  (B : PureTerm env context s)
                  (A~>B : TClosure (TopLevelColoredReduction color) (func {env} f choosing-A) B)
                  (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f) ->
                      \Sigma (someColor : Maybe Color)
                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
                             (BorderedParallelReduction {tc} color' someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
    : \Sigma (X : PureTerm env context s)
             (TClosure (TopLevelColoredReduction color) (func {env} f choosing-C) X)
             (mcolor : Maybe Color)
             (BorderedParallelReduction color' mcolor B X) =>
    \let
      | (t, rho, t[rho]=A, root-colors) => decompose-term color (func f choosing-A)
      | (u, lu[rho]=B, t~>*u) => iterate-decomposition (LinearTerm.convert-to-term {colored-env color} t) rho B (rewrite unwrap-injection t[rho]=A) A~>B root-colors
      | injected-u : Term env context s (LinearMetasignatureT {colored-env color} (t)) => inject-monochrome-term color u
      | eqs3 : (func {env} f choosing-A) = (MetaSubstitution.apply {env} (convert-to-injected-term color t) sublist-trivial rho) => inv t[rho]=A
      | witnesses => inject-linear-term.generate-injection-witness color t
      | (sigma, C=t[sigma], reds) => alternate-subst {_} color color' (func f choosing-C) t rho (root-colors) nothing (inl idp) (rewriteI eqs3 (parallelization-f choosing-C inner-reductions (cr-skip idp)))
      | uni-right => TClosure.lift {_} {_} {monochrome-reduction color} {TopLevelColoredReduction color} (\lam trm => (MetaSubstitution.apply {env} (inject-monochrome-term color trm) sublist-trivial sigma)) (lift-relation color sigma) (LinearTerm.convert-to-term {colored-env color} t) u t~>*u
      | (mcl, uni-left) => unify-left color' color injected-u (inject-monochrome-term.generate-injection-witness color u) sublist-trivial rho sigma reds
    \in ((MetaSubstitution.apply {env} injected-u sublist-trivial sigma),
         (rewrite C=t[sigma] (rewriteI unwrap-injection uni-right)),
         mcl,
         (rewriteI lu[rho]=B uni-left))
    \where {
      \func iterate-decomposition
        {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-msig meta-signature : MetaSignature Sort'}
        {color : Color}
        (t : Term (colored-env {tc} color) context s inner-msig)
        (rho : MetaSubstitution env nil inner-msig meta-signature)
        {A : Term env context s meta-signature}
        (B : Term env context s meta-signature)
        (teq : (MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist-trivial rho) = A)
        (A~>*B : TClosure (TopLevelColoredReduction color) A B)
        (root-colors : \Pi {s : Sort'} (m : inner-msig.metaname s) -> HasColoredRoot (Color.flip color) (rho m))
        : \Sigma (u : Term (colored-env {tc} color) context s inner-msig)
                 (MetaSubstitution.apply {env} (inject-monochrome-term color u) sublist-trivial rho = B)
                 (TClosure (monochrome-reduction color) (t) u) \elim A~>*B
        | tc-basic A~>B =>
          \let | (u, lu[rho]=B, t~>u) => decompose-along-reduction color t B rho root-colors (rewrite teq A~>B)
          \in (u, lu[rho]=B, tc-basic t~>u)
        | tc-connect C A->C C~>*B =>
          \let | (c, meq, rd) => decompose-along-reduction color t C rho root-colors (rewrite teq A->C)
               | (u, mu, tcl) => iterate-decomposition c rho B (meq) (C~>*B) root-colors \in (u, mu, tc-connect c rd tcl)

      \func convert-to-injected-term {tc : Confluence.TheoremContext} (color : Confluence.Color) {context : List Confluence.Sort'} {s : Confluence.Sort'} (term : LinearTerm (colored-env color) context s) : Term env context s (LinearMetasignatureT {colored-env color} (term)) \elim color, term
        | red, lt-func f choosing => func (inl f) (\lam i => LinearTerm.upgrade-metavariables-t {env} (\lam i => LinearMetasignatureT {envL} (choosing i)) (convert-to-injected-term red (choosing i)))
        | red, lt-full-metavar => metavar idp (\lam i => var i idp)
        | red, lt-var index p => var index p
        | blue, lt-func f choosing => func (inr f) (\lam i => LinearTerm.upgrade-metavariables-t {env} (\lam i => LinearMetasignatureT {envR} (choosing i)) (convert-to-injected-term blue (choosing i)))
        | blue, lt-full-metavar => metavar idp (\lam i => var i idp)
        | blue, lt-var index p => var index p

      \func unwrap-injection {tc : TheoremContext} {color : Color} {context : List Sort'} {s : Sort'} (t : LinearTerm (colored-env color) context s) :
        inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t) = convert-to-injected-term color {context} {s} t \elim color, t
        | red, lt-func f choosing => pmap (func {env} (inl f))
            (ext (\lam index => rewriteI (unwrap-injection {_} {red} (choosing index)) (swap red (\lam i => LinearMetasignatureT {envL} (choosing i)) (LinearTerm.convert-to-term {envL} (choosing index)))))
        | red, lt-full-metavar => idp
        | red, lt-var index p => idp
        | blue, lt-func f choosing => pmap (func {env} (inr f))
            (ext (\lam index => rewriteI (unwrap-injection {_} {blue} (choosing index)) (swap blue (\lam i => LinearMetasignatureT {envR} (choosing i)) (LinearTerm.convert-to-term {envR} (choosing index)))))
        | blue, lt-full-metavar => idp
        | blue, lt-var index p => idp
        \where {
          \func swap
            {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {n : Nat} {i : Fin n} (msigs : \Pi (i : Fin n) -> MetaSignature Sort')
            (t : Term (colored-env color) context s (msigs i)) :
            inject-monochrome-term color (LinearTerm.upgrade-metavariables-t {colored-env color} msigs t) =
            LinearTerm.upgrade-metavariables-t {env} msigs (inject-monochrome-term color t) \elim color, t
            | red, var index p => idp
            | red, metavar m choosing =>
              \let extt : (\lam i1 => Injections.inject-term-left tc.envL tc.envR (LinearTerm.upgrade-metavariables-t {envL} msigs (choosing i1))) = (\lam i1 => (LinearTerm.upgrade-metavariables-t {env} msigs (Injections.inject-term-left tc.envL tc.envR (choosing i1)))) => ext (\lam i => swap red msigs (choosing i))
              \in rewrite extt idp
            | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => (swap red msigs (choosing index))))
            | blue, var index p => idp
            | blue, metavar m choosing =>
              \let extt : (\lam i1 => Injections.inject-term-right tc.envL tc.envR (LinearTerm.upgrade-metavariables-t {envR} msigs (choosing i1))) = (\lam i1 => (LinearTerm.upgrade-metavariables-t {env} msigs (Injections.inject-term-right tc.envL tc.envR (choosing i1)))) => ext (\lam i => swap blue msigs (choosing i))
              \in rewrite extt idp
            | blue, func f choosing => pmap (func {env} (inr f)) (ext (\lam index => (swap blue msigs (choosing index))))
        }

      \func recreate-coloring-for-root {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {color : Color} {f : env.FunctionalSymbol.symbol s}
                                       {choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env (context ++ (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index)) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                                       (h : HasColoredRoot color (func f choosing-A)) : HasColoredRoot color (func f choosing-C) \elim color, f, h
        | red, inl s1, red-func-root => red-func-root
        | blue, inr s1, blue-func-root => blue-func-root
    }

  \func alternate-subst {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (gc rcolor : Color)
                        (C : Term env context s meta-signature)
                        (t : LinearTerm (colored-env gc) context s)
                        (rho : MetaSubstitution env nil (LinearMetasignatureT {colored-env gc} t) meta-signature)
                        (root-colors : \Pi {s1 : Sort'} -> \Pi (m : metaname {LinearMetasignatureT {colored-env gc} t} s1) -> HasColoredRoot (Color.flip gc) (rho m))
                        (someColor : Maybe Color)
                        (some-color-diff : (someColor = nothing) `Or` (someColor = just (Color.flip gc)))
                        (A=>C : BorderedParallelReduction rcolor someColor (MetaSubstitution.apply {env} ((unify-top.convert-to-injected-term gc {context} {s} t)) sublist-trivial rho) C)
    : \Sigma (sigma : MetaSubstitution env nil (LinearMetasignatureT {colored-env gc} t) meta-signature)
             (C = MetaSubstitution.apply {env} ((unify-top.convert-to-injected-term gc {context} {s} t)) (sublist-trivial) sigma)
             (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignatureT {colored-env gc} t} s) ->
                 \Sigma (mcolor : Maybe Color) (BorderedParallelReduction rcolor mcolor (rho m) (sigma m)))
  \elim gc, t, someColor, A=>C
    | red, lt-func f choosing, nothing, parallelization-f mediator inner-reductions (cr-skip p) =>
      \let
        | inductive-result i => alternate-subst red rcolor
            (mediator i) (choosing i)
            (\lam m => rho (i, m))
            (\lam {s1} m => root-colors (i, m))
            (inner-reductions i).1
            ((inner-reductions i).2)
            (rewrite (modular-commutation {env} (\lam j => LinearMetasignatureT {envL} (choosing j)) i sublist-trivial (unify-top.convert-to-injected-term red (choosing i)) rho)
                (rewrite (invariant-through-empty-subst {env} rho sublist-trivial (SubList.extend-right-single sublist-trivial) (LinearTerm.upgrade-metavariables-t {env}
                    (\lam j => LinearMetasignatureT {colored-env red} (choosing j)) (unify-top.convert-to-injected-term red (choosing i)))) (inner-reductions i).3))
      \in (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2,
           inv p *> (pmap (func {env} (inl f))
               (ext (\lam index => rewriteI
                   (modular-commutation {env} (\lam j => LinearMetasignatureT {envL} (choosing j)) index (SubList.extend-right-single sublist-trivial) (unify-top.convert-to-injected-term red (choosing index)) (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2))
                   (rewrite (invariant-through-empty-subst {env} ) (inductive-result index).2)))),
           \lam {s1} m => (inductive-result (m.1)).3 m.2)
    | red, lt-func f choosing, just color, parallelization-f mediator inner-reductions (cr-rewrite tlcr p) =>
      \let
        | coloring-from-tlcr => HasColoredRoot.reorganize color (TopLevelColoredReduction.extract-root-coloring (TClosure.extract tlcr).2)
        | extracted => coloring-from-tlcr *> extract-from-or some-color-diff
      \in contradiction
    | gc, lt-func f choosing, someColor, equal-trees p => (rho, inv p, \lam {s1} m => (nothing, equal-trees idp))
    | red, lt-full-metavar, someColor, rd =>
      ( \lam {s1} mvar => transport (Term env context __ meta-signature) (inv mvar) C,
        (inv (plain-identity-effect {env} C)),
        \lam {s1} m => \let | unified => unify-reduction rho C rd m  \in (someColor, unified))
    | red, lt-var index p, someColor, equal-trees p1 => (\lam {s1} mvar => contradiction, inv p1, \lam {s1} m => contradiction)
    | blue, _, _, _ => {?}
    \where {
      \func extract-from-or {A : \Type} {a b : A} (or : Or (just a = nothing) (just a = just b)) : a = b
        | inl a1 => contradiction
        | inr b1 => Maybe.unjust-eq b1

      \func unify-reduction {tc : TheoremContext} {gc : Color} {someColor : Maybe Color} {context : List Sort'} {s s' : Sort'} {meta-signature : MetaSignature Sort'}
                            (rho :  MetaSubstitution env nil (SingularMetaSignature {env} s context) meta-signature)
                            (C : Term env context s meta-signature)
                            (bpr : BorderedParallelReduction gc someColor (Substitution.apply {env}
                                (rho idp) (extend-substitution-left {env} sublist-trivial (\lam i => var i idp))) C)
                            (m : s' = s)
        : BorderedParallelReduction gc someColor (rho m)
          (transport (\lam (srt : Sort') => Term env context srt meta-signature) (inv m) C) \elim m
        | idp => (rewriteI (plain-identity-effect {env}) bpr)

      \func reorganize-colors {tc : TheoremContext} {gc gc' : Color} {someColor : Maybe Color} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                              {A B : Term env context s meta-signature} (A~>B : BorderedParallelReduction gc someColor A B) (or : (someColor = nothing) `Or` (someColor = just gc'))
        : \Sigma (someColor' : Maybe Color) (Or (someColor' = nothing) (someColor' = just (gc'))) (BorderedParallelReduction gc someColor' A B) \elim someColor, A, A~>B
        | _, A, equal-trees p => (nothing, inl idp, equal-trees p)
        | nothing, func f choosing, rd => (nothing, inl idp, rd)
        | just a, func f choosing, rd => (just a, or, rd)

      \func unwrap-func {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                        (T : Term env context s meta-signature) : Or Nat
          (\Sigma (f : env.FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
              Term env (context ++ (f FunctionalSignature.!!param index)) (f FunctionalSignature.!!sort index) meta-signature)) \elim T
        | var index p => inl 0
        | metavar m choosing1 => inl 0
        | func f1 choosing1 => inr (f1, choosing1)

      \func sigma-set-equalizer {A : \Set} (B : A -> \Type) {a : A} {b b' : B a} (p : (a,b) = {\Sigma (x : A) (B x)} (a,b')) : b = b' =>
        pmap (transport B __ b) (Path.inProp idp (pmap __.1 p)) *> pmapd (\lam t => B t.1) __.2 p

      \func apply-modularity {env : Environment} {context subst-context pattern-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n}
                             (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (pat-sublist : SubList pattern-context context)
                             (t : Term env pattern-context s (producer index)) :
        MetaSubstitution.apply (weakening t pat-sublist) sublist (substitutions index) = MetaSubstitution.apply (weakening (LinearPattern.upgrade-metavariables-p producer t) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim t
        | var index1 p => idp
        | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-left sublist e)) (ext (\lam i => apply-modularity producer substitutions sublist pat-sublist (choosing i)))
        | func f choosing => pmap (func f) (ext (\lam i => apply-modularity producer substitutions (SubList.extend-right-single sublist) (SubList.extend-right pat-sublist) (choosing i)))
    }

  \data TClosure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | tc-basic (a `R` b)
    | tc-connect (c : A) (a `R` c) (TClosure R c b)
    \where {
      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : TClosure Rel x y) : TClosure Rel' (map x) (map y) \elim closure
        | tc-basic r => tc-basic (rel-map r)
        | tc-connect c r closure => tc-connect (map c) (rel-map r) (lift map rel-map c y closure)

      \func compose {A : \Type} {R : A -> A -> \Type} {a b c : A} (a->b : TClosure R a b) (b->c : TClosure R b c) : TClosure R a c \elim a->b
        | tc-basic r => tc-connect b r b->c
        | tc-connect c1 r a->b => tc-connect c1 r (compose a->b b->c)

      \func extract  {A : \Type} {R : A -> A -> \Type} {a b : A} (cl : TClosure R a b) : \Sigma (c : A) (R a c) \elim cl
        | tc-basic r => (b, r)
        | tc-connect c r cl => (c, r)
    }

  \data Closure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | c-trivial (a = b)
    | c-basic (a `R` b)
    | c-connect (c : A) (a `R` c) (Closure R c b)
    \where {
      \func concat {A : \Type} {R : A -> A -> \Type} {a b c : A} (a~>b : Closure R a b) (b~>c : Closure R b c) : Closure R a c \elim a~>b, b~>c
        | c-basic r, rx => c-connect b r rx
        | c-connect c1 r a~>b, rx => c-connect c1 r (concat a~>b rx)
        | c-trivial idp, b~>c => b~>c

      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : Closure Rel x y) : Closure Rel' (map x) (map y) \elim closure
        | c-basic r => c-basic (rel-map r)
        | c-connect c r closure => c-connect (map c) (rel-map r) (lift map rel-map c y closure)
        | c-trivial idp => c-trivial idp

      \func flatten {A : \Type} {Rel : A -> A -> \Type}
                    {x y : A}
                    (closure : Closure (Closure Rel) x y) : Closure Rel x y \elim closure
        | c-basic r => r
        | c-connect c r closure => concat r (flatten closure)
        | c-trivial idp => c-trivial idp
    }

  \func unify-left {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {inner-metasignature : MetaSignature Sort'}
                   (gc anti-color : Color)
                   (s : Term env context' s inner-metasignature)
                   (witness : inject-monochrome-term.InjectionWitness anti-color s)
                   (sublist : SubList context context')
                   (rho sigma : MetaSubstitution env context inner-metasignature (EmptyMetasignature {env}))
                   (rho~>sigma : \Pi {s : Sort'} (m : inner-metasignature.metaname s) ->
                       \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (rho m) (sigma m))) :
    \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (MetaSubstitution.apply {env} s sublist rho) (MetaSubstitution.apply {env} s sublist sigma))
  \elim s, witness
    | var index p, _ => (nothing, equal-trees idp)
    | metavar m choosing, wit =>
      \let | main-reduction => rho~>sigma m
           | rho-subst => (extend-substitution-left {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho))
           | sigma-subst => (extend-substitution-left {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma))
           | target-reduction => reduction-over-substitution main-reduction.1 (rho m) (sigma m) main-reduction.2 rho-subst sigma-subst {?} -- extension of substitutions
      \in (target-reduction)
    | func f choosing, inject-monochrome-term.iw-func p _x =>
      \let | in-indices i => unify-left gc (color-of-root f) (choosing i) (rewrite p (_x i)) (SubList.extend-right-single sublist) rho sigma rho~>sigma
      \in (nothing, parallelization-f (\lam i => (MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single sublist) sigma)) (\lam i => ((in-indices i).1, {?}, (in-indices i).2)) (cr-skip idp))

  \func reduction-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'}
                                    {gc : Color}
                                    (color : Maybe Color)
                                    (A B : PureTerm env context s)
                                    (A=>B : BorderedParallelReduction gc color A B)
                                    (subst subst' : Substitution {env} context new-context (EmptyMetasignature {env}))
                                    (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    : \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (Substitution.apply {env} A subst) (Substitution.apply {env} B subst')) \elim color, A, A=>B
    | color, A, equal-trees p => rewrite p (distributed-reduction-for-substitution B color _ _ subst=>subst')
    | nothing, func f choosing, parallelization-f mediator _x (cr-skip p) =>
      \let | medium-reductions i => reduction-over-substitution  (_x i).1 (choosing i) (mediator i) (_x i).3 (append-context-right {env} subst) (append-context-right {env} subst') {?}
           | (sc, med, inrd, cwr) => (collect-reductions-together-raw f (\lam i => Substitution.apply {env} (choosing i) (append-context-right {env} subst)) (\lam i => Substitution.apply {env} (mediator i) (append-context-right {env} subst')) medium-reductions)
      \in rewriteI p (sc, (parallelization-f med inrd cwr))
    | just a, func f choosing, parallelization-f mediator _x (cr-rewrite tlcr p) =>
      \let | medium-reductions i => reduction-over-substitution (_x i).1 (choosing i) (mediator i) (_x i).3 (append-context-right {env} subst) (append-context-right {env} subst') {?}
      \in (collect-reductions-together-tlcr f (\lam i => Substitution.apply {env} (choosing i) (append-context-right {env} subst)) (\lam i => Substitution.apply {env} (mediator i) (append-context-right {env} subst')) medium-reductions (Substitution.apply {env} B subst') (rewrite p (TClosure.lift (\lam t => Substitution.apply {env} t subst') (\lam rel => tlcr-over-substitution subst' rel) (func {env} f mediator) B tlcr)))

  \func tlcr-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                               {A B : Term env context s meta-signature}
                               {color : Color}
                               (subst : Substitution {env} context new-context meta-signature)
                               (A~>B : TopLevelColoredReduction color A B)
    : TopLevelColoredReduction color (Substitution.apply {env} A subst) (Substitution.apply {env} B subst) \elim A, B, A~>B
    | A, B, rewrite-with-rule-colored h ((rule : LinearRewriteRule, msubst, msubst[l]=A, msubst[r]=B)) => rewrite-with-rule-colored {?} (\new LinearRewriteStep {
      | rule => rule
      | substitution m => Substitution.apply {env} (msubst m) (append-context-right {env} subst)
      | left-coherence => rewriteI msubst[l]=A {?} -- show that substitution is identical on context
      | right-coherence => rewriteI msubst[r]=B {?}
    })
    | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => {?}

  --  \func commutation {env : Environment} {context new-context : List Sort} {s : Sort} {inner-ms outer-ms : MetaSignature Sort}
  --                    (metasubst : MetaSubstitution env context inner-ms outer-ms)
  --                    (subst : Substitution context new-context outer-ms)
  --                    (t : Term env nil s inner-ms) :
  --    MetaSubstitution.apply (weakening t sublist-trivial) SubList.identity (\lam m => Substitution.apply (metasubst m) (append-context-left subst)) =
  --    Substitution.apply (MetaSubstitution.apply (weakening t sublist-trivial) SubList.identity metasubst) subst \elim t
  --    | var index p => \case \elim s, \elim p \with {
  --      | s, idp => {?}
  --    }
  --    | metavar m choosing => {?}
  --    | func f choosing => {?}

  \func distributed-reduction-for-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'}
                                               (A : PureTerm env context s)
                                               {gc : Color}
                                               (color : Maybe Color)
                                               (subst subst' : Substitution {env} context new-context (EmptyMetasignature {env}))
                                               (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    : \Sigma (color' : Maybe Color) (BorderedParallelReduction gc color' (Substitution.apply {env} A subst) (Substitution.apply {env} A subst')) \elim A
    | var index p => \case \elim s, \elim p \with {
      | s, idp => (subst=>subst' index)
    }
    | metavar m choosing => contradiction
    | func f choosing =>
      \let | inner-reductions i => distributed-reduction-for-substitution (choosing i) {gc} color (append-context-right {env} subst) (append-context-right {env} subst') {?}
           | (sc, med, inrd, cwr) => collect-reductions-together-raw f
               (\lam index => (Substitution.apply {env} (choosing index) (append-context-right {env} subst)))
               (\lam index => (Substitution.apply {env} (choosing index) (append-context-right {env} subst')))
               inner-reductions \in (sc, parallelization-f med inrd cwr)

  \func collect-reductions-together-tlcr
    {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
    {gc : Color}
    (f : env.FunctionalSymbol.symbol s)
    (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env (context ++ (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index)) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
    (tlcrs : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (choosing-A index) (choosing-B index)))
    (C : Term env context s meta-signature)
    (B~>*C : TClosure (TopLevelColoredReduction gc) (func {env} f choosing-B) C)
    : \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (func f choosing-A) C) => {?}

  \func collect-reductions-together-raw
    {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
    {gc : Color}
    (f : env.FunctionalSymbol.symbol s)
    (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env (context ++ (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index)) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
    (tlcrs : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (choosing-A index) (choosing-B index)))
    : \Sigma
    (someColor : Maybe Color)
    (mediator : \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) ->
        Term (env {tc}) (context ++ (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index)) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
    (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f) -> \Sigma
      (someColor : Maybe Color)
      ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f))))
      (BorderedParallelReduction {tc} gc someColor (choosing-A i) (mediator i)))
    (ColorwiseReduction {tc} gc someColor (func f mediator) (func f choosing-B)) => ({?}, choosing-A, {?}, {?})


  \func reduction-over-weakening {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (T S : Term env context s meta-signature)
                                 (T~>S : Closure TrichromaticParallelReduction T S)
                                 (sublist : SubList context new-context)
    : Closure TrichromaticParallelReduction (weakening {env} T sublist) (weakening {env} S sublist) => {?}
}
