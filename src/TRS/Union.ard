\import Confluence
\import Data.List (++, List, nil)
\import Data.Or
\import Logic
\import Paths
\import Paths.Meta
\import Relation
\import TRS.HRS
\import Set.Fin
\import TRS.List
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointMetaSignature (Sort : \Set) (A B : MetaSignature Sort) : MetaSignature Sort \cowith
  | metasymbol s => A.metasymbol s `Or` B.metasymbol s
  | metadomain metavar => \case \elim metavar \with {
    | inl a => A.metadomain a
    | inr b => B.metadomain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol
  | MetaVariable => JointMetaSignature Sort A.MetaVariable B.MetaVariable

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort}
                         (term : Term envL c s) : Term (JointEnvironment envL envR) c s \elim term
    | var index p => var index p
    | metavar m choosing => metavar (inl m) (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          (term : Term envR c s) : Term (JointEnvironment envL envR) c s \elim term
    | var index p => var index p
    | metavar m choosing => metavar (inr m) (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | r-is-not-generating m m-in-r => \case \elim m, \elim m-in-r \with {
      | inl m', m-in-r => \let | q => uninject-in envL envR rule.r m' m-in-r
                               | q' => rule.r-is-not-generating m' q \in {?}
      | inr b, m-in-r => {?}
    }
    \where {
      \func uninject-in {Sort : \Set}
                        (envL envR : Environment Sort)
                        {s s'' : Sort}
                        (term : Term envL nil s)
                        (m' : envL.MetaVariable.metasymbol s'')
                        (rel : (inl m') Term.in {JointEnvironment envL envR} (inject-term-left envL envR term))
        : m' Term.in term \elim term, rel
        | metavar m choosing, byLeft a => {?}
        | metavar m choosing, byRight b => {?}
        | func f choosing, inP a => {?}

      \func inject-in {Sort : \Set}
                      (envL envR : Environment Sort)
                      {s s'' : Sort}
                      (term : Term envL nil s)
                      (m' : envL.MetaVariable.metasymbol s'')
                      (rel : m' Term.in term)
        : (inl m') Term.in {JointEnvironment envL envR} (inject-term-left envL envR term) \elim term, rel
        | metavar m choosing, byLeft (q, p) => byLeft (q, {?})
        | metavar m choosing, byRight (n, prf) => byRight (n, inject-in envL envR (choosing n) m' prf)
        | func f choosing, inP a => {?}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | r-is-not-generating => {?}

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL)
                   (R : SimpleHigherOrderTermRewritingSystem envR)
: SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules =>
    \let
      | injected-left-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-left {_} {envL} {envR} L.set-of-rules
      | injected-right-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-right {_} {envL} {envR} R.set-of-rules
    \in JointIndexedSet injected-left-set injected-right-set

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL)
                                  (R : SimpleHigherOrderTermRewritingSystem envR)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort}
                                         {context : List Sort} (A B : Term env context s) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {s} {context}) A B

\module Confluence \where {
  \class TheoremContext {
    | Sort : \Set
    | envL : Environment Sort
    | envR : Environment Sort
    | L : SimpleHigherOrderTermRewritingSystem envL
    | R : SimpleHigherOrderTermRewritingSystem envR
  } \where {
    \func env {tc : TheoremContext} : Environment => JointEnvironment envL envR
  }

  \open TheoremContext

  \cons red {A B : \Type} (a : A) : A `Or` B => inl a

  \cons blue {A B : \Type} (b : B) : A `Or` B => inr b

  \data hasRedRoot {tc : TheoremContext}
                   {s : Sort} {context : List Sort} (t : Term env context s) \elim t
    | func (red _) _ => red-func
    | metavar (red _) _ => red-mvar

  \data hasBlueRoot {tc : TheoremContext}
                    {s : Sort} {context : List Sort} (t : Term env context s) \elim t
    | func (blue _) _ => blue-func
    | metavar (blue _) _ => blue-mvar

  \truncated \data ColoredParallelReduction {tc : TheoremContext}
                                            {s : Sort} {context : List Sort} (A B : Term env context s) : \Prop
    | leave-untouched
    | reduce-in-place-red (hasRedRoot A) (transitive-closure RedRewriteRelation A B)
    | reduce-in-place-blue (hasBlueRoot B) (transitive-closure BlueRewriteRelation A B)
    | spread-reduction (SpreadTransition A B)

  \data SpreadTransition {tc : TheoremContext}
                         {s : Sort} {context : List Sort} (A B : Term env context s) : \Set \elim A, B
    | func (red f-A) choosing-A, func (red f-B) choosing-B => distributed-reduction-red-f-f
      (p : f-A = f-B)
      (\Pi (i : F-param-index f-A) ->
          SingularTransition:Red->Blue {tc}
              (choosing-A i)
              ((transport-chooser-f {env {tc}} (pmap red p) choosing-B) i))
    | metavar (red m-A) choosing-A, metavar (red m-B) choosing-B => distributed-reduction-red-m-m
      (p : m-A = m-B)
      (\Pi (i : M-param-index m-A) ->
          SingularTransition:Red->Blue {tc}
              (choosing-A i)
              ((transport-chooser-m {env {tc}} (pmap red p) choosing-B) i))
    | func (blue f-A) choosing-A, func (blue f-B) choosing-B => distributed-reduction-blue-f-f
      (p : f-A = f-B)
      (\Pi (i : F-param-index f-A) ->
          SingularTransition:Blue->Red {tc}
              (choosing-A i)
              ((transport-chooser-f {env {tc}} (pmap blue p) choosing-B) i))
    | metavar (blue m-A) choosing-A, metavar (blue m-B) choosing-B => distributed-reduction-blue-m-m
      (p : m-A = m-B)
      (\Pi (i : M-param-index m-A) ->
          SingularTransition:Blue->Red {tc}
              (choosing-A i)
              ((transport-chooser-m {env {tc}} (pmap blue p) choosing-B) i))

  \truncated \data SingularTransition:Red->Blue {tc : TheoremContext}
                                                {s : Sort} {context : List Sort}
                                                (A B : Term env context s) : \Set
    | start-blue-reduction (hasBlueRoot A) (ColoredParallelReduction A B)
    | continue-red-spread (hasRedRoot A) (SpreadTransition A B)

  \data SingularTransition:Blue->Red {tc : TheoremContext}
                                     {s : Sort} {context : List Sort}
                                     (A B : Term env context s) : \Set
    | start-red-reduction (hasRedRoot A) (ColoredParallelReduction A B)
    | continue-blue-spread (hasBlueRoot A) (SpreadTransition A B)

  \truncated \data RedReductionAtIndex {tc : TheoremContext}
                                       {n : Nat}
                                       (contexts : Fin n -> List Sort)
                                       (sorts : Fin n -> Sort)
                                       (A B : \Pi (index : Fin n) -> Term env (contexts index) (sorts index)) : \Set \elim n
    | suc n => head-reduction-red (RedRewriteRelation {tc} (A fzero) (B fzero)) (\Pi (i : Fin n) -> A (fsuc i) = B (fsuc i))
    | suc n => tail-reduction-red (A fzero = B fzero)
                                  (RedReductionAtIndex {tc}
                                      (\lam i => contexts (fsuc i))
                                      (\lam i => sorts (fsuc i))
                                      (\lam i => A (fsuc i))
                                      (\lam i => B (fsuc i)))

  \truncated \data RedRewriteRelation {tc : TheoremContext} {s : Sort} {context : List Sort} (A B : Term env context s) : \Set \elim A, B
    | A, B => rewrite-with-rule-red (hasRedRoot {tc} A)
                                    (step : RewriteStep {env {tc}} A B)
                                    (step.rule IndexedSet.in (Injections.promote-indexed-set-left {Sort} {envL} {envR} L.set-of-rules))
    | func (red f-A) choosing-A, func (red f-B) choosing-B =>
    rewrite-with-parameter-f-red (p : f-A = f-B)
                                 (RedReductionAtIndex {tc}
                                     (f-A FunctionalSignature.!!param __ ++ context)
                                     (f-A FunctionalSignature.!!sort __)
                                     choosing-A
                                     (transport-chooser-f {env {tc}} (pmap red p) choosing-B))

    | metavar (red m-A) choosing-A, metavar (red m-B) choosing-B =>
    rewrite-with-parameter-m-red (p : m-A = m-B)
                                 (RedReductionAtIndex {tc}
                                     (\lam _ => context)
                                     (metadomain m-A !! __)
                                     choosing-A
                                     (transport-chooser-m {env {tc}} (pmap red p) choosing-B))

  \truncated \data BlueReductionAtIndex {tc : TheoremContext}
                                        {n : Nat}
                                        (contexts : Fin n -> List Sort)
                                        (sorts : Fin n -> Sort)
                                        (A B : \Pi (index : Fin n) -> Term env (contexts index) (sorts index)) : \Prop \elim n
    | suc n => head-reduction-blue (BlueRewriteRelation {tc} (A fzero) (B fzero)) (\Pi (i : Fin n) -> A (fsuc i) = B (fsuc i))
    | suc n => tail-reduction-blue (A fzero = B fzero)
                                   (BlueReductionAtIndex {tc}
                                       (\lam i => contexts (fsuc i))
                                       (\lam i => sorts (fsuc i))
                                       (\lam i => A (fsuc i))
                                       (\lam i => B (fsuc i)))

  \truncated \data BlueRewriteRelation {tc : TheoremContext} {s : Sort} {context : List Sort} (A B : Term env context s) : \Prop \elim A, B
    | A, B => rewrite-with-rule-blue (hasBlueRoot {tc} A)
                                     (step : RewriteStep {env {tc}} A B)
                                     (step.rule IndexedSet.in (Injections.promote-indexed-set-right {Sort} {envL} {envR} R.set-of-rules))
    | func (blue f-A) choosing-A, func (blue f-B) choosing-B =>
    rewrite-with-parameter-f-blue (p : f-A = f-B)
                                  (BlueReductionAtIndex {tc}
                                      (f-A FunctionalSignature.!!param __ ++ context)
                                      (f-A FunctionalSignature.!!sort __)
                                      choosing-A
                                      (transport-chooser-f {env {tc}} (pmap blue p) choosing-B))

    | metavar (blue m-A) choosing-A, metavar (blue m-B) choosing-B =>
    rewrite-with-parameter-m-blue (p : m-A = m-B)
                                  (BlueReductionAtIndex {tc}
                                      (\lam _ => context)
                                      (metadomain m-A !! __)
                                      choosing-A
                                      (transport-chooser-m {env {tc}} (pmap blue p) choosing-B))

  \data StraightJoin {A : \Set} (~> : A -> A -> \Set) (b c : A)
    | straight-join (d : A) (b `~> d) (c `~>` d)
    \where {
      \func common-reduct {A : \Set} {~> : A -> A -> \Set} {b c : A} (join : StraightJoin ~> b c) : A \elim join
        | straight-join d _ _ => d

      \func reduction-from-left {A : \Set} {~> : A -> A -> \Set} {b c : A} (join : StraightJoin ~> b c) : b `~>` (common-reduct join) \elim join
        | straight-join _ reduction _ => reduction

      \func reduction-from-right {A : \Set} {~> : A -> A -> \Set} {b c : A} (join : StraightJoin ~> b c) : c `~>` (common-reduct join) \elim join
        | straight-join _ _ reduction => reduction
    }

  \func parallel-reduction-confluence {tc : TheoremContext} {s : Sort} {context : List Sort}
                                      (a b c : Term env context s)
                                      (a~>b : ColoredParallelReduction a b)
                                      (a~>c : ColoredParallelReduction a c)
    : StraightJoin ColoredParallelReduction b c
  \elim a, b, c, a~>b, a~>c
    | a, b, c, leave-untouched eq, a~>c => straight-join c (transport (ColoredParallelReduction __ c) eq a~>c) (leave-untouched idp)
    | a, b, c, a~>b, leave-untouched eq => straight-join b (leave-untouched idp) (transport (ColoredParallelReduction __ b) eq a~>b)
    | a, b, c, reduce-in-place-red h t, reduce-in-place-red h1 t1 => {?}
    | a, b, c, reduce-in-place-red h t, reduce-in-place-blue h1 t1 => (root-has-unique-color {tc} a h h1)
    | a, b, c, reduce-in-place-red h t, spread-reduction s1 => {?}
    | a, b, c, reduce-in-place-blue h t, reduce-in-place-red h1 t1 => (root-has-unique-color {tc} a h1 h)
    | a, b, c, reduce-in-place-blue h t, reduce-in-place-blue h1 t1 => {?}
    | a, b, c, reduce-in-place-blue h t, spread-reduction s1 => {?}
    | a, b, c, spread-reduction s1, reduce-in-place-red h t => {?}
    | a, b, c, spread-reduction s1, reduce-in-place-blue h t => {?}
    | a, b, c, spread-reduction a~>b, spread-reduction a~>c => process-spread-reduction a b c a~>b a~>c

  \func process-spread-reduction {tc : TheoremContext} {s : Sort} {context : List Sort}
                                 (a b c : Term env context s)
                                 (a~>b : SpreadTransition a b) (a~>c : SpreadTransition a c)
    : StraightJoin ColoredParallelReduction b c \elim a, b, c, a~>b, a~>c
    | func (red f-A) choosing-A,
    func (red f-B) choosing-B,
    func (red f-C) choosing-C,
    distributed-reduction-red-f-f f-A=f-B pass-a-b,
    distributed-reduction-red-f-f f-A=f-C pass-a-c =>
      \let | joins (i : F-param-index f-A) : (StraightJoin (ColoredParallelReduction {tc}) (transport-chooser-f {env} (pmap red f-A=f-B) choosing-B i) (transport-chooser-f {env} (pmap red f-A=f-C) choosing-C i)) => \case (pass-a-b i), (pass-a-c i) \with {
        | start-blue-reduction h a_i~>b_i, start-blue-reduction h1 a_i~>c_i => parallel-reduction-confluence (choosing-A i) (transport-chooser-f {env} (pmap red f-A=f-B) choosing-B i) (transport-chooser-f {env} (pmap red f-A=f-C) choosing-C i) a_i~>b_i a_i~>c_i
        | start-blue-reduction h c, continue-red-spread h1 s1 => root-has-unique-color (choosing-A i) h1 h
        | continue-red-spread h s1, start-blue-reduction h1 c => root-has-unique-color (choosing-A i) h h1
        | continue-red-spread h s1, continue-red-spread h1 s2 => process-spread-reduction {tc} (choosing-A i) (transport-chooser-f {env} (pmap red f-A=f-B) choosing-B i) (transport-chooser-f {env} (pmap red f-A=f-C) choosing-C i) s1 s2
      }
           | common-term : Term env context s => func (red f-A) (\lam i => StraightJoin.common-reduct (joins i)) \in straight-join common-term (spread-reduction (distributed-reduction-red-f-f (inv f-A=f-B) (\lam i => {?}))) {?}

    | func (blue f-A) choosing-A, func (blue f-B) choosing-B, func (blue f-C) choosing-C, distributed-reduction-blue-f-f _ _, distributed-reduction-blue-f-f _ _ => {?}
    | metavar (red f-A) choosing-A, metavar (red f-B) choosing-B, metavar (red f-C) choosing-C, distributed-reduction-red-m-m _ _, distributed-reduction-red-m-m p _ => {?}
    | metavar (blue b) choosing, metavar (blue f-B) choosing-B, metavar (blue f-C) choosing-C, distributed-reduction-blue-m-m _ _, distributed-reduction-blue-m-m p _ => {?}
}


