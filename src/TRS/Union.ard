\import Algebra.Ring.Localization
\import Confluence
\import Data.Bool
\import Data.List (++, ++-assoc, ::, List, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import TRS.HRS
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort} {meta-signature : MetaSignature Sort}
                         (term : Term envL c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          {meta-signature : MetaSignature Sort}
                          (term : Term envR c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | l-is-func => promote-injection-left {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-left {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envL context s meta-signature)
                                   (t-is-func : FunctionalRoot {envL} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-left envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | l-is-func => promote-injection-right {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \func promote-injection-right {Sort : \Set}
                                   {envL envR : Environment Sort}
                                   {context : List Sort}
                                   {s : Sort}
                                   {meta-signature : MetaSignature Sort}
                                   (t : Term envR context s meta-signature)
                                   (t-is-func : FunctionalRoot {envR} t) : FunctionalRoot {JointEnvironment envL envR} (inject-term-right envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointEnvironment envL envR}
    }

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                   (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
 : SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules =>
    \let
      | injected-left-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-left {_} {envL} {envR} L.set-of-rules
      | injected-right-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-right {_} {envL} {envR} R.set-of-rules
    \in JointIndexedSet injected-left-set injected-right-set
  | meta-signature => meta-signature

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                                  (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort} {meta-signature : MetaSignature Sort}
                                         {context : List Sort} (A B : Term env context s meta-signature) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {context} {s}) A B

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : Environment Sort'
    | envR : Environment Sort'
    | L-rules : IndexedSet (RewriteRule envL)
    | R-rules : IndexedSet (RewriteRule envR)
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (RewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term (colored-env {tc} color) context s meta-signature): \Prop
    \elim color
      | red => RewriteRelation {envL} L-rules A B
      | blue => RewriteRelation {envR} R-rules A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (t : Term (colored-env color) context s meta-signature) : Term env context s meta-signature \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (term : Term env context s meta-signature) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      | _, metavar _ _ => uncolored-metavar-root
      | _, var _ _ => uncolored-var-root

    \func color-of-root {_ : TheoremContext} {s : Sort'} (f : env.FunctionalSymbol.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR

    \func colored-rules {tc : TheoremContext} (color : Color) : IndexedSet (RewriteRule (env {tc})) \elim color
      | red => Injections.promote-indexed-set-left {tc.Sort'} {tc.envL} {tc.envR} (L-rules)
      | blue => Injections.promote-indexed-set-right {tc.Sort'} {tc.envL} {tc.envR} (R-rules)
  }

  \open TheoremContext

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} (A B : Term env context s meta-signature) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot {tc} color A) (step : LinearRewriteStep {env {tc}} A B) --(step.rule IndexedSet.in {LinearRewriteRule step.env} (colored-rules coor)) todo
    | func (f-A : symbol {FunctionalSymbol {env {tc}}} s) choosing-A, func (f-B : symbol {FunctionalSymbol {env {tc}}} s) choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root {tc} f-A = color)
                                     (ReductionAtIndex {env {tc}}
                                         (TopLevelColoredReduction {tc} color {meta-signature})
                                         (\lam i => (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i ++ {Sort {env {tc}}} context))
                                         (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} __)
                                         choosing-A
                                         (transport-chooser-f {env {tc}} p choosing-B))

  \data BorderedParallelReduction {tc : TheoremContext} (color : Maybe Color) {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
                                  (A B : Term (env {tc}) context s meta-signature) \elim color, A, B
    | _, A, B => equal-trees (A = B)
    | just color, A, B => reduction-top-level (HasColoredRoot {tc} color A) (TopLevelColoredReduction {tc} color A B)
    | nothing, func f-A choosing-A, func f-B choosing-B =>
    reduction-subterms (f-A=f-B : f-A = f-B)
                       (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f-A) -> \Sigma
                         (someColor : Maybe Color)
                         ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f-A))))
                         (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-B choosing-B i)))

  \func TrichromaticParallelReduction {tc : TheoremContext} {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term env context s meta-signature) : \Type =>
    \Sigma (color : Maybe Color) (BorderedParallelReduction color A B)

  \func bpr-confluence {tc : TheoremContext} (color1 color2 : Maybe Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (A B C : Term env context s meta-signature)
                       (A~>B : BorderedParallelReduction color1 A B)
                       (A~>C : BorderedParallelReduction color2 A C)
    : StraightJoin B C (Closure TrichromaticParallelReduction) \elim color1, color2, A, B, C, A~>B, A~>C
    | _, _, A, B, C, equal-trees p, equal-trees p1 => {?} -- easy
    | color, just color1, A, B, B1, equal-trees p, reduction-top-level h A~>B1 => {?} -- easy
    | color, nothing, func f-A choosing-A, B, func f-B choosing-B, equal-trees p, reduction-subterms f-A=f-B _x => {?} -- easy
    | just color, color1, A, B, B1, reduction-top-level h A~>B, equal-trees p => {?} -- easy
    | just color, just color1, A, B, B1, reduction-top-level h A~>B, reduction-top-level h2 A~>B1 => {?} -- ?
    | just color, nothing, func f-A choosing-A, B, func f-C choosing-C, reduction-top-level A-colored A~>B, reduction-subterms f-A=f-C inner-reduction
    => \case \elim f-C, \elim f-A=f-C, \elim choosing-C, \elim inner-reduction \with {
        | f-C, idp, choosing-C, inner-reduction => \let (X, c1, C~>X, B~>*X) => unify-top color f-A choosing-A choosing-C B A~>B inner-reduction \in \new StraightJoin {
          | common-reduct => X
          | a~>cr => B~>*X
          | b~>cr => (c-basic (c1, C~>X))
        }
      }
    | nothing, color, func f-A choosing-A, func f-B choosing-B, B, reduction-subterms f-A=f-B red-subterms, equal-trees p => {?} -- easy
    | nothing, just color, func f-A choosing-A, func f-B choosing-B, B, reduction-subterms f-A=f-B _x, reduction-top-level h A~>B' => {?} -- symmetric to 3
    | nothing, nothing, func f-A choosing-A, func f-B choosing-B, func f-B1 choosing-B1, reduction-subterms f-A=f-B _x, reduction-subterms f-A=f-B1 _x1 => {?} -- inductive step, relatively easy

  \func extract-top-level {tc : TheoremContext} (global-context : List tc.Sort') {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                          (color : Color)
                          (sublist : SubList global-context context)
                          (A : Term env context s meta-signature) : \Sigma (internal-ms : MetaSignature Sort')
                                                                           (t : Term env context s internal-ms)
                                                                           (subst : MetaSubstitution env global-context internal-ms meta-signature)
                                                                           (A = MetaSubstitution.apply {env} t sublist subst)
  \elim color, A
    | _, var index p =>
      \let | empty-signature => \new MetaSignature Sort' {
        | metaname _ => Empty
        | m-domain a => contradiction
      }
      \in (empty-signature, var index p, \lam _ => contradiction, idp)
    | color, metavar m choosing =>
      \let | inner-results i => extract-top-level global-context color sublist (choosing i)
           | signature-producer i => (inner-results i).1
           | unified-metasignature => PointedModularMetaSignature {env} m signature-producer
           | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam {s'} m => \case \elim m \with {
             | inl a => \let q => weakening {env} {_} {_} {meta-signature.m-domain m ++ global-context} (metavar {env} m (\lam index => var index idp)) ((SubList.extend-right-single SubList.identity)) \in transport (Term env (meta-signature.m-domain m ++ global-context) __ meta-signature) a q
             | inr b => ((inner-results (b.1)).3 b.2)
           }
      \in (unified-metasignature,
           metavar (inl idp) (\lam i => upgrade-metavariables-to-pointed {env} m signature-producer (inner-results i).2),
           unified-substitution,
           {?}) -- provable, technical
    | red, func (inl f) choosing =>
      \let | inner-results (i : F-param-index {_} {env.FunctionalSymbol} (inl f)) => extract-top-level global-context red (SubList.extend-right-single-left sublist) (choosing i)
           | signature-producer i => (inner-results i).1
           | unified-metasignature => ModularMetaSignature {env} signature-producer
           | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam m => ((inner-results (m.1)).3 m.2)
      \in (unified-metasignature,
           func (inl f) (\lam index => upgrade-metavariables {env {tc}} signature-producer (inner-results index).2),
           unified-substitution,
           pmap (func {env {tc}} (inl f)) (ext (\lam i =>
               (inner-results i).4 *>
               inv ((apply-modular-inside {env {tc}} signature-producer (\lam ind => (inner-results ind).3) ((SubList.extend-right-single-left sublist)) (inner-results i).2)))))
    | red, func (inr f-b) choosing =>
      \let | singular-signature =>
        \new MetaSignature Sort' {
          | metaname s' => s = s'
          | m-domain p => context
        }
           | singular-term : Term env context s singular-signature => metavar idp (\lam i => var i idp)
           | singular-metasubstitution : MetaSubstitution env global-context singular-signature meta-signature =>
             \lam m => weakening {env {tc}} (transport (Term env context __ meta-signature) m (func {env {tc}} (inr (f-b : tc.envR.FunctionalSymbol.symbol s)) choosing)) (SubList.extend-right-single SubList.identity)
      \in (singular-signature, singular-term, singular-metasubstitution, pmap (func {env} (inr f-b)) (ext (\lam i => {?}))) -- provable, but technical; not interesting now
    | blue, func f choosing => {?}

  \func funExt {A : \Type} {B : A -> \Type} (f g : \Pi (a : A) -> B a) (h : \Pi (a : A) -> f a = g a) : f = g => ext h

  \func apply-modular-inside {env : Environment} {context subst-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n} (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (t : Term env context s (producer index)) :
    MetaSubstitution.apply (upgrade-metavariables producer t) sublist (\lam m => substitutions m.1 m.2) = MetaSubstitution.apply t sublist (substitutions index) \elim t
    | var index1 p => idp
    | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-right sublist e)) (ext (\lam i => apply-modular-inside producer substitutions sublist (choosing i)))
    | func f choosing => pmap (func f) (ext (\lam i => apply-modular-inside producer substitutions (SubList.extend-right-single-left sublist) (choosing i)))

  \func ModularMetaSignature {env : Environment} {n : Nat} (producer : \Pi (Fin n) -> MetaSignature Sort) : MetaSignature Sort \cowith
    | metaname s => \Sigma (i : Fin n) (metaname {producer i} s)
    | m-domain m => m-domain {(producer (m.1))} m.2

  \func PointedModularMetaSignature {env : Environment} {n : Nat} {pointed-signature : MetaSignature Sort} {s : Sort} (m : pointed-signature.metaname s)
                                    (producer : Fin n -> MetaSignature Sort) : MetaSignature Sort \cowith
    | metaname s' => (s = s') `Or` (\Sigma  (i : Fin n) (metaname {producer i} s'))
    | m-domain {s'} m => \case \elim m \with {
      | inl a => pointed-signature.m-domain m
      | inr b => m-domain {(producer (b.1))} b.2
    }

  \func upgrade-metavariables {env : Environment} {context : List Sort} {s : Sort} {n : Nat} {index : Fin n}
                              (producer : \Pi (Fin n) -> MetaSignature Sort)
                              (A : Term env context s (producer index))
    : Term env context s (ModularMetaSignature producer) \elim A
    | var index p => var index p
    | metavar m choosing => metavar (index, m) (\lam i => upgrade-metavariables producer (choosing i))
    | func f choosing => func f (\lam i => upgrade-metavariables producer (choosing i))

  \func upgrade-metavariables-to-pointed {env : Environment} {context : List Sort} {s s' : Sort} {n : Nat} {index : Fin n} {meta-signature : MetaSignature Sort}
                                         (m' : meta-signature.metaname s')
                                         (producer : \Pi (Fin n) -> MetaSignature Sort)
                                         (A : Term env context s (producer index))
    : Term env context s (PointedModularMetaSignature m' producer) \elim A
    | var index p => var index p
    | metavar m choosing => metavar (inr (index, m)) (\lam i => upgrade-metavariables-to-pointed m' producer (choosing i))
    | func f choosing => func f (\lam i => upgrade-metavariables-to-pointed m' producer (choosing i))

  \func unify-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                  (f : env.FunctionalSymbol.symbol s)
                  (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                  (B : Term env context s meta-signature)
                  (A~>B : TopLevelColoredReduction color (func f choosing-A) B)
                  (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f) -> \Sigma (someColor : Maybe Color)
                                                                                                     ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
                                                                                                     (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
    : \Sigma (X : Term env context s meta-signature) (c1 : Maybe Color) (BorderedParallelReduction c1 (func f choosing-C) X) (Closure TrichromaticParallelReduction B X) \elim B, A~>B
    | B, rewrite-with-rule-colored h ((rul : LinearRewriteRule (env {tc})), rho, l[rho]=A, r[rho]=B) => \let
      | (sigma, C=l[sigma], reds) => alternate-subst {_} {nil} {context} (func f choosing-A) (func f choosing-C) sublist-trivial SubList.identity idp rul.linear-pattern rho (inv l[rho]=A) nothing (reduction-subterms idp inner-reductions)
      | uni-right => unify-right color rul.linear-pattern rul.r sigma rul.l-is-func
      | uni-left => unify-left (weakening {env} rul.r sublist-trivial) SubList.identity rho sigma reds \in ((MetaSubstitution.apply {env} (weakening {env} rul.r sublist-trivial) SubList.identity sigma), just color, reduction-top-level (recreate-coloring-for-root h) (rewrite C=l[sigma] uni-right), rewriteI r[rho]=B uni-left)
    | func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => (func f {?}, {?}, {?}, {?})
    \where {
      \func recreate-coloring-for-root {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} {color : Color} {f : env.FunctionalSymbol.symbol s}
                                       {choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature}
                                       (h : HasColoredRoot color (func f choosing-A)) : HasColoredRoot color (func f choosing-C) \elim color, f, h
        | red, inl s1, red-func-root => red-func-root
        | blue, inr s1, blue-func-root => blue-func-root
    }

  \data LinearPattern (env : Environment)
                      (context : List Sort)
                      (termSort : Sort)
    | lp-var (index : Fin (length context)) (termSort = context !! index)
    | lp-func (f : FunctionalSymbol.symbol termSort)
              (choosing : \Pi (index : Fin (length (domain f))) -> LinearPattern env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index))
    | lp-metavar
    \where {
      \func upgrade-metavariables-p {env : Environment} {context : List Sort} {s : Sort} {n : Nat} {index : Fin n}
                                    (producer : \Pi (Fin n) -> MetaSignature Sort)
                                    (A : Term env context s (producer index))
        : Term env context s (ModularMetaSignature producer) \elim A
        | var index p => var index p
        | metavar m choosing => metavar (index, m) (\lam i => upgrade-metavariables-p producer (choosing i))
        | func f choosing => func f (\lam i => upgrade-metavariables-p producer (choosing i))

      \func convert-to-term {env : Environment} {context : List Sort} {s : Sort} (pattern : LinearPattern env context s) : Term env context s (LinearMetasignature pattern) \elim pattern
        | lp-var index p => var index p
        | lp-func f choosing => func f (\lam i => upgrade-metavariables-p (\lam i => LinearMetasignature (choosing i)) (convert-to-term (choosing i)))
        | lp-metavar => metavar idp (\lam index => var index idp)
    }

  \record LinearRewriteRule \extends RewriteRule {
    | linear-pattern : LinearPattern env nil s
    | meta-signature => LinearMetasignature linear-pattern
    | l => LinearPattern.convert-to-term linear-pattern
  }

  \record LinearRewriteStep \extends RewriteStep {
    \override  rule : LinearRewriteRule env {s}
  }

  \func LinearMetasignature {env : Environment} {context : List Sort} {s : Sort} (pattern : LinearPattern env context s) : MetaSignature Sort \elim pattern
    | lp-var index p => \new MetaSignature {
      | metaname s => Empty
      | m-domain m => contradiction
    }
    | lp-func f choosing => \new MetaSignature {
      | metaname s => \Sigma (i : Fin (length (domain f))) (metaname {LinearMetasignature (choosing i)} s)
      | m-domain m => m-domain {LinearMetasignature (choosing m.1)} m.2
    }
    | lp-metavar => \new MetaSignature {
      | metaname s' => s = s'
      | m-domain m => context
    }

  \func alternate-subst {tc : TheoremContext} {pattern-context global-context context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (A C : Term env (context) s meta-signature)
                        (pattern-sublist : SubList pattern-context context)
                        (glb-sublist : SubList global-context context)
                        (eq : pattern-context ++ global-context = context)
                        (t : LinearPattern env pattern-context s)
                        (rho : MetaSubstitution env global-context (LinearMetasignature {env} t) meta-signature)
                        (A=t[rho] : A = MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-term {env} t) (pattern-sublist)) (glb-sublist) rho)
                        (someColor : Maybe Color)
                        (A=>C : BorderedParallelReduction someColor A C)
    : \Sigma (sigma : MetaSubstitution env global-context (LinearMetasignature {env} t) meta-signature)
             (C = MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-term {env} t) (pattern-sublist)) (glb-sublist) sigma)
             (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignature {env} t} s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m))) \elim A, C, t, someColor, A=>C
    | A, C, lp-var index p, someColor, rd => \case \elim someColor, \elim A, \elim A=t[rho], \elim C, \elim rd \with {
      | someColor, A, idp, C, equal-trees idp => (\lam {s1} mvar => contradiction, idp, \lam {s1} m => (nothing, contradiction))
      | just color1, A, idp, C, reduction-top-level h t => (\lam {s1} mvar => contradiction, \case \elim t \with {
        | rewrite-with-rule-colored h1 (((rule : LinearRewriteRule env),m,t,t1)) => \let q => pattern-can't-be-var {env} (rule.l) m ((weakening.recalculate-index (pattern-sublist) index p).1) ((weakening.recalculate-index (pattern-sublist) index p).2) t (rule.l-is-func) \in contradiction
      }, \lam {s1} m => contradiction)
    }
    | A, C, lp-metavar, someColor, rd => \case \elim context, \elim C, \elim pattern-sublist, \elim glb-sublist, \elim eq, \elim A, \elim rd, \elim rho, \elim A=t[rho] \with {
      | context, C, pattern-sublist, glb-sublist, idp, A, rd, rho, A=t[rho] =>
            \let | context-mapping => (extend-substitution-right {env} glb-sublist
                (\lam i => (\let (index', p') => weakening.recalculate-index (pattern-sublist) i idp \in var index' p')))
                 | context-mapping-is-identical : context-mapping = plain-identity {env} => ext (identify-context-mapping {env} glb-sublist pattern-sublist)
                 | res-term : Term env (pattern-context ++ global-context) s meta-signature => Substitution.apply {env} (rho idp) context-mapping
                 | modified-rd : BorderedParallelReduction someColor (rho idp) C => transport (BorderedParallelReduction someColor __ C) (A=t[rho] *> (pmap (Substitution.apply {env} (rho idp)) context-mapping-is-identical) *> plain-identity-effect {env} (rho idp)) rd
            \in (\lam {s1} mvar => transport (Term env (pattern-context ++ global-context) __ meta-signature) mvar C,
                 inv (plain-identity-effect {env} C) *> (pmap (Substitution.apply {env} C) (inv context-mapping-is-identical)),
                 \lam {s1} m => (someColor, Jl (\lam _ s=s' => BorderedParallelReduction someColor (rho s=s') (transport (\lam p0 => Term env (pattern-context ++ global-context) p0 meta-signature) s=s' C)) modified-rd m))
    }

    | A, C, lp-func f choosing, someColor, equal-trees A=C => (rho, inv A=C *> A=t[rho], \lam {s1} m => (nothing, equal-trees idp))
    | A, C, lp-func f choosing, just color1, reduction-top-level h t => {?}
    | func f-A choosing-A, func f-C choosing-C, lp-func f choosing, nothing, reduction-subterms f-A=f-C inner-reductions => \let e : f = f-A => {?} \in redirection f-A f-C f choosing-A choosing-C {?} {?} {?} choosing e f-A=f-C rho A=t[rho] inner-reductions
    \where {
      \func pattern-can't-be-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature new-meta-signature : MetaSignature Sort}
                                 (T : Term env nil s meta-signature)
                                 (subst : MetaSubstitution env context meta-signature new-meta-signature)
                                 (someIndex : Fin (length context)) (someProof : s = context !! someIndex)
                                 (eq : MetaSubstitution.apply (weakening T sublist-trivial) SubList.identity subst = var someIndex someProof)
                                 (T-functional : FunctionalRoot T) : Empty \elim T, T-functional
        | func f choosing, T-has-functional-root => contradiction

      \func identify-context-mapping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                                     (sublist : SubList right-context (left-context ++ right-context))
                                     (sublist' : SubList left-context (left-context ++ right-context))
                                     (ind : Fin (length (left-context ++ right-context))) :
        (extend-substitution-right {env} {_} {_} {_} {meta-signature} (sublist)
            (\lam i => (\let (index', p') => weakening.recalculate-index sublist' i idp \in var index' p'))) ind = var ind idp
      \elim left-context, right-context, ind
        | nil, :: a right-context, zero => {?}
        | nil, :: a right-context, suc ind => {?} -- rewrite (extension-over-identity-is-identity ind) idp
        | :: a left-context, nil, zero => {?}
        | :: a left-context, r, suc ind => {?}
        --        \let q => identify-context-mapping {_} {_} {_} {meta-signature} sublist sublist' ind \in identify-context-mapping.extension-over-skipping (\lam i => weakening.recalculate-index (SubList.extend-right-single SubList.identity) i idp) ind q
        | :: a left-context, :: a1 right-context, zero => {?}
        \where {
          \func extension-over-identity-is-identity {A : \Type} {some-context : List A} (j : Fin (length some-context)) : extend-substitution-right.produce-inner-term SubList.identity j = (j, idp) \elim some-context, j
            | :: a some-context, zero => idp
            | :: a some-context, suc j => rewrite (extension-over-identity-is-identity j) idp

          \func extension-over-skipping {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort} {a : Sort}
                                        (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                        (j : Fin (length (left-context ++ right-context)))
                                        (eq : extend-substitution-right {_} {_} {_} {_} {meta-signature} (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j = var j idp)
            : extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j = var (suc j) idp =>
            \let | rrr => pmap (weakening {_} {_} {_} {a :: (left-context ++ right-context)} __ (sublist-skip SubList.identity)) eq
                 | qqq : rrr @ right = var (suc j) idp => \let internal => recalculate-over-skipping {_} {a} j \in pmap sigma-to-var internal
                 | zzz : rrr @ left = extend-substitution-right {_} {_} {_} {a :: (left-context ++ right-context)} {meta-signature}(sublist-skip (SubList.extend-right-single-left SubList.identity)) (\lam i => \let (index, p) => index-calculator i \in var (suc index) p) j => weakining-extension-comms index-calculator j
            \in inv zzz *> rrr *> qqq

          \func sigma-to-var {env : Environment} {context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} (sig : \Sigma (i : Fin (length context)) (s = context !! i)) : Term env context s meta-signature =>
            var sig.1 sig.2

          \func recalculate-over-skipping {A : \Set} {point' : A} {a : List A} (ind : Fin (length a)) : weakening.recalculate-index {_} {a} {point' :: a} (sublist-skip SubList.identity) ind idp = (suc ind, idp) \elim a, ind
            | :: a a1, zero => idp
            | :: a a1, suc ind => rewrite (weakening.recalculate-index-over-identity ind) idp

          \func weakining-extension-comms {env : Environment} {left-context right-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort}
                                          (index-calculator : \Pi (i : Fin (length left-context)) -> \Sigma (j' : Fin (length (left-context ++ right-context))) (left-context !! i = (left-context ++ right-context) !! j'))
                                          (j : Fin (length (left-context ++ right-context)))
            : weakening {_} {_} {_} {_} {meta-signature}
              (extend-substitution-right (SubList.extend-right-single-left SubList.identity) (\lam i => sigma-to-var (index-calculator i)) j)
              (sublist-skip SubList.identity) =
          extend-substitution-right {_} {_} {_} {s :: left-context ++ right-context}
              (sublist-skip (SubList.extend-right-single-left SubList.identity))
              (\lam i => \let (index, p) => index-calculator i \in var (suc index) p)
              j => {?}
        }

      \func redirection {tc : TheoremContext} {pattern-context global-context context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (f-A f-C f : env.FunctionalSymbol.symbol s)
                        (choosing-A : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-A))) ->
                            Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                        (choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-C))) ->
                            Term env ((f-C FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-C FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                        (pattern-sublist : SubList pattern-context context)
                        (glb-sublist : SubList global-context context)
                        (eq : pattern-context ++ global-context = context)
                        (choosing : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
                            LinearPattern env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ pattern-context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
                        (f=f-A : f = f-A)
                        (f-A=f-C : f-A = f-C)
                        (rho : MetaSubstitution env global-context (LinearMetasignature {env} (lp-func f choosing)) meta-signature)
                        (global-equality : func {env} f-A choosing-A = func f (\lam i => MetaSubstitution.apply {env} (weakening {env} (LinearPattern.upgrade-metavariables-p {env}
                            (\lam i => LinearMetasignature {env} (choosing i)) (LinearPattern.convert-to-term {env} (choosing i)))
                            (SubList.extend-left pattern-sublist)) (SubList.extend-right-single-left glb-sublist) rho))
                        (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f-A) -> \Sigma (someColor : Maybe Color)
                                                                                                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f-A))))
                                                                                                             (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-C choosing-C i))) :
        \Sigma (sigma : MetaSubstitution env global-context (LinearMetasignature {env} (lp-func f choosing)) meta-signature)
               ((func {env} f-C choosing-C) = MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-term {env} (lp-func f choosing)) pattern-sublist) (glb-sublist) sigma)
               (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignature {env} (lp-func f choosing)} s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m)))
      \elim f-A, f-C, f, choosing-A, choosing-C, choosing, f=f-A, f-A=f-C, rho, inner-reductions
        | f-A, f-C, f, choosing-A, choosing-C, choosing, idp, idp, rho, inner-reductions =>
          \let | equality-of-choosers => inv (unwrap-func' {env} global-equality)

               | insides i => alternate-subst
                   (choosing-A i)
                   (choosing-C i)
                   (SubList.extend-left pattern-sublist)
                   (SubList.extend-right-single-left glb-sublist)
                   (rewrite ++-assoc (pmap ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i) ++ __) eq))
                   (choosing i)
                   (\lam m => rho (i, m))
                   ((pmap (__ i) equality-of-choosers) *> (inv
                       (apply-modularity {env}
                       (\lam ind => LinearMetasignature {env} (choosing ind))
                       (\lam ii m => rho (ii, m))
                       (SubList.extend-right-single-left glb-sublist)
                       (SubList.extend-left pattern-sublist)
                       (LinearPattern.convert-to-term {env} (choosing i)))))
                   (inner-reductions i).1
                   (inner-reductions i).3
          \in (\lam {s1} mvar => (insides mvar.1).1 mvar.2,
               pmap (func {env} f-A)
                   (ext (\lam index => (insides index).2 *> apply-modularity {env} (\lam ind => LinearMetasignature {env} (choosing ind)) (\lam ind => (insides ind).1) (SubList.extend-right-single-left glb-sublist) (SubList.extend-left pattern-sublist) (LinearPattern.convert-to-term {env} (choosing index)))),
               \lam {s1} m => (insides m.1).3 m.2)

      \func unwrap-func {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                        (T : Term env context s meta-signature) : Or Nat
          (\Sigma (f : env.FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
              Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) \elim T
        | var index p => inl 0
        | metavar m choosing1 => inl 0
        | func f1 choosing1 => inr (f1, choosing1)

      \func unwrap-func' {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                         {f'' : env.FunctionalSymbol.symbol s}
                         {choosing choosing' : \Pi (index : Fin (length (env.FunctionalSymbol.domain f''))) ->
                             Term env ((f'' FunctionalSignature.!!param index) ++ context) (f'' FunctionalSignature.!!sort index) meta-signature}
                         (eq : func f'' choosing = func f'' choosing') : choosing' = choosing =>
        \let | extracted => pmap (extractFunSymbol (f'', choosing)) eq
             | eq1 : (extracted @ left).1 = (extracted @ right).1 => idp
             | eq3 : (extracted @ left).1 = f'' => idp
             | eq2 => pmapd (\lam sig => \Pi (index : Fin (length (env.FunctionalSymbol.domain sig.1))) ->
                 Term env ((sig.1 FunctionalSignature.!!param index) ++ context) (sig.1 FunctionalSignature.!!sort index) meta-signature)
                 (\lam sig => sig.2)
                 extracted
             \in {?} -- weird homotopical stuff

      \func extractFunSymbol {env : Environment} {s : Sort} {context : List Sort} {meta-signature : MetaSignature Sort}
                             (default : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
                                 Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature)) (T : Term env context s meta-signature) : \Sigma (f : FunctionalSymbol.symbol s) (\Pi (index : Fin (length (env.FunctionalSymbol.domain f))) ->
          Term env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index) meta-signature) \elim T
        | var index p => default
        | metavar m choosing => default
        | func f choosing => (f, choosing)

      \func apply-modularity {env : Environment} {context subst-context pattern-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n}
                             (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (pat-sublist : SubList pattern-context context)
                             (t : Term env pattern-context s (producer index)) :
        MetaSubstitution.apply (weakening t pat-sublist) sublist (substitutions index) = MetaSubstitution.apply (weakening (LinearPattern.upgrade-metavariables-p producer t) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim t
        | var index1 p => idp
        | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-right sublist e)) (ext (\lam i => apply-modularity producer substitutions sublist pat-sublist (choosing i)))
        | func f choosing => pmap (func f) (ext (\lam i => apply-modularity producer substitutions (SubList.extend-right-single-left sublist) (SubList.extend-left pat-sublist) (choosing i)))
    }

  \func unify-right {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                    (t : LinearPattern env nil s) (s : Term env nil s (LinearMetasignature {env} t))
                    (sigma : MetaSubstitution env context (LinearMetasignature {env} t) meta-signature)
                    (t-is-func : FunctionalRoot {env} (LinearPattern.convert-to-term {env} t)) :
    TopLevelColoredReduction {tc} color
        (MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-term {env} t) sublist-trivial) SubList.identity sigma)
        (MetaSubstitution.apply {env} (weakening {env} s sublist-trivial) SubList.identity sigma) =>
    rewrite-with-rule-colored {?} (\new LinearRewriteStep {
      | rule => \new LinearRewriteRule {
        | linear-pattern => t
        | r => s
        | l-is-func => t-is-func
      }
      | substitution => sigma
      | left-coherence => idp
      | right-coherence => idp
    })

  \data Closure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | c-basic (a `R` b)
    | c-connect (c : A) (a `R` c) (Closure R c b)
    \where {
      \func concat {A : \Type} {R : A -> A -> \Type} {a b c : A} (a~>b : Closure R a b) (b~>c : Closure R b c) : Closure R a c \elim a~>b, b~>c
        | c-basic r, rx => c-connect b r rx
        | c-connect c1 r a~>b, rx => c-connect c1 r (concat a~>b rx)
    }

  \func unify-left {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature inner-metasignature : MetaSignature Sort'}
                   (s : Term env context' s inner-metasignature)
                   (sublist : SubList context context')
                   (rho sigma : MetaSubstitution env context inner-metasignature meta-signature)
                   (rho~>sigma : \Pi {s : Sort'} (m : inner-metasignature.metaname s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m))) :
    Closure TrichromaticParallelReduction (MetaSubstitution.apply {env} s sublist rho) (MetaSubstitution.apply {env} s sublist sigma) \elim s
    | var index p => c-basic (nothing, equal-trees idp)
    | metavar m choosing => \let | main-reduction => rho~>sigma m
                                 | partial-reductions i => unify-left (choosing i) sublist rho sigma rho~>sigma
                                 | rho-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho))
                                 | sigma-subst => (extend-substitution-right {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma))
                                 | term-A => (Substitution.apply {env} (rho m) rho-subst)
                                 | term-B => (Substitution.apply {env} (rho m) sigma-subst)
                                 | in-indices i => (unify-left (choosing i) sublist rho sigma rho~>sigma)
                                 | term-C => (Substitution.apply {env} (sigma m) sigma-subst)
                                 | term-A~>term-B : Closure TrichromaticParallelReduction term-A term-B => apply-reducible-substitution (rho m) rho-subst sigma-subst {?}
                                 | term-B~>term-C : TrichromaticParallelReduction term-B term-C => (main-reduction.1, extend-reduction-to-substitution (rho m) (sigma m) sigma-subst main-reduction.1 main-reduction.2) \in Closure.concat term-A~>term-B (Closure.c-basic term-B~>term-C)
    | func f choosing => \let | q i => unify-left (choosing i) (SubList.extend-right-single-left sublist) rho sigma rho~>sigma
                         \in gather-closure f (\lam i => MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single-left sublist) rho) (\lam i => MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single-left sublist) sigma) q

  \func apply-reducible-substitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                     (s : Term env context s meta-signature)
                                     (a-subst b-subst : Substitution {env} context context' meta-signature)
                                     (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
    : Closure TrichromaticParallelReduction (Substitution.apply {env} s a-subst) (Substitution.apply {env} s b-subst)
  \elim s
    | var index p => \case \elim s, \elim p \with {
      | s, idp => a~>b index
    }
    | metavar m choosing => {?} -- like the bottom one
    | func f choosing =>
      \let | choosing-a i => (Substitution.apply {env} (choosing i) (append-context-left {env} a-subst))
           | choosing-b i => (Substitution.apply {env} (choosing i) (append-context-left {env} b-subst))
           | q i => apply-reducible-substitution (choosing i) (append-context-left {env} a-subst) (append-context-left {env} b-subst) {?}
      \in gather-closure f choosing-a choosing-b q

  \func extend-reduction-to-substitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                         (t s' : Term env context s meta-signature)
                                         (subst : Substitution {env} context context' meta-signature)
                                         (someColor : Maybe Color)
                                         (t~>s : BorderedParallelReduction someColor t s')
    : BorderedParallelReduction someColor (Substitution.apply {env} t subst) (Substitution.apply {env} s' subst) \elim t, s', someColor, t~>s
    | t, s', someColor, equal-trees p => equal-trees (pmap (Substitution.apply {env} __ subst) p)
    | t, s', just color, reduction-top-level h tlcr => reduction-top-level {?} (lemma-tlcr t s' subst color tlcr)
    | func f-A choosing-A, func f-B choosing-B, nothing, reduction-subterms f-A=f-B _x => redirection f-A f-B choosing-A choosing-B f-A=f-B _x subst
    \where {
      \func redirection {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (f-A f-C : env.FunctionalSymbol.symbol s)
                        (choosing-A : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-A))) -> Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                        (choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-C))) -> Term env ((f-C FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-C FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                        (f-A=f-C : f-A = f-C)
                        (inner-reductions : \Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f-A) -> \Sigma
                          (someColor : Maybe Color)
                          ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f-A))))
                          (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-C choosing-C i)))
                        (subst : Substitution {env} context context' meta-signature)
        : BorderedParallelReduction nothing (Substitution.apply {env} (func f-A choosing-A) subst) (Substitution.apply {env} (func f-C choosing-C) subst) \elim f-A=f-C
        | idp => reduction-subterms idp (\lam i => \let (col, or, reduct) => inner-reductions i \in
          (col, or, extend-reduction-to-substitution (choosing-A i) (choosing-C i) ((append-context-left {env} subst)) col reduct))

      \func lemma-tlcr {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                       (t s' : Term env context s meta-signature)
                       (subst : Substitution {env} context context' meta-signature)
                       (color : Color)
                       (t~>s : TopLevelColoredReduction color t s') : TopLevelColoredReduction color (Substitution.apply {env} t subst) (Substitution.apply {env} s' subst) \elim t, s', t~>s
        | t, s', rewrite-with-rule-colored h (rule,metasubst,m[l]=t,m[r]=s') => rewrite-with-rule-colored {?} (\new LinearRewriteStep {
          | rule => rule
          | substitution m => Substitution.apply {env} (metasubst m) (append-context-left {env} subst)
          | left-coherence => {?}
          | right-coherence => {?}
        })
        | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => {?}

      \func prove-coherence {env : Environment} {context context' pattern-context : List Sort} {s : Sort} {inner-meta-signature meta-signature : MetaSignature Sort}
                            (t : Term env pattern-context s inner-meta-signature)
                            (sublist : SubList pattern-context context)
                            (sublist' : SubList pattern-context context')
                            (subst : Substitution {env} context context' meta-signature)
                            (metasubst : MetaSubstitution env context inner-meta-signature meta-signature)
        : MetaSubstitution.apply (weakening t sublist') SubList.identity (\lam m => Substitution.apply (metasubst m) (append-context-left subst)) = Substitution.apply (MetaSubstitution.apply (weakening t sublist) SubList.identity metasubst) subst \elim t
        | metavar m choosing => \let | initial-term : Term env (inner-meta-signature.m-domain m ++ context) s meta-signature => (metasubst m)
                                     | left-inner-subst : Substitution (inner-meta-signature.m-domain m ++ context) (inner-meta-signature.m-domain m ++ context') meta-signature => (append-context-left subst)

                                     | left-outer-subst : Substitution (inner-meta-signature.m-domain m ++ context') context' meta-signature
                                     => (extend-substitution-right
                                         SubList.identity (\lam i => MetaSubstitution.apply (weakening (choosing i) sublist') SubList.identity
                                             (\lam {s} m => Substitution.apply (metasubst m) (append-context-left subst))))

                                     | right-inner-subst : Substitution (inner-meta-signature.m-domain m ++ context) context meta-signature
                                     => (extend-substitution-right SubList.identity
                                         (\lam i => MetaSubstitution.apply (weakening (choosing i) sublist) SubList.identity metasubst))

                                     | right-outer-subst : Substitution context context' meta-signature => subst
                                     | internal-subst : Substitution (inner-meta-signature.m-domain m) context meta-signature => \lam i => MetaSubstitution.apply (weakening (choosing i) sublist) SubList.identity metasubst

                                     | substituted-metavar => (Substitution.apply (metasubst m) (append-context-left subst))

                                     | applied-to-metavar => (extend-substitution-right
                                         SubList.identity (\lam i => MetaSubstitution.apply (weakening (choosing i) sublist') SubList.identity
                                             (\lam {s} m => Substitution.apply (metasubst m) (append-context-left subst))))
                                     | expanded-A => (Substitution.apply (metasubst m) (extend-substitution-right SubList.identity
                                         (\lam i => MetaSubstitution.apply (weakening (choosing i) sublist) SubList.identity metasubst)))
                                     | result : Substitution.apply substituted-metavar applied-to-metavar = Substitution.apply expanded-A subst => {?} \in result
        | var index p => {?}
        | func f choosing => pmap (func f) (ext (\lam index => \let q => prove-coherence (choosing index) {?} {?} {?} metasubst \in {?}))

      \func rhombic-coherence {env : Environment} {old-left-context old-right-context new-right-context : List Sort} {s : Sort} {old-meta-signature new-meta-signature : MetaSignature Sort}
                              (sublist' : SubList old-left-context new-right-context)
                              (sublist : SubList old-left-context old-right-context)
                              (T : Term env (old-left-context ++ old-right-context) s new-meta-signature)
                              (args : Substitution old-left-context old-left-context old-meta-signature)
                              (subst : Substitution old-right-context new-right-context new-meta-signature)
                              (meta-subst : MetaSubstitution env old-right-context old-meta-signature new-meta-signature)
        : Substitution.apply (Substitution.apply T (append-context-left subst)) (extend-substitution-right SubList.identity (\lam i => MetaSubstitution.apply (weakening (args i) sublist') SubList.identity (\lam m => Substitution.apply (meta-subst m) (append-context-left subst)))) =
      Substitution.apply (Substitution.apply T (extend-substitution-right SubList.identity (\lam i => MetaSubstitution.apply (weakening (args i) sublist) SubList.identity meta-subst))) subst \elim T
        | var index p => \case \elim s, \elim p \with {
          | s, idp => {?}
        }
        | metavar m choosing => pmap (metavar m) (ext (\lam index => {?}))
        | func f choosing => pmap (func f) (ext (\lam index =>
            \let | chosen => rewriteI (++-assoc) (choosing index)
                 | inner-rhombic => rhombic-coherence {?} {?} chosen {?} {?} {?} \in {?}))
    }

  \func gather-closure {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                       (f : env.FunctionalSymbol.symbol s)
                       (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                       (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure TrichromaticParallelReduction (choosing-A index) (choosing-B index))
    : Closure TrichromaticParallelReduction (func {env} f choosing-A) (func f choosing-B) =>
    {?} -- purely technical concatenation of closures
}