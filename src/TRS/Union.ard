\import Algebra.Ring.Localization
\import Confluence
\import Data.Bool
\import Data.List (++, List, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import TRS.HRS
\import TRS.List
\import TRS.Maybe
\import TRS.Utils

\func JointFunctionalSignature (Sort : \Set) (A B : FunctionalSignature Sort) : FunctionalSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointEnvironment {Sort : \Set} (A : Environment Sort) (B : Environment Sort) : Environment Sort \cowith
  | FunctionalSymbol => JointFunctionalSignature Sort A.FunctionalSymbol B.FunctionalSymbol

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : Environment Sort)
                         {s : Sort} {c : List Sort} {meta-signature : MetaSignature Sort}
                         (term : Term envL c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-pattern-term-left {Sort : \Set}
                                 (envL envR : Environment Sort)
                                 {s : Sort}
                                 {c : List Sort}
                                 {meta-signature : MetaSignature Sort}
                                 (term : PatternTerm envL c s meta-signature) : PatternTerm (JointEnvironment envL envR) c s meta-signature \elim term
    | pattern-var index p => pattern-var index p
    | pattern-metavar m arguments coherence => pattern-metavar m arguments coherence
    | pattern-func f choosing => pattern-func (inl f) (\lam i => inject-pattern-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : Environment Sort)
                          {s : Sort}
                          {c : List Sort}
                          {meta-signature : MetaSignature Sort}
                          (term : Term envR c s meta-signature) : Term (JointEnvironment envL envR) c s meta-signature \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func inject-pattern-term-right {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  {s : Sort}
                                  {c : List Sort}
                                  {meta-signature : MetaSignature Sort}
                                  (term : PatternTerm envR c s meta-signature) : PatternTerm (JointEnvironment envL envR) c s meta-signature \elim term
    | pattern-var index p => pattern-var index p
    | pattern-metavar m arguments coherence => pattern-metavar m arguments coherence
    | pattern-func f choosing => pattern-func (inr f) (\lam i => inject-pattern-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : Environment Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-pattern-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : Environment Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointEnvironment envL envR) \cowith
    | s => rule.s
    | meta-signature => rule.meta-signature
    | l => inject-pattern-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r

  \func promote-indexed-set-left {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : Environment Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointEnvironment envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\instance JointHRS {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                   (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
 : SimpleHigherOrderTermRewritingSystem (JointEnvironment L.env R.env)
  | set-of-rules =>
    \let
      | injected-left-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-left {_} {envL} {envR} L.set-of-rules
      | injected-right-set : IndexedSet (RewriteRule (JointEnvironment L.env R.env)) => Injections.promote-indexed-set-right {_} {envL} {envR} R.set-of-rules
    \in JointIndexedSet injected-left-set injected-right-set
  | meta-signature => meta-signature

\lemma Union-Preserves-Confluence {Sort : \Set} {envL envR : Environment Sort} {meta-signature : MetaSignature Sort}
                                  (L : SimpleHigherOrderTermRewritingSystem envL meta-signature)
                                  (R : SimpleHigherOrderTermRewritingSystem envR meta-signature)
                                  (L-confluence : isConfluent L)
                                  (R-confluence : isConfluent R)
  : isConfluent (JointHRS {_} {envL} {envR} L R) => {?}

\func TransitivelyClosedRewriteRelation  {env : Environment}
                                         (set-of-rules : IndexedSet (RewriteRule env))
                                         {s : env.Sort} {meta-signature : MetaSignature Sort}
                                         {context : List Sort} (A B : Term env context s meta-signature) : \Prop =>
  transitive-closure (RewriteRelation {env} set-of-rules {context} {s}) A B

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : Environment Sort'
    | envR : Environment Sort'
    | L-rules : IndexedSet (RewriteRule envL)
    | R-rules : IndexedSet (RewriteRule envR)
  } \where {
    \func colored-env {_ : TheoremContext} (color : Color) : Environment Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules {_ : TheoremContext} (color : Color) : IndexedSet (RewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term (colored-env {tc} color) context s meta-signature): \Prop
    \elim color
      | red => RewriteRelation {envL} L-rules A B
      | blue => RewriteRelation {envR} R-rules A B

    \func inject-monochrome-term {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                 (t : Term (colored-env color) context s meta-signature) : Term env context s meta-signature \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t

    \data HasColoredRoot {_ : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (term : Term env context s meta-signature) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      | _, metavar _ _ => uncolored-metavar-root
      | _, var _ _ => uncolored-var-root

    \func color-of-root {_ : TheoremContext} {s : Sort'} (f : env.FunctionalSymbol.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env {_ : TheoremContext} : Environment => JointEnvironment envL envR

    \func colored-rules {tc : TheoremContext} (color : Color) : IndexedSet (RewriteRule (env {tc})) \elim color
      | red => Injections.promote-indexed-set-left {tc.Sort'} {tc.envL} {tc.envR} (L-rules)
      | blue => Injections.promote-indexed-set-right {tc.Sort'} {tc.envL} {tc.envR} (R-rules)
  }

  \open TheoremContext

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {meta-signature : MetaSignature Sort'} {context : List env.Sort} {s : env.Sort} (A B : Term env context s meta-signature) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot {tc} color A) (step : LinearRewriteStep {env {tc}} A B) --(step.rule IndexedSet.in {LinearRewriteRule step.env} (colored-rules coor)) todo
    | func (f-A : symbol {FunctionalSymbol {env {tc}}} s) choosing-A, func (f-B : symbol {FunctionalSymbol {env {tc}}} s) choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root {tc} f-A = color)
                                     (ReductionAtIndex {env {tc}}
                                         (TopLevelColoredReduction {tc} color {meta-signature})
                                         (\lam i => (f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i ++ {Sort {env {tc}}} context))
                                         (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} __)
                                         choosing-A
                                         (transport-chooser-f {env {tc}} p choosing-B))

  \data BorderedParallelReduction {tc : TheoremContext} (color : Maybe Color) {context : List tc.Sort'} {s : tc.Sort'} {meta-signature : MetaSignature Sort'}
                                  (A B : Term (env {tc}) context s meta-signature) \elim color, A, B
    | _, A, B => equal-trees (A = B)
    | just color, A, B => reduction-top-level (HasColoredRoot {tc} color A) (TopLevelColoredReduction {tc} color A B)
    | nothing, func f-A choosing-A, func f-B choosing-B =>
    reduction-subterms (f-A=f-B : f-A = f-B)
                       (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f-A) -> \Sigma
                         (someColor : Maybe Color)
                         ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f-A))))
                         (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-B choosing-B i)))

  \func TrichromaticParallelReduction {tc : TheoremContext} {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (A B : Term env context s meta-signature) : \Type =>
    \Sigma (color : Maybe Color) (BorderedParallelReduction color A B)

  \func bpr-confluence {tc : TheoremContext} (color1 color2 : Maybe Color) {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}  (A B C : Term env context s meta-signature)
                       (A~>B : BorderedParallelReduction color1 A B)
                       (A~>C : BorderedParallelReduction color2 A C)
    : StraightJoin B C (Closure TrichromaticParallelReduction) \elim color1, color2, A, B, C, A~>B, A~>C
    | _, _, A, B, C, equal-trees p, equal-trees p1 => {?} -- easy
    | color, just color1, A, B, B1, equal-trees p, reduction-top-level h A~>B1 => {?} -- easy
    | color, nothing, func f-A choosing-A, B, func f-B choosing-B, equal-trees p, reduction-subterms f-A=f-B _x => {?} -- easy
    | just color, color1, A, B, B1, reduction-top-level h A~>B, equal-trees p => {?} -- easy
    | just color, just color1, A, B, B1, reduction-top-level h A~>B, reduction-top-level h2 A~>B1 => {?} -- ?
    | just color, nothing, func f-A choosing-A, B, func f-C choosing-C, reduction-top-level A-colored A~>B, reduction-subterms f-A=f-C inner-reduction
    => \case \elim f-C, \elim f-A=f-C, \elim choosing-C, \elim inner-reduction \with {
        | f-C, idp, choosing-C, inner-reduction => \let (X, c1, C~>X, B~>*X) => unify-top color f-A choosing-A choosing-C B A~>B inner-reduction \in \new StraightJoin {
          | common-reduct => X
          | a~>cr => B~>*X
          | b~>cr => (c-basic (c1, C~>X))
        }
      }
    | nothing, color, func f-A choosing-A, func f-B choosing-B, B, reduction-subterms f-A=f-B red-subterms, equal-trees p => {?} -- easy
    | nothing, just color, func f-A choosing-A, func f-B choosing-B, B, reduction-subterms f-A=f-B _x, reduction-top-level h A~>B' => {?} -- symmetric to 3
    | nothing, nothing, func f-A choosing-A, func f-B choosing-B, func f-B1 choosing-B1, reduction-subterms f-A=f-B _x, reduction-subterms f-A=f-B1 _x1 => {?} -- inductive step, relatively easy

  \func extract-top-level {tc : TheoremContext} (global-context : List tc.Sort') {context : List tc.Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                          (color : Color)
                          (sublist : SubList global-context context)
                          (A : Term env context s meta-signature) : \Sigma (internal-ms : MetaSignature Sort')
                                                                           (t : Term env context s internal-ms)
                                                                           (subst : MetaSubstitution env global-context internal-ms meta-signature)
                                                                           (A = MetaSubstitution.apply {env} t sublist subst)
  \elim color, A
    | _, var index p =>
      \let | empty-signature => \new MetaSignature Sort' {
        | metaname _ => Empty
        | m-domain a => contradiction
      }
      \in (empty-signature, var index p, \lam _ => contradiction, idp)
    | color, metavar m choosing =>
      \let | inner-results i => extract-top-level global-context color sublist (choosing i)
           | signature-producer i => (inner-results i).1
           | unified-metasignature => PointedModularMetaSignature {env} m signature-producer
           | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam {s'} m => \case \elim m \with {
             | inl a => \let q => Substitution.weakening {env} {_} {_} {meta-signature.m-domain m ++ global-context} (metavar {env} m (\lam index => var index idp)) ((SubList.extend-right-single SubList.identity) global-context) \in transport (Term env (meta-signature.m-domain m ++ global-context) __ meta-signature) a q
             | inr b => ((inner-results (b.1)).3 b.2)
           }
      \in (unified-metasignature,
           metavar (inl idp) (\lam i => upgrade-metavariables-to-pointed {env} m signature-producer (inner-results i).2),
           unified-substitution,
           {?}) -- provable, technical
    | red, func (inl f) choosing =>
      \let | inner-results (i : F-param-index {_} {env.FunctionalSymbol} (inl f)) => extract-top-level global-context red (SubList.extend-right-single-left sublist) (choosing i)
           | signature-producer i => (inner-results i).1
           | unified-metasignature => ModularMetaSignature {env} signature-producer
           | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam m => ((inner-results (m.1)).3 m.2)
      \in (unified-metasignature,
           func (inl f) (\lam index => upgrade-metavariables {env {tc}} signature-producer (inner-results index).2),
           unified-substitution,
           pmap (func {env {tc}} (inl f)) (ext (\lam i =>
               (inner-results i).4 *>
               inv ((apply-modular-inside {env {tc}} signature-producer (\lam ind => (inner-results ind).3) ((SubList.extend-right-single-left sublist)) (inner-results i).2)))))
    | red, func (inr f-b) choosing =>
      \let | singular-signature =>
        \new MetaSignature Sort' {
          | metaname s' => s = s'
          | m-domain p => context
        }
           | singular-term : Term env context s singular-signature => metavar idp (\lam i => var i idp)
           | singular-metasubstitution : MetaSubstitution env global-context singular-signature meta-signature =>
             \lam m => Substitution.weakening {env {tc}} (transport (Term env context __ meta-signature) m (func {env {tc}} (inr (f-b : tc.envR.FunctionalSymbol.symbol s)) choosing)) (SubList.extend-right-single SubList.identity global-context)
      \in (singular-signature, singular-term, singular-metasubstitution, pmap (func {env} (inr f-b)) (ext (\lam i => {?}))) -- provable, but technical; not interesting now
    | blue, func f choosing => {?}

  \func funExt {A : \Type} {B : A -> \Type} (f g : \Pi (a : A) -> B a) (h : \Pi (a : A) -> f a = g a) : f = g => ext h

  \func apply-modular-inside {env : Environment} {context subst-context : List Sort} {s : Sort} {meta-signature : MetaSignature Sort} {n : Nat} {index : Fin n} (producer : Fin n -> MetaSignature Sort)
                             (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) meta-signature)
                             (sublist : SubList subst-context context)
                             (t : Term env context s (producer index)) :
    MetaSubstitution.apply (upgrade-metavariables producer t) sublist (\lam m => substitutions m.1 m.2) = MetaSubstitution.apply t sublist (substitutions index) \elim t
    | var index1 p => idp
    | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (MetaSubstitution.apply.extend-chooser sublist e)) (ext (\lam i => apply-modular-inside producer substitutions sublist (choosing i)))
    | func f choosing => pmap (func f) (ext (\lam i => apply-modular-inside producer substitutions (SubList.extend-right-single-left sublist) (choosing i)))

  \func ModularMetaSignature {env : Environment} {n : Nat} (producer : \Pi (Fin n) -> MetaSignature Sort) : MetaSignature Sort \cowith
    | metaname s => \Sigma (i : Fin n) (metaname {producer i} s)
    | m-domain m => m-domain {(producer (m.1))} m.2

  \func PointedModularMetaSignature {env : Environment} {n : Nat} {pointed-signature : MetaSignature Sort} {s : Sort} (m : pointed-signature.metaname s)
                                    (producer : Fin n -> MetaSignature Sort) : MetaSignature Sort \cowith
    | metaname s' => (s = s') `Or` (\Sigma  (i : Fin n) (metaname {producer i} s'))
    | m-domain {s'} m => \case \elim m \with {
      | inl a => pointed-signature.m-domain m
      | inr b => m-domain {(producer (b.1))} b.2
    }

  \func upgrade-metavariables {env : Environment} {context : List Sort} {s : Sort} {n : Nat} {index : Fin n}
                              (producer : \Pi (Fin n) -> MetaSignature Sort)
                              (A : Term env context s (producer index))
    : Term env context s (ModularMetaSignature producer) \elim A
    | var index p => var index p
    | metavar m choosing => metavar (index, m) (\lam i => upgrade-metavariables producer (choosing i))
    | func f choosing => func f (\lam i => upgrade-metavariables producer (choosing i))

  \func upgrade-metavariables-to-pointed {env : Environment} {context : List Sort} {s s' : Sort} {n : Nat} {index : Fin n} {meta-signature : MetaSignature Sort}
                                         (m' : meta-signature.metaname s')
                                         (producer : \Pi (Fin n) -> MetaSignature Sort)
                                         (A : Term env context s (producer index))
    : Term env context s (PointedModularMetaSignature m' producer) \elim A
    | var index p => var index p
    | metavar m choosing => metavar (inr (index, m)) (\lam i => upgrade-metavariables-to-pointed m' producer (choosing i))
    | func f choosing => func f (\lam i => upgrade-metavariables-to-pointed m' producer (choosing i))

  \func unify-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                  (f : env.FunctionalSymbol.symbol s)
                  (choosing-A choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                  (B : Term env context s meta-signature)
                  (A~>B : TopLevelColoredReduction color (func f choosing-A) B)
                  (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f) -> \Sigma (someColor : Maybe Color)
                                                                                                     ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
                                                                                                     (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} idp choosing-C i)))
    : \Sigma (X : Term env context s meta-signature) (c1 : Maybe Color) (BorderedParallelReduction c1 (func f choosing-C) X) (Closure TrichromaticParallelReduction B X) \elim B, A~>B
    | B, rewrite-with-rule-colored h ((rul : LinearRewriteRule (env {tc})), rho, l[rho]=A, r[rho]=B) => \let
      | (sigma, C=l[sigma], reds) => alternate-subst sublist-trivial SubList.identity (func f choosing-A) (func f choosing-C) rul.linear-pattern rho (inv l[rho]=A) nothing  (reduction-subterms idp inner-reductions)
      | uni-right => unify-right color rul.linear-pattern rul.r sigma
      | uni-left => unify-left (Substitution.weakening {env} rul.r sublist-trivial) SubList.identity rho sigma reds \in ((MetaSubstitution.apply {env} (Substitution.weakening {env} rul.r sublist-trivial) SubList.identity sigma), just color, reduction-top-level {?easy} (rewrite C=l[sigma] uni-right), rewriteI r[rho]=B uni-left)
    | func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => {?technical}

  \data LinearPattern (env : Environment)
                      (context : List Sort)
                      (termSort : Sort)
    | lp-var (index : Fin (length context)) (termSort = context !! index)
    | lp-func (f : FunctionalSymbol.symbol termSort)
              (choosing : \Pi (index : Fin (length (domain f))) -> LinearPattern env ((f FunctionalSignature.!!param index) ++ context) (f FunctionalSignature.!!sort index))
    | lp-metavar (meta-context : List Sort)
                 (arguments : DescendingVector (length meta-context) (length context))
                 (arguments-coherence : \Pi (index : Fin (length meta-context)) -> meta-context !! index = context !! (arguments dv!! index))
    \where {
      \func upgrade-metavariables-p {env : Environment} {context : List Sort} {s : Sort} {n : Nat} {index : Fin n}
                                    (producer : \Pi (Fin n) -> MetaSignature Sort)
                                    (A : PatternTerm env context s (producer index))
        : PatternTerm env context s (ModularMetaSignature producer) \elim A
        | pattern-var index p => pattern-var index p
        | pattern-metavar m arguments coherence => pattern-metavar (index, m) arguments coherence
        | pattern-func f choosing => pattern-func f (\lam i => upgrade-metavariables-p producer (choosing i))

      \func convert-to-pattern {env : Environment} {context : List Sort} {s : Sort} (pattern : LinearPattern env context s) : PatternTerm env context s (LinearMetasignature pattern) \elim pattern
        | lp-var index p => pattern-var index p
        | lp-func f choosing => pattern-func f (\lam i => upgrade-metavariables-p (\lam i => LinearMetasignature (choosing i)) (convert-to-pattern (choosing i)))
        | lp-metavar meta-context arguments arguments-coherence => pattern-metavar idp arguments arguments-coherence
    }

  \record LinearRewriteRule \extends RewriteRule {
    | linear-pattern : LinearPattern env nil s
    | meta-signature => LinearMetasignature linear-pattern
    | l => LinearPattern.convert-to-pattern linear-pattern
  }

  \record LinearRewriteStep \extends RewriteStep {
    \override  rule : LinearRewriteRule env {s}
  }

  \func LinearMetasignature {env : Environment} {context : List Sort} {s : Sort} (pattern : LinearPattern env context s) : MetaSignature Sort \elim pattern
    | lp-var index p => \new MetaSignature {
      | metaname s => Empty
      | m-domain m => contradiction
    }
    | lp-func f choosing => \new MetaSignature {
      | metaname s => \Sigma (i : Fin (length (domain f))) (metaname {LinearMetasignature (choosing i)} s)
      | m-domain m => m-domain {LinearMetasignature (choosing m.1)} m.2
    }
    | lp-metavar meta-context arguments arguments-coherence => \new MetaSignature {
      | metaname s' => s = s'
      | m-domain m => meta-context
    }

  \func alternate-subst {tc : TheoremContext} {context pattern-context global-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (sublist : SubList pattern-context context)
                        (gc-sublist : SubList global-context context)
                        (A C : Term env context s meta-signature)
                        (t : LinearPattern env pattern-context s)
                        (rho : MetaSubstitution env global-context (LinearMetasignature {env} t) meta-signature)
                        (A=t[rho] : A = MetaSubstitution.apply {env} (Substitution.weakening {env} (PatternTerm.convertToTerm {env} (LinearPattern.convert-to-pattern {env} t)) sublist) gc-sublist rho)
                        (someColor : Maybe Color)
                        (A=>C : BorderedParallelReduction someColor A C)
    : \Sigma (sigma : MetaSubstitution env global-context (LinearMetasignature {env} t) meta-signature)
             (C = MetaSubstitution.apply {env} (Substitution.weakening {env} (PatternTerm.convertToTerm {env} (LinearPattern.convert-to-pattern {env} t)) sublist) gc-sublist sigma)
             (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignature {env} t} s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m))) \elim A, C, t, someColor, A=>C
    | A, C, lp-var index p, someColor, rd => \case \elim someColor, \elim A, \elim A=t[rho], \elim C, \elim rd \with {
      | someColor, A, idp, C, equal-trees idp => (\lam {s1} mvar => contradiction, idp, \lam {s1} m => (nothing, contradiction))
      | just color1, A, idp, C, reduction-top-level h t => (\lam {s1} mvar => contradiction, {?}, \lam {s1} m => contradiction) -- easy
    }
    | A, C, lp-metavar metacontext args args-h, someColor, rd => \let | res-term : Term env context s (LinearMetasignature {env} (lp-metavar metacontext args args-h)) => (metavar idp (\lam i1 => Substitution.weakening {env} (var (args dv!! i1) (args-h i1)) sublist))
                                                                      | ridp => Substitution.apply {env} (rho idp) (MetaSubstitution.apply.extend-chooser {env} gc-sublist (\lam i1 => \let (index', p') => Substitution.weakening.recalculate-index pattern-context context sublist (args dv!! i1) (args-h i1) \in var index' p'))
                                                                      | q => {?}
                                                                      | (u, C=phi_u, t=>u) => pull-reduction-along-substitution {tc} A C (rho idp) (MetaSubstitution.apply.extend-chooser {env} gc-sublist (\lam i1 => Substitution.weakening {env} (var (args dv!! i1) (args-h i1)) sublist)) A=t[rho] someColor rd
                                                                 \in (\lam {s'} m => transport (Term env (metacontext ++ global-context) __ meta-signature) m u,
                                                                      C=phi_u,
                                                                      \lam {s1} m => (someColor, Jl (\lam _ s=s' => BorderedParallelReduction someColor (rho s=s') (transport (\lam p0 => Term env (metacontext ++ global-context) p0 meta-signature) s=s' u)) t=>u m)) -- Prove that if A~>C and A=phi(t) where phi is some substitution, then t~>s, where C=phi(s)
    | A, C, lp-func f choosing, someColor, equal-trees A=C => (rho, inv A=C *> A=t[rho], \lam {s1} m => (nothing, equal-trees idp))
    | A, C, lp-func f choosing, just color1, reduction-top-level h t => {?}
    | func f-A choosing-A, func f-C choosing-C, lp-func f choosing, nothing, reduction-subterms f-A=f-C inner-reductions => \let e : f = f-A => {?} \in redirection f-A f-C f choosing-A choosing-C choosing sublist gc-sublist e f-A=f-C rho inner-reductions
    \where {
      \func redirection {tc : TheoremContext} {context pattern-context global-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                        (f-A f-C f : env.FunctionalSymbol.symbol s)
                        (choosing-A : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-A))) -> Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                        (choosing-C : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-C))) -> Term env ((f-C FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-C FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                        (choosing : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> LinearPattern env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ pattern-context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
                        (sublist : SubList pattern-context context)
                        (gc-sublist : SubList global-context context)
                        (f=f-A : f = f-A)
                        (f-A=f-C : f-A = f-C)
                        (rho : MetaSubstitution env global-context (LinearMetasignature {env} (lp-func f choosing)) meta-signature)
                        (inner-reductions : \Pi (i : F-param-index {_} {env.FunctionalSymbol} f-A) -> \Sigma (someColor : Maybe Color)
                                                                                                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f-A))))
                                                                                                             (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-C choosing-C i))) :
        \Sigma (sigma : MetaSubstitution env global-context (LinearMetasignature {env} (lp-func f choosing)) meta-signature)
               ((func {env} f-C choosing-C) = MetaSubstitution.apply {env} (Substitution.weakening {env} (PatternTerm.convertToTerm {env} (LinearPattern.convert-to-pattern {env} (lp-func f choosing))) sublist) gc-sublist sigma)
               (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetasignature {env} (lp-func f choosing)} s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m))) \elim f-A, f-C, f, choosing-A, choosing-C, choosing, f=f-A, f-A=f-C, rho, inner-reductions
        | f-A, f-C, f, choosing-A, choosing-C, choosing, idp, idp, rho, inner-reductions =>
          \let insides i => alternate-subst (SubList.extend-left sublist) (SubList.extend-right-single-left gc-sublist) (choosing-A i) (choosing-C i) (choosing i) (\lam m => rho (i, m)) {?} (inner-reductions i).1 (inner-reductions i).3
          \in (\lam {s1} mvar => (insides mvar.1).1 mvar.2, pmap (func {env} f-A)
              (ext (\lam index => {?techical})), \lam {s1} m => (insides m.1).3 m.2)
    }

  \func pull-reduction-along-substitution {tc : TheoremContext} {context inner-context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                          (A C : Term env context s meta-signature)
                                          (t : Term env inner-context s meta-signature)
                                          (phi : Substitution {env} inner-context context meta-signature)
                                          (A=phi_t : A = Substitution.apply {env} t phi)
                                          (someColor : Maybe Color)
                                          (A=>C : BorderedParallelReduction someColor A C)
    : \Sigma (u : Term env inner-context s meta-signature)
             (C = Substitution.apply {env} u phi)
             (BorderedParallelReduction someColor t u) \elim A, C, t, A=phi_t, someColor, A=>C
    | A, C, var index p, eq, someColor, equal-trees p1 => (var index p, inv p1 *> eq, equal-trees idp)
    | A, C, metavar m choosing, idp, someColor, equal-trees p => {?}
    | A, C, func f choosing, eq, someColor, equal-trees p => {?}
    | A, C, var index p, idp, just color, reduction-top-level h tlcr => (var index p, {?}, {?})
    | A, C, metavar m choosing, eq, just color, reduction-top-level h A=>C => \let inner-reductions (i : Nat) => {?} \in {?}
    | A, C, func f choosing, idp, just color, reduction-top-level h t => {?}
    | func f-A choosing-A, func f-B choosing-B, var index p, A=phi_t, nothing, reduction-subterms f-A=f-B _x => {?}
    | func f-A choosing-A, func f-B choosing-B, func f choosing, A=phi_t, nothing, reduction-subterms f-A=f-B _x => {?}

  \func unify-right {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                    (t : LinearPattern env nil s) (s : Term env nil s (LinearMetasignature {env} t))
                    (sigma : MetaSubstitution env context (LinearMetasignature {env} t) meta-signature) :
    TopLevelColoredReduction {tc} color
        (MetaSubstitution.apply {env} (Substitution.weakening {env} (PatternTerm.convertToTerm {env} (LinearPattern.convert-to-pattern {env} t)) sublist-trivial) SubList.identity sigma)
        (MetaSubstitution.apply {env} (Substitution.weakening {env} s sublist-trivial) SubList.identity sigma) =>
    rewrite-with-rule-colored {?} (\new LinearRewriteStep {
      | rule => \new LinearRewriteRule {
        | linear-pattern => t
        | r => s
      }
      | substitution => sigma
      | left-coherence => idp
      | right-coherence => idp
    })

  \data Closure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | c-basic (a `R` b)
    | c-connect (c : A) (a `R` c) (Closure R c b)

  \func unify-left {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature inner-metasignature : MetaSignature Sort'}
                   (s : Term env context' s inner-metasignature)
                   (sublist : SubList context context')
                   (rho sigma : MetaSubstitution env context inner-metasignature meta-signature)
                   (rho~>sigma : \Pi {s : Sort'} (m : inner-metasignature.metaname s) -> \Sigma (mcolor : Maybe Color) (BorderedParallelReduction mcolor (rho m) (sigma m))) :
    Closure TrichromaticParallelReduction (MetaSubstitution.apply {env} s sublist rho) (MetaSubstitution.apply {env} s sublist sigma) \elim s
    | var index p => c-basic (nothing, equal-trees idp)
    | metavar m choosing => \let | main-reduction => rho~>sigma m
                                 | partial-reductions i => unify-left (choosing i) sublist rho sigma rho~>sigma
                                 | rho-subst => (MetaSubstitution.apply.extend-chooser {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho))
                                 | sigma-subst => (MetaSubstitution.apply.extend-chooser {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma))
                                 | term-A => (Substitution.apply {env} (rho m) rho-subst)
                                 | term-B => (Substitution.apply {env} (rho m) sigma-subst)
                                 | in-indices i => (unify-left (choosing i) sublist rho sigma rho~>sigma)
                                 | term-C => (Substitution.apply {env} (sigma m) (MetaSubstitution.apply.extend-chooser {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma)))
                                 | term-A~>term-B : Closure TrichromaticParallelReduction term-A term-B => apply-reducible-substitution (rho m) {?} rho-subst sigma-subst {?}
                                 | term-B~>term-C : TrichromaticParallelReduction term-B term-C => {?} \in {?}
    | func f choosing => \let | q i => unify-left (choosing i) (SubList.extend-right-single-left sublist) rho sigma rho~>sigma
                         \in {?} -- somehow, should not be hard

  \func apply-reducible-substitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                     (s : Term env context s meta-signature)
                                     (sublist : SubList context context')
                                     (a-subst b-subst : Substitution {env} context context' meta-signature)
                                     (a~>b : \Pi (index : Fin (length context)) -> Closure TrichromaticParallelReduction (a-subst index) (b-subst index))
    : Closure TrichromaticParallelReduction (Substitution.apply {env} s a-subst) (Substitution.apply {env} s b-subst)
  \elim s
    | var index p => \case \elim s, \elim p \with {
      | s, idp => a~>b index
    }
    | metavar m choosing => {?} -- like the bottom one
    | func f choosing =>
      \let | choosing-a i => (Substitution.apply {env} (choosing i) (Substitution.apply.enlarge-substitution {env} meta-signature (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i) a-subst))
           | choosing-b i => (Substitution.apply {env}
               (choosing i) (Substitution.apply.enlarge-substitution {env} meta-signature (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i) b-subst))
           | q i => apply-reducible-substitution (choosing i) (SubList.extend-left sublist) (Substitution.apply.enlarge-substitution {env} meta-signature (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i) a-subst) (Substitution.apply.enlarge-substitution {env} meta-signature (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} i) b-subst) {?}
      \in gather-closure f choosing-a choosing-b q

  \func gather-closure {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                       (f : env.FunctionalSymbol.symbol s)
                       (choosing-A choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Term env ((f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
                       (args : \Pi (index : Fin (length (env.FunctionalSymbol.domain f))) -> Closure TrichromaticParallelReduction (choosing-A index) (choosing-B index))
    : Closure TrichromaticParallelReduction (func {env} f choosing-A) (func f choosing-B) => {?} -- purely technical concatenation of closures
}



