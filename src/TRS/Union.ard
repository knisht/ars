\import Algebra.Meta
\import Algebra.Ring.Localization
\import Confluence
\import Data.Bool
\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Function.Meta (repeat)
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation
\import Set
\import Set.Fin
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.Union.TopLevel
\import TRS.Utils

\func JointFSignature {Sort : \Set} (A B : FSignature Sort) : FSignature Sort \cowith
  | symbol s => A.symbol s `Or` B.symbol s
  | domain symb => \case \elim symb \with {
    | inl a => A.domain a
    | inr b => B.domain b
  }

\func JointIndexedSet {A : \Type} (L R : IndexedSet A) : IndexedSet A \cowith
  | J => L.J `Or` R.J
  | get x => \case \elim x \with {
    | inl a => L.get a
    | inr b => R.get b
  }

\module Injections \where {
  \func inject-term-left {Sort : \Set}
                         (envL envR : FSignature Sort)
                         {s : Sort} {c : List Sort} {mc : MetaContext Sort}
                         (term : Term envL c s mc) : Term (JointFSignature envL envR) c s mc \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-left envL envR (choosing i))
    | func f choosing => func (inl f) (\lam i => inject-term-left envL envR (choosing i))

  \func inject-term-right {Sort : \Set}
                          (envL envR : FSignature Sort)
                          {s : Sort}
                          {c : List Sort}
                          {mc : MetaContext Sort}
                          (term : Term envR c s mc) : Term (JointFSignature envL envR) c s mc \elim term
    | var index p => var index p
    | metavar m choosing => metavar m (\lam i => inject-term-right envL envR (choosing i))
    | func f choosing => func (inr f) (\lam i => inject-term-right envL envR (choosing i))

  \func promote-rewrite-rule-left {Sort : \Set}
                                  (envL envR : FSignature Sort)
                                  (rule : RewriteRule envL)
    : RewriteRule (JointFSignature envL envR) \cowith
    | s => rule.s
    | meta-context => rule.meta-context
    | l => inject-term-left envL envR rule.l
    | r => inject-term-left envL envR rule.r
    | l-is-func => promote-injection-left {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \lemma promote-injection-left {Sort : \Set}
                                    {envL envR : FSignature Sort}
                                    {context : List Sort}
                                    {s : Sort}
                                    {mc : MetaContext Sort}
                                    (t : Term envL context s mc)
                                    (t-is-func : FunctionalRoot {envL} t) : FunctionalRoot {JointFSignature envL envR} (inject-term-left envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointFSignature envL envR}
    }

  \func promote-rewrite-rule-right {Sort : \Set}
                                   (envL envR : FSignature Sort)
                                   (rule : RewriteRule envR)
    : RewriteRule (JointFSignature envL envR) \cowith
    | s => rule.s
    | meta-context => rule.meta-context
    | l => inject-term-right envL envR rule.l
    | r => inject-term-right envL envR rule.r
    | l-is-func => promote-injection-right {_} {envL} {envR} rule.l rule.l-is-func
    \where {
      \lemma promote-injection-right {Sort : \Set}
                                     {envL envR : FSignature Sort}
                                     {context : List Sort}
                                     {s : Sort}
                                     {mc : MetaContext Sort}
                                     (t : Term envR context s mc)
                                     (t-is-func : FunctionalRoot {envR} t) : FunctionalRoot {JointFSignature envL envR} (inject-term-right envL envR t) \elim t, t-is-func
        | func f choosing, T-has-functional-root => T-has-functional-root {JointFSignature envL envR}
    }

  \func promote-indexed-set-left {Sort : \Set} {envL envR : FSignature Sort} (rules : IndexedSet (RewriteRule envL)) : IndexedSet (RewriteRule (JointFSignature envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-left envL envR (rules.get j)

  \func promote-indexed-set-right {Sort : \Set} {envL envR : FSignature Sort} (rules : IndexedSet (RewriteRule envR)) : IndexedSet (RewriteRule (JointFSignature envL envR)) \cowith
    | J => rules.J
    | get j => Injections.promote-rewrite-rule-right envL envR (rules.get j)
}

\func JointRules {Sort : \Set} {envL envR : FSignature Sort}
                 (L-rules : IndexedSet (RewriteRule envL))
                 (R-rules : IndexedSet (RewriteRule envR))
  : IndexedSet (RewriteRule (JointFSignature envL envR)) =>
  \let
    | injected-left-set : IndexedSet (RewriteRule (JointFSignature envL envR)) => Injections.promote-indexed-set-left {_} {envL} {envR} L-rules
    | injected-right-set : IndexedSet (RewriteRule (JointFSignature envL envR)) => Injections.promote-indexed-set-right {_} {envL} {envR} R-rules
  \in JointIndexedSet injected-left-set injected-right-set


\instance JointHRS {Sort : \Set} {envL envR : FSignature Sort} {mc : MetaContext Sort}
                   (L : SimpleHigherOrderTermRewritingSystem envL mc)
                   (R : SimpleHigherOrderTermRewritingSystem envR mc)
: SimpleHigherOrderTermRewritingSystem (JointFSignature L.env R.env)
  | set-of-rules => JointRules {_} {envL} {envR} L.set-of-rules R.set-of-rules
  | meta-context => mc

\module Confluence \where {
  \data Color | red | blue \where {
    \func flip (c : Color) : Color \elim c
      | red => blue
      | blue => red

    \lemma double-flip (c : Color) : Color.flip (Color.flip c) = c \elim c
      | red => idp
      | blue => idp

    \lemma flip-contradiction {c : Color} (eq : c = flip c) : Empty \elim c
      | red => contradiction
      | blue => contradiction
  }

  \class TheoremContext {
    | Sort' : \Set
    | envL : FSignature Sort'
    | envR : FSignature Sort'
    | L-rules : IndexedSet (LinearRewriteRule envL)
    | R-rules : IndexedSet (LinearRewriteRule envR)

    \func colored-env (color : Color) : FSignature Sort' \elim color
      | red => envL
      | blue => envR

    \func colored-set-of-rules (color : Color) : IndexedSet (LinearRewriteRule (colored-env color)) \elim color
      | red => L-rules
      | blue => R-rules

    \func monochrome-reduction (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (A B : Term (colored-env color) context s mc) : \Type =>
      RewriteRelation {colored-env color} (colored-set-of-rules color) A B

    \func inject-monochrome-term (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                                 (t : Term (colored-env color) context s mc) : Term env context s mc \elim color
      | red => Injections.inject-term-left envL envR t
      | blue => Injections.inject-term-right envL envR t
      \where {
        \data InjectionWitness (color : Color) {context : List Sort'} {s : Sort'} {msig : MetaContext Sort'} (t : Term env context s msig) \elim t
          | func f choosing => iw-func (color-of-root f = color)
                                       (\Pi (i : Fin (length (env.domain f))) -> InjectionWitness color (choosing i))
          | metavar m choosing => iw-mvar (\Pi (i : Fin (length (msig.m-domain m))) -> InjectionWitness color (choosing i))
          | var _ _ => iw-var

        \lemma generate-injection-witness (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                                          (t : Term (colored-env color) context s mc) : InjectionWitness color (inject-monochrome-term color t) \elim color, t
          | red, func f choosing => iw-func idp (\lam i => generate-injection-witness red (choosing i))
          | red, var index p => iw-var
          | red, metavar m choosing => iw-mvar (\lam i => generate-injection-witness red (choosing i))
          | blue, var index p => iw-var
          | blue, metavar m choosing => iw-mvar (\lam i => generate-injection-witness blue (choosing i))
          | blue, func f choosing => iw-func idp (\lam i => generate-injection-witness blue (choosing i))
      }

    \data HasColoredRoot (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (term : Term env context s mc) \elim color, term
      | red, func (inl _) _ => red-func-root
      | blue, func (inr _) _ => blue-func-root
      \where {
        \lemma equalize-colors (color color' : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                               (f : env.symbol s)
                               (choosing choosing' : \Pi (index : Fin (length (env.domain f))) -> Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc)
                               (hcl1 : HasColoredRoot color (func f choosing))
                               (hcl2 : HasColoredRoot color' (func f choosing'))
          : color = color' \elim color, color', f, hcl1, hcl2
          | red, red, inl s1, red-func-root, red-func-root => idp
          | blue, blue, inr s1, blue-func-root, blue-func-root => idp
          | red, blue, inr b, (), hcl2
          | blue, red, inl a, (), hcl2

        \lemma reorganize (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                          {f : env.symbol s}
                          {choosing : \Pi (index : Fin (length (env.domain f))) -> Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc}
                          (hcl : HasColoredRoot color (func f choosing))
          : color-of-root f = color \elim color, f, hcl
          | red, inl s1, red-func-root => idp
          | blue, inr s1, blue-func-root => idp
      }

    \func color-of-root {s : Sort'} (f : env.symbol s) : Color \elim f
      | inl _ => red
      | inr _ => blue

    \func env : FSignature => JointFSignature envL envR

    \func colored-rules (color : Color) : IndexedSet (RewriteRule env) \elim color
      | red => Injections.promote-indexed-set-left {Sort'} {envL} {envR} L-rules
      | blue => Injections.promote-indexed-set-right {Sort'} {envL} {envR} R-rules
  }

  \open TheoremContext

  \func break-down-rule {tc : Confluence.TheoremContext}
                        (idx : J {JointRules {_} {Confluence.envL} {Confluence.envR} tc.L-rules tc.R-rules})
    : \Sigma (new-r : Term (colored-env (color-of-idx idx)) nil (RewriteRule.s {get {JointRules {_} {Confluence.envL} {Confluence.envR} tc.L-rules tc.R-rules} idx}) (RewriteRule.meta-context {get {JointRules {_} {Confluence.envL} {Confluence.envR} tc.L-rules tc.R-rules} idx}))
             (inject-monochrome-term (color-of-idx idx) new-r = RewriteRule.r {get {JointRules {_} {Confluence.envL} {Confluence.envR} tc.L-rules tc.R-rules} idx}) \elim idx
    | inl left-idx => \let rule : RewriteRule envL => L-rules.get left-idx \in (rule.r, idp)
    | inr right-idx => \let rule : RewriteRule envR => R-rules.get right-idx \in (rule.r, idp)

  \func get-colored-root-for-l
    {tc : TheoremContext}
    (idx : J {JointRules {_} {Confluence.envL} {Confluence.envR} tc.L-rules tc.R-rules})
    : HasColoredRoot (color-of-idx idx) (RewriteRule.l {get {JointRules {_} {Confluence.envL} {Confluence.envR} tc.L-rules tc.R-rules} idx}) \elim idx
    | inl a => \let rule : RewriteRule envL => L-rules.get a \in extract-left-l red rule.l rule.l-is-func
    | inr b => \let rule : RewriteRule envR => R-rules.get b \in extract-left-l blue rule.l rule.l-is-func
    \where {
      \func extract-left-l {tc : TheoremContext} (color : Color) {s : Sort'} {mc : MetaContext Sort'} (t : Term (colored-env color) nil s mc) (fr : FunctionalRoot {colored-env color} t) : HasColoredRoot color (inject-monochrome-term color t) \elim color, t, fr
        | red, func f choosing, T-has-functional-root => red-func-root
        | blue, func f choosing, T-has-functional-root => blue-func-root
    }

  \func color-of-idx {tc : TheoremContext}
                     (idx : J {JointRules {_} {Confluence.envL} {Confluence.envR} tc.L-rules tc.R-rules}) : Color \elim idx
    | inl a => red
    | inr b => blue

  \record Inherited {tc : TheoremContext} (color : Color) (s : Sort') (lp : LinearPattern (colored-env color) nil s) (r : Term (colored-env color) nil s (LinearMetaContext {colored-env color} lp))
    | idx : J {JointRules {_} {envL} {envR} L-rules R-rules}
    | i-sort-eq : s = RewriteRule.s {get {JointRules {_} {envL} {envR} L-rules R-rules} idx}
    | i-meta-eq : (LinearMetaContext {colored-env color} lp) = RewriteRule.meta-context {get {JointRules {_} {envL} {envR} L-rules R-rules} idx}
    | idx-l-eq : RewriteRule.l {get {JointRules {_} {envL} {envR} L-rules R-rules} idx} = transport2 (\lam sort mc => Term env nil sort mc) (i-sort-eq {\this}) i-meta-eq (LinearPattern.convert-to-injected-term color lp)
    | ifx-r-eq : RewriteRule.r {get {JointRules {_} {envL} {envR} L-rules R-rules} idx} = transport2 (\lam sort mc => Term env nil sort mc) i-sort-eq i-meta-eq (inject-monochrome-term color r)

  \data TopLevelColoredReduction {tc : TheoremContext} (color : Color) {mc : MetaContext env.Sort} {context : List env.Sort} {s : env.Sort} (A B : Term env context s mc) \elim A, B
    | A, B =>
    rewrite-with-rule-colored (HasColoredRoot color A)
                              (linear-pattern : LinearPattern (colored-env color) nil s)
                              (r : Term (colored-env color) nil s (LinearMetaContext {colored-env color} linear-pattern))
                              (l-is-func : FunctionalRoot {colored-env color} (LinearPattern.convert-to-term {colored-env color} linear-pattern))
                              (substitution : MetaSubstitution env context (LinearMetaContext {colored-env color} linear-pattern) mc)
                              (left-coherence : MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-injected-term color {nil} {s} linear-pattern) SubList.sublist-trivial-skip) SubList.identity substitution = A)
                              (right-coherence : MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color r) SubList.sublist-trivial-skip) SubList.identity substitution = B)
                              (inherited : Inherited color s linear-pattern r)
    | func f-A choosing-A, func f-B choosing-B =>
    rewrite-with-parameter-f-colored (p : f-A = f-B)
                                     (color-of-root f-A = color)
                                     (i : Fin (length (domain {env} f-A)))
                                     (tlcr : TopLevelColoredReduction color (choosing-A i) (transport-chooser-f {env} p choosing-B i))
                                     (eq : \Pi (j : Fin (length (domain {env} f-A))) (j = i -> Empty) -> (choosing-A j) = (transport-chooser-f {env} p choosing-B j))
    \where {
      \lemma extract-root-coloring {tc : TheoremContext} {color : Color} {mc : MetaContext Sort'} {context : List env.Sort} {s : env.Sort} {A B : Term env context s mc} (tlcr : TopLevelColoredReduction color A B) : HasColoredRoot color A
      \elim color, A, B, tlcr
        | color, A, B, rewrite-with-rule-colored h _ _ _ _ _ _ _ => h
        | color, func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 i tlcr eq => \case \elim color, \elim f-A, \elim choosing-A, \elim p1 \with {
          | red, inl a, choosing-A, p1 => red-func-root
          | blue, inr b, choosing-A, p1 => blue-func-root
        }
    }

  \data BorderedParallelReduction {tc : TheoremContext}
                                  (global-color : Color)
                                  (color : Maybe Color)
                                  {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                                  (A B : Term env context s mc) \elim A
    | A => equal-trees (A = B)
    | func f choosing =>
    parallelization-f
      (mediator : \Pi (index : Fin (length (env.domain f))) ->
          Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc)
      (\Pi (i : F-param-index {env} f) -> \Sigma
        (someColor : Maybe Color)
        ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
        (BorderedParallelReduction global-color someColor (choosing i) (mediator i)))
      (ColorwiseReduction global-color color (func f mediator) B)
    \where {
      \func append-tlcr
        {tc : TheoremContext}
        {global-color : Color}
        {color : Maybe Color}
        {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
        (A B : Term env context s mc)
        (bpr : BorderedParallelReduction global-color color A B)
        (C : Term env context s mc)
        (B~>*C : TClosure (TopLevelColoredReduction global-color) B C)
        : \Sigma (someColor : Maybe Color) (BorderedParallelReduction global-color someColor A C) \elim color, A, bpr
        | color, A, equal-trees p => \let hcr => TopLevelColoredReduction.extract-root-coloring (TClosure.extract B~>*C).2 \in \case \elim A, \elim B, \elim global-color, \elim B~>*C, \elim hcr, \elim p \with {
          | A, func (inl s1) choosing, red, B~>*C, red-func-root, idp => (just red, parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite B~>*C idp))
          | A, func (inr s1) choosing, blue, B~>*C, blue-func-root, idp => (just blue, parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite B~>*C idp))
        }
        | nothing, func f choosing, parallelization-f mediator _x (cr-skip p) => (just global-color, parallelization-f mediator _x (cr-rewrite (rewrite p B~>*C) idp))
        | just a, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => (just global-color, parallelization-f mediator _x (cr-rewrite (TClosure.compose (rewrite p t) B~>*C) idp))
    }

  \data ColorwiseReduction {tc : TheoremContext}
                           {context : List Sort'}
                           {s : Sort'}
                           {mc : MetaContext Sort'}
                           (global-color : Color)
                           (color : Maybe Color) (A B : Term env context s mc) \elim color
    | nothing => cr-skip (A = B)
    | just color => cr-rewrite (TClosure (TopLevelColoredReduction color) A B) (global-color = color)

  \func TrichromaticParallelReduction {tc : TheoremContext} {mc : MetaContext Sort'} {context : List Sort'} {s : Sort'} (A B : Term env context s mc) : \Type =>
    \Sigma (global-color : Color) (color : Maybe Color) (BorderedParallelReduction global-color color A B)

  \func ConfluentialSystem (env : FSignature) (rules : IndexedSet (RewriteRule env)) : \Type =>
    \Pi {mc : MetaContext Sort} {context : List Sort} {s : Sort}
        (A B C : Term env context s mc)
        (TClosure (RewriteRelation rules) A B)
        (TClosure (RewriteRelation rules) A C) -> StraightJoin B C (TClosure (\lam x y => \Sigma (rd : RewriteRelation rules x y) (FunctionalWitness rd)))

  \data FunctionalWitness {env : FSignature} {rules : IndexedSet (RewriteRule env)} {context : List Sort} {s : Sort} {mc : MetaContext Sort} {t u : Term env context s mc} (rd : RewriteRelation rules t u) \elim t, u, rd
    | A, B, rewrite-with-rule _ _ _ _ _ => rule-rewriting
    | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f _ _ rd _ => param-rewriting (FunctionalWitness rd)

  \record StraightJoin {A : \Type} (a b : A) (rel : A -> A -> \Type)
    | common-reduct : A
    | a~>cr : rel a common-reduct
    | b~>cr : rel b common-reduct

  \func bpr-confluence {tc : TheoremContext} {gc1 gc2 : Color} (color1 color2 : Maybe Color) {context : List Sort'} {s : Sort'}
                       {A B C : PureTerm env context s}
                       (A~>B : BorderedParallelReduction gc1 color1 A B)
                       (A~>C : BorderedParallelReduction gc2 color2 A C)
                       (left-confluence : ConfluentialSystem envL L-rules)
                       (right-confluence : ConfluentialSystem envR R-rules)
    : \Sigma (D : PureTerm env context s)
             (color3 : Maybe Color)
             (color4 : Maybe Color)
             (BorderedParallelReduction gc2 color3 B D)
             (BorderedParallelReduction gc1 color4 C D) \elim color1, color2, A, B, C, A~>B, A~>C
    | color1, color2, A, B, C, equal-trees p, rd => (C, color2, color1, rewriteI p rd, equal-trees idp)
    | color1, color2, A, B, C, rd, equal-trees p => (B, color2, color1, equal-trees idp, rewriteI p rd)
    | nothing, nothing, func f choosing, B, C, parallelization-f mediator choosing->med (cr-skip famed=B), parallelization-f mediator' choosing->med' (cr-skip famed'=C)
    => \let | inner-confluences i => bpr-confluence (choosing->med i).1 (choosing->med' i).1 (choosing->med i).3 (choosing->med' i).3 left-confluence right-confluence
            | D => func {env} f (\lam i => (inner-confluences i).1)
            | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).2, (inner-confluences i).4))
            | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (inner-confluences i).1) (\lam i => ((inner-confluences i).3, (inner-confluences i).5))
       \in (func f (\lam i => (inner-confluences i).1),
            color-1,
            color-2,
            rewriteI famed=B (parallelization-f mediator-1 inrd-1 cwr-1),
            rewriteI famed'=C (parallelization-f mediator-2 inrd-2 cwr-2))
    | nothing, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-skip p), parallelization-f mediator' choosing=>med' (cr-rewrite med'~>C gc2=right-color) =>
      \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
           | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
           | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
           | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
           | rd : BorderedParallelReduction gc2 color-1 (func f mediator) (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-1 inrd-1 cwr-1
           | (rightmost-reduct, flr~>rr, mcl, C=>rr) => unify-top right-color gc1 f mediator' mediator-2 C med'~>C inrd-2
           | (X, c1, B=>X, c2, C=>X) => unwrap-cwr (func f mediator) C (func f mediator-2) (first-level-reduct) (rightmost-reduct) cwr-2 (rewrite (gc2=right-color) flr~>rr) rd C=>rr left-confluence right-confluence
      \in (X,
           c1,
           c2,
           rewriteI p B=>X,
           C=>X)
    | just left-color, nothing, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-skip p) =>
      \let | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
           | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
           | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
           | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
           | (leftmost-reduct, flr~>lr, mcl, B=>lr) => unify-top left-color gc2 f mediator mediator-1 B med~>B inrd-1
           | rd : BorderedParallelReduction gc1 color-2 (func f mediator') (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-2 inrd-2 cwr-2
           | (X, c1, C=>X, c2, B=>X) => unwrap-cwr (func f mediator') B (func f mediator-1) (first-level-reduct) (leftmost-reduct) cwr-1 (rewrite (gc1=left-color) flr~>lr) rd B=>lr left-confluence right-confluence
      \in (X,
           c2,
           c1,
           B=>X,
           rewriteI p C=>X)
    | just left-color, just right-color, func f choosing, B, C, parallelization-f mediator choosing=>med (cr-rewrite med~>B gc1=left-color), parallelization-f mediator' choosing=>med' (cr-rewrite med~>C gc2=right-color)
    => \let
        | hcl-f-left : HasColoredRoot left-color (func f mediator) => TopLevelColoredReduction.extract-root-coloring (TClosure.extract med~>B).2
        | hcl-f-right : HasColoredRoot right-color (func f mediator') => TopLevelColoredReduction.extract-root-coloring (TClosure.extract med~>C).2
        | lcolor=rcolor : left-color = right-color => HasColoredRoot.equalize-colors left-color right-color f mediator mediator' hcl-f-left hcl-f-right
        | joined-mediators i => bpr-confluence (choosing=>med i).1 (choosing=>med' i).1 (choosing=>med i).3 (choosing=>med' i).3 left-confluence right-confluence
        | first-level-reduct => func {env} f (\lam i => (joined-mediators i).1)
        | (color-1, mediator-1, inrd-1, cwr-1) => collect-reductions-together-raw f mediator (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).2, (joined-mediators i).4))
        | (color-2, mediator-2, inrd-2, cwr-2) => collect-reductions-together-raw f mediator' (\lam i => (joined-mediators i).1) (\lam i => ((joined-mediators i).3, (joined-mediators i).5))
        | rd : BorderedParallelReduction gc2 color-1 (func f mediator) (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-1 inrd-1 cwr-1
        | rd' : BorderedParallelReduction gc1 color-2 (func f mediator') (func f (\lam i => (joined-mediators i).1)) => parallelization-f mediator-2 inrd-2 cwr-2
        | (leftmost-reduct, flr~>lr, clr-b, B=>lr) => unify-top left-color left-color f mediator mediator-1 B med~>B (rewrite (lcolor=rcolor *> inv gc2=right-color) inrd-1)
        | (rightmost-reduct, flr~>rr, clr-c, C=>rr) => unify-top right-color right-color f mediator' mediator-2 C med~>C (rewrite (inv lcolor=rcolor *> inv gc1=left-color) inrd-2)
        | (X, c1, B=>X, c2, C=>X) => unwrap-double-cwr B C (func f mediator-1) (func f mediator-2) first-level-reduct leftmost-reduct rightmost-reduct (rewrite (inv gc2=right-color) cwr-1) (rewrite (inv lcolor=rcolor *> inv gc1=left-color) cwr-2) (rewriteI lcolor=rcolor flr~>lr) flr~>rr (rewriteI lcolor=rcolor B=>lr) C=>rr left-confluence right-confluence
       \in (X, c1, c2, (rewrite gc2=right-color B=>X), rewrite (gc1=left-color *> lcolor=rcolor) C=>X)
    \where {
      \func unwrap-cwr
        {tc : TheoremContext} {gc1 gc2 : Color} {color3 color4 : Maybe Color} {context : List Sort'} {s : Sort'}
        (T1 T2 A B C : PureTerm env context s) {color-2 : Maybe Color}
        (cwr : ColorwiseReduction gc1 color-2 A B) (A~>*C : TClosure (TopLevelColoredReduction gc2) A C)
        (T1=>B : BorderedParallelReduction gc2 color3 T1 B) (T2=>C : BorderedParallelReduction gc1 color4 T2 C)
        (left-confluence : ConfluentialSystem envL L-rules)
        (right-confluence : ConfluentialSystem envR R-rules)
        :
        \Sigma (X : PureTerm env context s) (c1 : Maybe Color) (BorderedParallelReduction gc2 c1 T1 X) (c2 : Maybe Color) (BorderedParallelReduction gc1 c2 T2 X) \elim color-2, cwr
        | nothing, cr-skip p => \let (cl-1, t1=>X) => BorderedParallelReduction.append-tlcr T1 B T1=>B C (rewriteI p A~>*C) \in (C, cl-1, t1=>X, color4, T2=>C)
        | just color, cr-rewrite A~>*B p =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs color gc2 A~>*B A~>*C left-confluence right-confluence
               | (cl-1, t1=>X) => BorderedParallelReduction.append-tlcr T1 B T1=>B X B~>*X
               | (cl-2, t2=>X) => BorderedParallelReduction.append-tlcr T2 C T2=>C X (rewrite p C~>*X)
          \in (X, cl-1, t1=>X, cl-2, t2=>X)

      \func unwrap-double-cwr
        {tc : TheoremContext} {gc1 : Color} {color3 color4 : Maybe Color} {context : List Sort'} {s : Sort'}
        (T1 T2 A A' E B C : PureTerm env context s) {color-2 color-1 : Maybe Color}
        (cwr-1 : ColorwiseReduction gc1 color-2 A E)
        (cwr-2 : ColorwiseReduction gc1 color-1 A' E)
        (A~>*B : TClosure (TopLevelColoredReduction gc1) A B)
        (A'~>*C : TClosure (TopLevelColoredReduction gc1) A' C)
        (T1=>B : BorderedParallelReduction gc1 color3 T1 B)
        (T2=>C : BorderedParallelReduction gc1 color4 T2 C)
        (left-confluence : ConfluentialSystem envL L-rules)
        (right-confluence : ConfluentialSystem envR R-rules)
        :
        \Sigma (X : PureTerm env context s) (c1 : Maybe Color) (BorderedParallelReduction gc1 c1 T1 X) (c2 : Maybe Color) (BorderedParallelReduction gc1 c2 T2 X) \elim color-2, color-1, cwr-1, cwr-2
        | nothing, nothing, cr-skip p, cr-skip p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 A~>*B (rewrite {1} (p *> inv p1) A'~>*C) left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | nothing, just color, cr-skip p, cr-rewrite A'~>*E p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 (TClosure.compose (transport (\lam cl => TClosure (TopLevelColoredReduction cl) A' E) (inv p1) A'~>*E) (rewrite {1} (inv p) A~>*B)) A'~>*C left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | just color, nothing, cr-rewrite A~>*E p, cr-skip p1 =>
          \let | (X, B~>*X, C~>*X) => join-different-tlcrs gc1 gc1 A~>*B (TClosure.compose ((transport (\lam cl => TClosure (TopLevelColoredReduction cl) A E) (inv p) A~>*E)) (rewrite {1} (inv p1) A'~>*C)) left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X B~>*X
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X C~>*X
          \in (X, c1, T1=>X, c2, T2=>X)
        | just color, just color1, cr-rewrite A~>*E p, cr-rewrite A'~>*E p1 =>
          \let | (M1, B~>*M1, E~>*M1) => join-different-tlcrs gc1 gc1 (A~>*B) (rewrite p A~>*E) left-confluence right-confluence
               | (M2, E~>*M2, C~>*M2) => join-different-tlcrs gc1 gc1 (transport (\lam cl => TClosure (TopLevelColoredReduction cl) A' E) (inv p1) A'~>*E) A'~>*C left-confluence right-confluence
               | (X, M1~>*X, M2~>*X) => join-different-tlcrs gc1 gc1 E~>*M1 E~>*M2 left-confluence right-confluence
               | (c1, T1=>X) => BorderedParallelReduction.append-tlcr _ _ T1=>B X (TClosure.compose B~>*M1 M1~>*X)
               | (c2, T2=>X) => BorderedParallelReduction.append-tlcr _ _ T2=>C X (TClosure.compose C~>*M2 M2~>*X)
          \in (X, c1, T1=>X, c2, T2=>X)

      \func reorganize-colors-here {tc : TheoremContext} {gc : Color} {someColor : Maybe Color} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                                   {A B : Term env context s mc} (A~>B : BorderedParallelReduction gc someColor A B)
        : \Sigma (someColor' : Maybe Color) (Or (someColor' = nothing) (someColor' = just gc)) (BorderedParallelReduction gc someColor' A B) \elim someColor, A, A~>B
        | _, A, equal-trees p => (nothing, inl idp, equal-trees p)
        | nothing, func f choosing, rd => (nothing, inl idp, rd)
        | just a, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => (just a, rewrite p (inr idp), parallelization-f mediator _x (cr-rewrite t p))

      \func join-different-tlcrs {tc : TheoremContext} (color1 color2 : Color) {context : List Sort'} {s : Sort'}
                                 {A B C : PureTerm env context s}
                                 (A~>B : TClosure (TopLevelColoredReduction color1) A B)
                                 (A~>C : TClosure (TopLevelColoredReduction color2) A C)
                                 (left-confluence : ConfluentialSystem envL L-rules)
                                 (right-confluence : ConfluentialSystem envR R-rules)
        : \Sigma (X : PureTerm env context s) (TClosure (TopLevelColoredReduction color2) B X) (TClosure (TopLevelColoredReduction color1) C X)
      \elim color1, color2
        | red, red => join-tlcrs red A B C A~>B A~>C left-confluence
        | red, blue => \let | a => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>B).2
                            | b => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>C).2 \in \case \elim A, \elim a, \elim b \with {
          }
        | blue, red => \let | a => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>B).2
                            | b => TopLevelColoredReduction.extract-root-coloring (TClosure.extract A~>C).2 \in \case \elim A, \elim a, \elim b \with {
          }
        | blue, blue => join-tlcrs blue A B C A~>B A~>C right-confluence

      \func gather-reduction {tc : TheoremContext}
                             (color : Color)
                             (sclr : Maybe Color)
                             (eq : (sclr = nothing) `Or` (sclr = just color))
                             {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} {B lr X : Term env context s mc}
                             (B=>lr : BorderedParallelReduction color sclr B lr)
                             (lr~>X : TClosure (TopLevelColoredReduction color) lr X)
        : BorderedParallelReduction color (just color) B X
      \elim sclr, eq, B, B=>lr
        | sclr, _, B, equal-trees p => \let x => TopLevelColoredReduction.extract-root-coloring (TClosure.extract lr~>X).2 \in \case \elim color, \elim lr, \elim x, \elim p, \elim lr~>X \with {
          | red, func (inl f) choosing, red-func-root, p, lr~>X => rewrite p (parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite lr~>X idp))
          | blue, func (inr f) choosing, blue-func-root, p, lr~>X => rewrite p (parallelization-f choosing (\lam i => (nothing, inl idp, equal-trees idp)) (cr-rewrite lr~>X idp))
        }
        | nothing, inl a, func f choosing, parallelization-f mediator _x (cr-skip p) => parallelization-f mediator _x (cr-rewrite (rewrite p lr~>X) idp)
        | just a1, inl a, func f choosing, parallelization-f mediator _x c => contradiction
        | nothing, inr b, func f choosing, parallelization-f mediator _x c => contradiction
        | just a, inr b, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => parallelization-f mediator _x (cr-rewrite (TClosure.compose (rewriteI (Maybe.unjust-eq b) t) lr~>X) idp)

      \func twist-colors {c1 c2 c3 : Maybe Color} (c1or : Or (c1 = nothing) (c1 = c2)) (c2or : Or (c2 = nothing) (c2 = c3)) : Or (c1 = nothing) (c1 = c3) \elim c1or
        | inl a => inl a
        | inr b => rewrite b c2or

      \func twist-colors' {c1 c2 c3 : Maybe Color} (c1or : Or (c1 = c2) (c1 = nothing)) (c2or : Or (c2 = nothing) (c2 = c3)) : Or (c1 = nothing) (c1 = c3) \elim c1or
        | inl a => rewrite a c2or
        | inr b => inl b
    }

  \func unify-top {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color color' : Color)
                  (f : env.symbol s)
                  (choosing-A choosing-C : \Pi (index : Fin (length (env.domain f))) -> PureTerm env (context ++ (f env.!!param index)) (f env.!!sort index))
                  (B : PureTerm env context s)
                  (A~>B : TClosure (TopLevelColoredReduction color) (func {env} f choosing-A) B)
                  (inner-reductions : \Pi (i : F-param-index {env} f) ->
                      \Sigma (someColor : Maybe Color)
                             ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
                             (BorderedParallelReduction color' someColor (choosing-A i) (transport-chooser-f {env} idp choosing-C i)))
    : \Sigma (X : PureTerm env context s)
             (TClosure (TopLevelColoredReduction color) (func {env} f choosing-C) X)
             (mcolor : Maybe Color)
             (BorderedParallelReduction color' mcolor B X) =>
    \let
      | (t, rho, t[rho]=A, root-colors) => decompose-term color (func f choosing-A)
      | (u, lu[rho]=B, t~>*u) => iterate-decomposition (LinearTerm.convert-to-term {colored-env color} t) rho B (rewrite unwrap-injection t[rho]=A) A~>B root-colors
      | injected-u : Term env context s (LinearMetaContextT {colored-env color} (t)) => inject-monochrome-term color u
      | eqs3 : (func {env} f choosing-A) = (MetaSubstitution.apply {env} (convert-to-injected-term color t) SubList.sublist-trivial-skip rho) => inv t[rho]=A
      | witnesses => inject-linear-term.generate-injection-witness color t
      | (sigma, C=t[sigma], reds) => alternate-subst {_} color color' (func f choosing-C) t rho (root-colors) nothing (inl idp) (rewriteI eqs3 (parallelization-f choosing-C inner-reductions (cr-skip idp)))
      | uni-right => TClosure.lift {_} {_} {\lam x y => \Sigma (rrd : monochrome-reduction color x y) (FunctionalWitness {colored-env color} {colored-set-of-rules color} rrd) } {TopLevelColoredReduction color} (\lam trm => (MetaSubstitution.apply {env} (inject-monochrome-term color trm) SubList.sublist-trivial-skip sigma)) (\lam tlcr => lift-relation color sigma tlcr.1 tlcr.2) (LinearTerm.convert-to-term {colored-env color} t) u t~>*u
      | (mcl, uni-left) => unify-left color' color injected-u (inject-monochrome-term.generate-injection-witness color u) SubList.sublist-trivial-skip rho sigma reds
    \in ((MetaSubstitution.apply {env} injected-u SubList.sublist-trivial-skip sigma),
         (rewrite C=t[sigma] (rewriteI unwrap-injection uni-right)),
         mcl,
         (rewriteI lu[rho]=B uni-left))
    \where {
      \func iterate-decomposition
        {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
        {color : Color}
        (t : Term (colored-env color) context s inner-mc)
        (rho : MetaSubstitution env nil inner-mc mc)
        {A : Term env context s mc}
        (B : Term env context s mc)
        (teq : (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-skip rho) = A)
        (A~>*B : TClosure (TopLevelColoredReduction color) A B)
        (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip color) (rho m))
        : \Sigma (u : Term (colored-env color) context s inner-mc)
                 (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.sublist-trivial-skip rho = B)
                 (TClosure (\lam x y => \Sigma (rd : monochrome-reduction color x y) (FunctionalWitness {colored-env color} {colored-set-of-rules color} rd)) (t) u) \elim A~>*B
        | tc-basic A~>B =>
          \let | (u, lu[rho]=B, t~>u, fw) => decompose-along-reduction color t B rho root-colors (rewrite teq A~>B)
          \in (u, lu[rho]=B, tc-basic (t~>u, fw))
        | tc-connect C A->C C~>*B =>
          \let | (c, meq, rd, fw) => decompose-along-reduction color t C rho root-colors (rewrite teq A->C)
               | (u, mu, tcl) => iterate-decomposition c rho B (meq) (C~>*B) root-colors \in (u, mu, tc-connect c (rd, fw) tcl)

      \func convert-to-injected-term {tc : Confluence.TheoremContext} (color : Confluence.Color) {context : List Confluence.Sort'} {s : Confluence.Sort'} (term : LinearTerm (colored-env color) context s) : Term env context s (LinearMetaContextT {colored-env color} (term)) \elim color, term
        | red, lt-func f choosing => func (inl f) (\lam i => LinearTerm.upgrade-metavariables-t {env} (\lam i => LinearMetaContextT {envL} (choosing i)) (convert-to-injected-term red (choosing i)))
        | red, lt-full-metavar => metavar idp (\lam i => var i idp)
        | red, lt-var index p => var index p
        | blue, lt-func f choosing => func (inr f) (\lam i => LinearTerm.upgrade-metavariables-t {env} (\lam i => LinearMetaContextT {envR} (choosing i)) (convert-to-injected-term blue (choosing i)))
        | blue, lt-full-metavar => metavar idp (\lam i => var i idp)
        | blue, lt-var index p => var index p

      \lemma unwrap-injection {tc : TheoremContext} {color : Color} {context : List Sort'} {s : Sort'} (t : LinearTerm (colored-env color) context s) :
        inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t) = convert-to-injected-term color {context} {s} t \elim color, t
        | red, lt-func f choosing => pmap (func {env} (inl f))
            (ext (\lam index => rewriteI (unwrap-injection {_} {red} (choosing index)) (swap red (\lam i => LinearMetaContextT {envL} (choosing i)) (LinearTerm.convert-to-term {envL} (choosing index)))))
        | red, lt-full-metavar => idp
        | red, lt-var index p => idp
        | blue, lt-func f choosing => pmap (func {env} (inr f))
            (ext (\lam index => rewriteI (unwrap-injection {_} {blue} (choosing index)) (swap blue (\lam i => LinearMetaContextT {envR} (choosing i)) (LinearTerm.convert-to-term {envR} (choosing index)))))
        | blue, lt-full-metavar => idp
        | blue, lt-var index p => idp
        \where {
          \lemma swap
            {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {n : Nat} {i : Fin n} (msigs : \Pi (i : Fin n) -> MetaContext Sort')
            (t : Term (colored-env color) context s (msigs i)) :
            inject-monochrome-term color (LinearTerm.upgrade-metavariables-t {colored-env color} msigs t) =
            LinearTerm.upgrade-metavariables-t {env} msigs (inject-monochrome-term color t) \elim color, t
            | red, var index p => idp
            | red, metavar m choosing =>
              \let extt : (\lam i1 => Injections.inject-term-left envL envR (LinearTerm.upgrade-metavariables-t {envL} msigs (choosing i1))) = (\lam i1 => (LinearTerm.upgrade-metavariables-t {env} msigs (Injections.inject-term-left envL envR (choosing i1)))) => ext (\lam i => swap red msigs (choosing i))
              \in rewrite extt idp
            | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => (swap red msigs (choosing index))))
            | blue, var index p => idp
            | blue, metavar m choosing =>
              \let extt : (\lam i1 => Injections.inject-term-right envL envR (LinearTerm.upgrade-metavariables-t {envR} msigs (choosing i1))) = (\lam i1 => (LinearTerm.upgrade-metavariables-t {env} msigs (Injections.inject-term-right envL envR (choosing i1)))) => ext (\lam i => swap blue msigs (choosing i))
              \in rewrite extt idp
            | blue, func f choosing => pmap (func {env} (inr f)) (ext (\lam index => (swap blue msigs (choosing index))))
        }

      \lemma recreate-coloring-for-root {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} {color : Color} {f : env.symbol s}
                                        {choosing-A choosing-C : \Pi (index : Fin (length (env.domain f))) -> Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc}
                                        (h : HasColoredRoot color (func f choosing-A)) : HasColoredRoot color (func f choosing-C) \elim color, f, h
        | red, inl s1, red-func-root => red-func-root
        | blue, inr s1, blue-func-root => blue-func-root
    }

  \func alternate-subst {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                        (gc rcolor : Color)
                        (C : Term env context s mc)
                        (t : LinearTerm (colored-env gc) context s)
                        (rho : MetaSubstitution env nil (LinearMetaContextT {colored-env gc} t) mc)
                        (root-colors : \Pi {s1 : Sort'} -> \Pi (m : metaname {LinearMetaContextT {colored-env gc} t} s1) -> HasColoredRoot (Color.flip gc) (rho m))
                        (someColor : Maybe Color)
                        (some-color-diff : (someColor = nothing) `Or` (someColor = just (Color.flip gc)))
                        (A=>C : BorderedParallelReduction rcolor someColor (MetaSubstitution.apply {env} ((unify-top.convert-to-injected-term gc {context} {s} t)) SubList.sublist-trivial-skip rho) C)
    : \Sigma (sigma : MetaSubstitution env nil (LinearMetaContextT {colored-env gc} t) mc)
             (C = MetaSubstitution.apply {env} ((unify-top.convert-to-injected-term gc {context} {s} t)) (SubList.sublist-trivial-skip) sigma)
             (rho~>sigma : \Pi {s : Sort'} (m : metaname {LinearMetaContextT {colored-env gc} t} s) ->
                 \Sigma (mcolor : Maybe Color) (BorderedParallelReduction rcolor mcolor (rho m) (sigma m)))
  \elim gc, t, someColor, A=>C
    | red, lt-func f choosing, nothing, parallelization-f mediator inner-reductions (cr-skip p) =>
      \let
        | inductive-result i => alternate-subst red rcolor
            (mediator i) (choosing i)
            (\lam m => rho (i, m))
            (\lam {s1} m => root-colors (i, m))
            (inner-reductions i).1
            ((inner-reductions i).2)
            (rewrite (modular-commutation {env} (\lam j => LinearMetaContextT {envL} (choosing j)) i SubList.sublist-trivial-skip (unify-top.convert-to-injected-term red (choosing i)) rho)
                (rewrite (invariant-through-empty-subst {env} rho SubList.sublist-trivial-skip (SubList.extend-right-single SubList.sublist-trivial-skip) (LinearTerm.upgrade-metavariables-t {env}
                    (\lam j => LinearMetaContextT {colored-env red} (choosing j)) (unify-top.convert-to-injected-term red (choosing i)))) (inner-reductions i).3))
      \in (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2,
           inv p *> (pmap (func {env} (inl f))
               (ext (\lam index => rewriteI
                   (modular-commutation {env} (\lam j => LinearMetaContextT {envL} (choosing j)) index (SubList.extend-right-single SubList.sublist-trivial-skip) (unify-top.convert-to-injected-term red (choosing index)) (\lam {s1} mvar => (inductive-result (mvar.1)).1 mvar.2))
                   (rewrite (invariant-through-empty-subst {env}) (inductive-result index).2)))),
           \lam {s1} m => (inductive-result (m.1)).3 m.2)
    | red, lt-func f choosing, just color, parallelization-f mediator inner-reductions (cr-rewrite tlcr p) =>
      \let
        | coloring-from-tlcr => HasColoredRoot.reorganize color (TopLevelColoredReduction.extract-root-coloring (TClosure.extract tlcr).2)
        | extracted => coloring-from-tlcr *> extract-from-or some-color-diff
      \in contradiction
    | gc, lt-func f choosing, someColor, equal-trees p => (rho, inv p, \lam {s1} m => (nothing, equal-trees idp))
    | red, lt-full-metavar, someColor, rd =>
      ( \lam {s1} mvar => transport (Term env context __ mc) (inv mvar) C,
        (inv (plain-identity-effect {env} C)),
        \lam {s1} m => \let | unified => unify-reduction rho C rd m  \in (someColor, unified))
    | red, lt-var index p, someColor, equal-trees p1 => (\lam {s1} mvar => contradiction, inv p1, \lam {s1} m => contradiction)
    | blue, _, _, _ => {?}
    \where {
      \func extract-from-or {A : \Type} {a b : A} (or : Or (just a = nothing) (just a = just b)) : a = b
        | inl a1 => contradiction
        | inr b1 => Maybe.unjust-eq b1

      \func unify-reduction {tc : TheoremContext} {gc : Color} {someColor : Maybe Color} {context : List Sort'} {s s' : Sort'} {mc : MetaContext Sort'}
                            (rho :  MetaSubstitution env nil (SingularMetaContext {env} s context) mc)
                            (C : Term env context s mc)
                            (bpr : BorderedParallelReduction gc someColor (Substitution.apply {env}
                                (rho idp) (extend-substitution-left {env} SubList.sublist-trivial-skip (\lam i => var i idp))) C)
                            (m : s' = s)
        : BorderedParallelReduction gc someColor (rho m)
          (transport (\lam (srt : Sort') => Term env context srt mc) (inv m) C) \elim m
        | idp => (rewriteI (plain-identity-effect {env}) bpr)

      \func reorganize-colors {tc : TheoremContext} {gc gc' : Color} {someColor : Maybe Color} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                              {A B : Term env context s mc} (A~>B : BorderedParallelReduction gc someColor A B) (or : (someColor = nothing) `Or` (someColor = just gc'))
        : \Sigma (someColor' : Maybe Color) (Or (someColor' = nothing) (someColor' = just (gc'))) (BorderedParallelReduction gc someColor' A B) \elim someColor, A, A~>B
        | _, A, equal-trees p => (nothing, inl idp, equal-trees p)
        | nothing, func f choosing, rd => (nothing, inl idp, rd)
        | just a, func f choosing, rd => (just a, or, rd)

      \func unwrap-func {env : FSignature} {s : Sort} {context : List Sort} {mc : MetaContext Sort}
                        (T : Term env context s mc) : Or Nat
          (\Sigma (f : env.symbol s) (\Pi (index : Fin (length (env.domain f))) ->
              Term env (context ++ (f FSignature.!!param index)) (f FSignature.!!sort index) mc)) \elim T
        | var index p => inl 0
        | metavar m choosing1 => inl 0
        | func f1 choosing1 => inr (f1, choosing1)

      \func sigma-set-equalizer {A : \Set} (B : A -> \Type) {a : A} {b b' : B a} (p : (a,b) = {\Sigma (x : A) (B x)} (a,b')) : b = b' =>
        pmap (transport B __ b) (Path.inProp idp (pmap __.1 p)) *> pmapd (\lam t => B t.1) __.2 p

      \lemma apply-modularity {env : FSignature} {context subst-context pattern-context : List Sort} {s : Sort} {mc : MetaContext Sort} {n : Nat} {index : Fin n}
                              (producer : Fin n -> MetaContext Sort)
                              (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) mc)
                              (sublist : SubList subst-context context)
                              (pat-sublist : SubList pattern-context context)
                              (t : Term env pattern-context s (producer index)) :
        MetaSubstitution.apply (weakening t pat-sublist) sublist (substitutions index) = MetaSubstitution.apply (weakening (LinearPattern.upgrade-metavariables-p producer t) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim t
        | var index1 p => idp
        | metavar m choosing => pmap (\lam e => Substitution.apply (substitutions index m) (extend-substitution-left sublist e)) (ext (\lam i => apply-modularity producer substitutions sublist pat-sublist (choosing i)))
        | func f choosing => pmap (func f) (ext (\lam i => apply-modularity producer substitutions (SubList.extend-right-single sublist) (SubList.extend-right-both pat-sublist) (choosing i)))
    }

  \data TClosure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | tc-basic (a `R` b)
    | tc-connect (c : A) (a `R` c) (TClosure R c b)
    \where {
      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : TClosure Rel x y) : TClosure Rel' (map x) (map y) \elim closure
        | tc-basic r => tc-basic (rel-map r)
        | tc-connect c r closure => tc-connect (map c) (rel-map r) (lift map rel-map c y closure)

      \func compose {A : \Type} {R : A -> A -> \Type} {a b c : A} (a->b : TClosure R a b) (b->c : TClosure R b c) : TClosure R a c \elim a->b
        | tc-basic r => tc-connect b r b->c
        | tc-connect c1 r a->b => tc-connect c1 r (compose a->b b->c)

      \func extract  {A : \Type} {R : A -> A -> \Type} {a b : A} (cl : TClosure R a b) : \Sigma (c : A) (R a c) \elim cl
        | tc-basic r => (b, r)
        | tc-connect c r cl => (c, r)

      \func to-closure {A : \Type} {R : A -> A -> \Type} {a b : A} (cl : TClosure R a b) : Closure R a b \elim cl
        | tc-basic r => c-basic r
        | tc-connect c r cl => c-connect c r (to-closure cl)
    }

  \data Closure {A : \Type} (R : A -> A -> \Type) (a b : A)
    | c-trivial (a = b)
    | c-basic (a `R` b)
    | c-connect (c : A) (a `R` c) (Closure R c b)
    \where {
      \func concat {A : \Type} {R : A -> A -> \Type} {a b c : A} (a~>b : Closure R a b) (b~>c : Closure R b c) : Closure R a c \elim a~>b, b~>c
        | c-basic r, rx => c-connect b r rx
        | c-connect c1 r a~>b, rx => c-connect c1 r (concat a~>b rx)
        | c-trivial idp, b~>c => b~>c

      \func lift {A B : \Type} {Rel : A -> A -> \Type} {Rel' : B -> B -> \Type} (map : A -> B)
                 (rel-map : \Pi {a b : A} (Rel a b) -> Rel' (map a) (map b))
                 (x y : A)
                 (closure : Closure Rel x y) : Closure Rel' (map x) (map y) \elim closure
        | c-basic r => c-basic (rel-map r)
        | c-connect c r closure => c-connect (map c) (rel-map r) (lift map rel-map c y closure)
        | c-trivial idp => c-trivial idp

      \func flatten {A : \Type} {Rel : A -> A -> \Type}
                    {x y : A}
                    (closure : Closure (Closure Rel) x y) : Closure Rel x y \elim closure
        | c-basic r => r
        | c-connect c r closure => concat r (flatten closure)
        | c-trivial idp => c-trivial idp
    }

  \func unify-left {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {inner-mc : MetaContext Sort'}
                   (gc anti-color : Color)
                   (S : Term env context' s inner-mc)
                   (witness : inject-monochrome-term.InjectionWitness anti-color S)
                   (sublist : SubList context context')
                   (rho sigma : MetaSubstitution env context inner-mc (EmptyMetaContext {env}))
                   (rho~>sigma : \Pi {s : Sort'} (m : inner-mc.metaname s) ->
                       \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (rho m) (sigma m))) :
    \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (MetaSubstitution.apply {env} S sublist rho) (MetaSubstitution.apply {env} S sublist sigma))
  \elim S, witness
    | var index p, _ => (nothing, equal-trees idp)
    | metavar m choosing, inject-monochrome-term.iw-mvar _x =>
      \let | main-reduction => rho~>sigma m
           | rho-subst => (extend-substitution-left {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho))
           | sigma-subst => (extend-substitution-left {env} sublist (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma))
           | inductive i => unify-left gc anti-color (choosing i) (_x i) sublist rho sigma rho~>sigma
           | target-reduction => reduction-over-substitution main-reduction.1 (rho m) (sigma m) main-reduction.2 rho-subst sigma-subst (\lam i => extend-substitutuion-left-for-parallel (\lam i => MetaSubstitution.apply {env} (choosing i) sublist rho) (\lam i => MetaSubstitution.apply {env} (choosing i) sublist sigma) inductive sublist i)
      \in (target-reduction)
    | func f choosing, inject-monochrome-term.iw-func p _x =>
      \let | in-indices i => unify-left gc (color-of-root f) (choosing i) (rewrite p (_x i)) (SubList.extend-right-single sublist) rho sigma rho~>sigma
           | (someColor, med, inrd, cwr) => collect-reductions-together-raw f
               (\lam i => MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single sublist) rho)
               (\lam i => MetaSubstitution.apply {env} (choosing i) (SubList.extend-right-single sublist) sigma)
               in-indices
      \in (someColor, parallelization-f med inrd cwr)

  \func extend-substitutuion-left-for-parallel
    {tc : TheoremContext} {left-context right-context some-context : List Sort'}
    {gc : Color}
    (subst subst' : Substitution {env} right-context some-context (EmptyMetaContext {env}))
    (rd' : \Pi (i : Fin (length right-context)) ->
        \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    (sublist : SubList left-context some-context)
    (index : Fin (length (left-context ++ right-context)))
    : \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (extend-substitution-left {env} sublist subst index) (extend-substitution-left {env} sublist subst' index)) =>
    partial-fin-induction (\lam ind => \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (extend-substitution-left {env} sublist subst ind) (extend-substitution-left {env} sublist subst' ind)))
        (\lam i => rewrite (extend-substitution-left.for-left-context {env}) ((nothing, equal-trees (rewrite (extend-substitution-left.for-left-context {env}) idp))))
        (\lam i => \let inner => rd' i \in rewrite (extend-substitution-left.for-right-context {env}) (rewrite (extend-substitution-left.for-right-context {env}) (inner.1, lemma inner.1 (inv (expand-fin-eq-late i)) inner.2)))
        index
    \where {
      \func lemma {tc : TheoremContext} {context : List Sort'}
                  {gc : Color} {ms : MetaContext Sort'}
                  (someColor : Maybe Color)
                  {s s' : Sort'}
                  (p : s = s')
                  {A B : Term env context s ms}
                  (bpr : BorderedParallelReduction gc someColor A B)
        : BorderedParallelReduction gc someColor (transport (Term env context __ ms) p A) (transport (Term env context __ ms) p B) \elim p
        | idp => bpr
    }

  \func reduction-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'}
                                    {gc : Color}
                                    (color : Maybe Color)
                                    (A B : PureTerm env context s)
                                    (A=>B : BorderedParallelReduction gc color A B)
                                    (subst subst' : Substitution {env} context new-context (EmptyMetaContext {env}))
                                    (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    : \Sigma (mcolor : Maybe Color) (BorderedParallelReduction gc mcolor (Substitution.apply {env} A subst) (Substitution.apply {env} B subst')) \elim color, A, A=>B
    | color, A, equal-trees p => rewrite p (distributed-reduction-for-substitution B color _ _ subst=>subst')
    | nothing, func f choosing, parallelization-f mediator _x (cr-skip p) =>
      \let | medium-reductions i => reduction-over-substitution  (_x i).1 (choosing i) (mediator i) (_x i).3 (append-context-right {env} subst) (append-context-right {env} subst') (expand-reduction-right subst subst' subst=>subst')
           | (sc, med, inrd, cwr) => (collect-reductions-together-raw f (\lam i => Substitution.apply {env} (choosing i) (append-context-right {env} subst)) (\lam i => Substitution.apply {env} (mediator i) (append-context-right {env} subst')) medium-reductions)
      \in rewriteI p (sc, (parallelization-f med inrd cwr))
    | just a, func f choosing, parallelization-f mediator _x (cr-rewrite tlcr p) =>
      \let | medium-reductions i => reduction-over-substitution (_x i).1 (choosing i) (mediator i) (_x i).3 (append-context-right {env} subst) (append-context-right {env} subst') (expand-reduction-right subst subst' subst=>subst')
           | (some-color, med, inrd, cwr) => (collect-reductions-together-tlcr (just gc) f (\lam i => Substitution.apply {env} (choosing i) (append-context-right {env} subst)) (\lam i => Substitution.apply {env} (mediator i) (append-context-right {env} subst')) medium-reductions (Substitution.apply {env} B subst') (cr-rewrite (rewrite p (TClosure.lift (\lam t => Substitution.apply {env} t subst') (\lam rel => tlcr-over-substitution subst' rel) (func {env} f mediator) B tlcr)) idp))
      \in (some-color, parallelization-f med inrd cwr)

  \func expand-reduction-right
    {tc : TheoremContext} {context new-context additional-context : List Sort'}
    {gc : Color}
    (subst subst' : Substitution {env} context new-context (EmptyMetaContext {env}))
    (rd' : \Pi (i : Fin (length context)) ->
        \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    (index : Fin (length (context ++ additional-context)))
    : \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (append-context-right {env} subst index) (append-context-right {env} subst' index)) \elim context, index
    | nil, index => (nothing, equal-trees idp)
    | :: a context, 0 => \let ind => rd' 0 \in (ind.1, expand-reduction-over-weakening ind.1 (subst 0) (subst' 0) ind.2 (SubList.extend-right-single SubList.identity))
    | :: a context, suc index => expand-reduction-right (\lam i => subst (suc i)) (\lam i => subst' (suc i)) (\lam i => rd' (suc i)) index

  \func tlcr-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                               {A B : Term env context s mc}
                               {color : Color}
                               (subst : Substitution {env} context new-context mc)
                               (A~>B : TopLevelColoredReduction color A B)
    : TopLevelColoredReduction color (Substitution.apply {env} A subst) (Substitution.apply {env} B subst) \elim A, B, A~>B
    | A, B, rewrite-with-rule-colored h lp r lf msubst msubst[l]=A msubst[r]=B inh =>
      rewrite-with-rule-colored
          (hcr-over-substitution subst h)
          lp
          r
          lf
          (\lam m => Substitution.apply {env} (msubst m) (append-context-right {env} subst))
          (rewrite (inv msubst[l]=A) (((rewrite first-sublist-commutation) ((rewrite (first-sublist-commutation {_} {context})) (rewrite (second-sublist-commutation {_} {new-context}) (rewrite (second-sublist-commutation {_} {context}) (rewrite {2} (append-context-right-to-nil {env} subst) (untransport {env} _ ++_nil ++_nil (\lam {s1 : Sort'} (m : metaname {LinearMetaContext {colored-env color} lp} s1) => Substitution.apply {env} (msubst m) (append-context-right {env} subst)) _ _ _ _ _ _ (commutation {env} (LinearPattern.convert-to-injected-term color lp) subst msubst)))))))))
          (rewrite (inv msubst[r]=B) (((rewrite first-sublist-commutation) ((rewrite (first-sublist-commutation {_} {context})) (rewrite (second-sublist-commutation {_} {new-context}) (rewrite (second-sublist-commutation {_} {context}) (rewrite {2} (append-context-right-to-nil {env} subst) (untransport {env} _ ++_nil ++_nil (\lam {s1 : Sort'} (m : metaname {LinearMetaContext {colored-env color} lp} s1) => Substitution.apply {env} (msubst m) (append-context-right {env} subst)) _ _ _ _ _ _ (commutation {env} (inject-monochrome-term color r) subst msubst)))))))))
          inh
    | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored idp p1 i tlcr eq => rewrite-with-parameter-f-colored idp p1 i (tlcr-over-substitution (append-context-right {env} subst) tlcr) (\lam j _x => rewrite (eq j _x) idp)
    \where {
      \func untransport {env : FSignature} {context-a context-a' context-b context-b' context-meta context-meta2 : List Sort} {s : Sort} {mc mc' : MetaContext Sort}
                        (t : Term env nil s mc)
                        (eq : context-a = context-a')
                        (eq' : context-b = context-b')
                        (ms-a : MetaSubstitution env context-meta mc mc')
                        (sl1 : SubList nil context-a)
                        (sl2 : SubList context-meta context-a)
                        (sl3 : SubList nil context-b)
                        (sl4 : SubList context-meta2 context-b)
                        (ms-b : MetaSubstitution env context-meta2 mc mc')
                        (subst : Substitution context-b context-a mc')
                        (true-eq : MetaSubstitution.apply (weakening t sl1) sl2 ms-a = Substitution.apply (MetaSubstitution.apply (weakening t sl3) sl4 ms-b) subst):
        MetaSubstitution.apply (weakening t
            (transport (SubList nil) eq sl1))
            (transport (SubList context-meta) eq sl2)
            ms-a = Substitution.apply (MetaSubstitution.apply (weakening t
            (transport (SubList nil) eq' sl3))
            (transport (SubList context-meta2) eq' (sl4)) ms-b)
                       (transport2 (\lam (ctx : List Sort) (ctx' : List Sort) => Substitution ctx ctx' mc') eq' eq (subst)) \elim eq, eq'
        | idp, idp => true-eq

      \lemma commutation {env : FSignature} {s : Sort} {aux-context core-context new-context : List Sort} {old-ms new-ms : MetaContext Sort}
                         (term : Term env aux-context s old-ms)
                         (subst : Substitution core-context new-context new-ms)
                         (metasubst : MetaSubstitution env core-context old-ms new-ms)
        :
        MetaSubstitution.apply
            (weakening term (SubList.extend-left-single SubList.identity))
            (SubList.extend-right-single SubList.identity) (\lam {s} m => Substitution.apply (metasubst m) (append-context-right subst))
          =
        Substitution.apply (MetaSubstitution.apply
            (weakening term (SubList.extend-left-single SubList.identity))
            (SubList.extend-right-single SubList.identity {aux-context}) metasubst) (append-context-right subst) \elim term
        | var index idp => inv (weakening-extend-left _ (var index idp))
        | metavar m choosing => repeat {2} (rewrite subst-comm) (cong (ext (\lam i =>
            \let inductive : (\lam j => MetaSubstitution.apply
                (weakening (choosing j) (SubList.extend-left-single SubList.identity))
                (SubList.extend-right-single SubList.identity) (\lam {s} m => Substitution.apply (metasubst m) (append-context-right subst)))
              =
            (\lam j => Substitution.apply (MetaSubstitution.apply
                (weakening (choosing j) (SubList.extend-left-single SubList.identity))
                (SubList.extend-right-single SubList.identity {aux-context}) metasubst) (append-context-right subst)) => ext (\lam j => commutation (choosing j) subst metasubst)
            \in rewrite inductive (subst-comm-different subst _ i))))
        | func f choosing =>
          pmap (func f) (ext (\lam index => \let inductive => commutation (choosing index) subst metasubst \in rewrite weakening-over-double-extend (rewrite weakening-over-double-extend-2 (rewrite weakening-over-double-extend (rewrite weakening-over-double-extend-2 (rewrite double-append-context-right (inductive-step (choosing index) ++-assoc ++-assoc idp idp _ _ _ _ metasubst subst inductive)))))))
        \where {
          \lemma subst-comm  {env : FSignature} {s : Sort} {context-a context-b context-c : List Sort} {mc : MetaContext Sort}
                             (t : Term env context-a s mc)
                             (subst-a : Substitution context-a context-b mc)
                             (subst-b : Substitution context-b context-c mc) :
            Substitution.apply (Substitution.apply t subst-a) subst-b = Substitution.apply t (\lam i => Substitution.apply (subst-a i) subst-b) \elim t
            | var index idp => idp
            | metavar m choosing => pmap (metavar m) (ext (\lam index => subst-comm (choosing index) subst-a subst-b))
            | func f choosing => pmap (func f) (ext (\lam index => subst-comm (choosing index) (append-context-right subst-a) (append-context-right subst-b) *> (pmap (Substitution.apply (choosing index)) (ext (\lam i => commutation-with-right-extension subst-a subst-b i)))))
            \where {
              \func commutation-with-right-extension {env : FSignature} {context-a context-b context-c add-context : List Sort} {mc : MetaContext Sort}
                                                     (subst-a : Substitution context-a context-b mc)
                                                     (subst-b : Substitution context-b context-c mc)
                                                     (i : Fin (length (context-a ++ add-context)))
                : Substitution.apply (append-context-right subst-a i) (append-context-right subst-b) = append-context-right (\lam (i : Fin (length context-a)) => Substitution.apply (subst-a i) subst-b) i =>
                partial-fin-induction
                    (\lam ind => Substitution.apply (append-context-right subst-a ind) (append-context-right subst-b) = append-context-right (\lam (i : Fin (length context-a)) => Substitution.apply (subst-a i) subst-b) ind)
                    (\lam i1 => repeat {2} (rewrite append-context-right-begin) (rewrite weakening-extend-right (equating-lemma subst-a subst-b i1 _)))
                    (\lam i1 => repeat {2} (rewrite append-context-right-end) (rewrite (weakening-extend-left subst-b (var i1 (expand-fin-eq-late i1))) idp))
                    i
                \where {
                  \func equating-lemma  {env : FSignature} {s : Sort} {context-a context-b context-c add-context : List Sort} {mc : MetaContext Sort}
                                        (subst-a : Substitution context-a context-b mc)
                                        (subst-b : Substitution context-b context-c mc)
                                        (i1 : Fin (length (context-a)))
                                        (eq : s = context-a !! i1)
                    : weakening (Substitution.apply (coe (\lam (i : I) => Term env context-b (inv (eq) @ i) mc) (subst-a i1) right) subst-b)
                      (SubList.extend-right-single SubList.identity {add-context}) = weakening (transport (\lam (p0 : env.Sort) => Term env context-c p0 mc) (inv (eq)) (Substitution.apply (subst-a i1) subst-b))
                                                                           (SubList.extend-right-single SubList.identity) \elim eq
                    | idp => idp
                }
            }

          \lemma subst-comm-different
            {env : FSignature} {context-a context-b context-c context-d : List Sort} {mc : MetaContext Sort}
            (subst : Substitution context-a context-b mc)
            (subst2 : Substitution context-c (context-a ++ context-d) mc)
            (index : Fin (length (context-a ++ context-c)))
            : Substitution.apply (append-context-right subst index) (extend-substitution-left (SubList.extend-right-single SubList.identity) (\lam j => Substitution.apply (subst2 j) (append-context-right subst)))
            = Substitution.apply (extend-substitution-left (SubList.extend-right-single SubList.identity) subst2 index) (append-context-right subst) =>
            partial-fin-induction (\lam i => Substitution.apply (append-context-right subst i) (extend-substitution-left (SubList.extend-right-single SubList.identity) (\lam j => Substitution.apply (subst2 j) (append-context-right subst)))
              = Substitution.apply (extend-substitution-left (SubList.extend-right-single SubList.identity) subst2 i) (append-context-right subst))
                (\lam i => rewrite append-context-right-begin (rewrite extend-substitution-left.for-left-context (rewrite weakening-append-left (inductive-step subst i _))))
                (\lam i => rewrite append-context-right-end (rewrite extend-substitution-left.for-right-context (rewrite (weakening-append-right (\lam (j : Fin (length context-c)) => Substitution.apply (subst2 j) (append-context-right subst)) (var i (expand-fin-eq-late i))) (inductive-step-2 subst subst2 i (expand-fin-eq-late i)))))
                index
            \where {
              \func inductive-step-2 {env : FSignature} {context-a context-b context-c context-d : List Sort} {s : Sort} {mc : MetaContext Sort}
                                     (subst : Substitution context-a context-b mc)
                                     (subst2 : Substitution context-c (context-a ++ context-d) mc)
                                     (index : Fin (length context-c))
                                     (eq : s = context-c !! index) : Substitution.apply (var index (eq))
                  (\lam (j : Fin (length context-c)) => Substitution.apply (subst2 j) (append-context-right subst)) = Substitution.apply
                                                                                                                          (transport (\lam (p0 : env.Sort) => Term env (context-a ++ context-d) p0 mc) (inv (eq)) (subst2 index))
                                                                                                                          (append-context-right subst) \elim eq
                | idp => idp

              \func inductive-step  {env : FSignature} {context-a context-b context-c : List Sort} {s : Sort} {mc : MetaContext Sort}
                                    (subst : Substitution context-a context-b mc)
                                    (index : Fin (length context-a))
                                    (eq : s = context-a !! index)
                : weakening (coe (\lam (i1 : I) => Term env context-b (inv (eq) @ i1) mc) (subst index) right)
                  (SubList.extend-right-single SubList.identity {context-c}) = Substitution.apply
                                                                                   (var (weakening.recalculate-index (SubList.extend-right-single SubList.identity) index (eq)).1
                                                                                       (weakening.recalculate-index (SubList.extend-right-single SubList.identity) index (eq)).2)
                                                                                   (append-context-right subst) \elim eq
                | idp => rewrite (weakening-extend-right subst (var index idp)) idp
            }

          \lemma inductive-step
            {env : FSignature} {s : Sort} {big-context-al big-context-ar new-context term-context core-context rbig-context-al rbig-context-ar : List Sort} {old-ms new-ms : MetaContext Sort}
            (term : Term env term-context s old-ms)
            (eq : big-context-al = big-context-ar)
            (eq' : rbig-context-al = rbig-context-ar)
            (eq'' : core-context ++ term-context = rbig-context-ar)
            (eq''' : new-context ++ term-context = big-context-ar)
            (sl-term-ar : SubList term-context big-context-ar)
            (sl-new-ar : SubList new-context big-context-ar)
            (sl-term-rar : SubList term-context rbig-context-ar)
            (sl-core-rar : SubList core-context rbig-context-ar)
            (metasubst : MetaSubstitution env core-context old-ms new-ms)
            (subst : Substitution core-context new-context new-ms)
            (inductor : MetaSubstitution.apply
                (weakening term sl-term-ar) sl-new-ar (\lam {s} m => Substitution.apply (metasubst m) (append-context-right subst)) =
            Substitution.apply
                (MetaSubstitution.apply (weakening term sl-term-rar) sl-core-rar metasubst) (transport2 (\lam ctx1 ctx2 => \Pi (i : Fin (length ctx1)) -> Term env ctx2 (ctx1 !! i) new-ms) eq'' eq''' (append-context-right
                {env} {core-context} {new-context} {new-ms} subst {term-context})))
            : MetaSubstitution.apply {env} {big-context-al} {new-context}
              (weakening {env} {_} {term-context}
                  {big-context-al} term
                  (transport (SubList {Sort} (term-context))
                      {big-context-ar}
                      {big-context-al}
                      (inv eq)
                      (sl-term-ar)))
              (transport (SubList {Sort} new-context) {big-context-ar}
                  {big-context-al}
                  (inv eq)
                  (sl-new-ar))
              (\lam {s} m => Substitution.apply (metasubst {s} m)
                  (append-context-right {env} {core-context} {new-context} {new-ms} subst))
            =
          Substitution.apply
              {_} {_} {rbig-context-al}
              (MetaSubstitution.apply {env} {rbig-context-al} {core-context}
                  {_}
                  (weakening {_} {_} {term-context}
                      {rbig-context-al} {old-ms} (term)
                      (transport {List Sort} (SubList {Sort} (term-context))
                          {rbig-context-ar}
                          {rbig-context-al}
                          (inv eq')
                          (sl-term-rar)))
                  (transport {List Sort} (SubList {Sort} core-context) {rbig-context-ar}
                      {rbig-context-al}
                      (inv eq')
                      (sl-core-rar)) metasubst)
              {big-context-al}
              (transport2 {List Sort} {List Sort} (\lam ctx ctx' => \Pi (index : Fin (length {Sort} ctx)) -> Term env ctx' (ctx !! index) new-ms)
                  {rbig-context-ar}
                  {rbig-context-al}
                  {big-context-ar}
                  {big-context-al}
                  (inv eq')
                  (inv eq)
                  (transport2 (\lam ctx1 ctx2 => \Pi (i : Fin (length ctx1)) -> Term env ctx2 (ctx1 !! i) new-ms) eq'' eq''' (append-context-right
                      {env} {core-context} {new-context} {new-ms} subst {term-context})))
          \elim eq, eq', eq'', eq'''
            | idp, idp, idp, idp => unfold transport inductor
        }

      \func first-sublist-commutation {A : \Type} {a : List A} :
        SubList.sublist-trivial-skip {_} {a} = transport (SubList nil) ++_nil (SubList.extend-left-single sublist-trivial {a}) =>
        decompose-along-reduction.any-nil-sublist-equate _ _

      \func second-sublist-commutation {A : \Set} {a : List A} :
        SubList.identity {_} {a} = transport (SubList a) ++_nil (SubList.extend-right-single SubList.identity) => all-identity-sublists-equal _ _
        \where {
          \func all-identity-sublists-equal {A : \Set} {a : List A} (sl sl' : SubList a a) : sl = sl' \elim a, sl, sl'
            | nil, sublist-trivial, sublist-trivial => idp
            | :: y a, sublist-match p sl, sublist-match p1 sl' => rewrite (Path.inProp p p1) (pmap (sublist-match p1) (all-identity-sublists-equal sl sl'))
            | :: y a, sublist-match p sl, sublist-skip sl' => \let q => impossible-sublist sl' \in contradiction
            | :: y a, sublist-skip sl, sublist-match p sl' => \let q => impossible-sublist sl \in contradiction
            | :: y a, sublist-skip sl, sublist-skip sl' => \let q => impossible-sublist sl' \in contradiction

          \func impossible-sublist  {A : \Set} {x : A} {a : List A} (sl : SubList (x :: a) a) : Empty \elim a, sl
            | :: y a, sublist-match p sl => impossible-sublist sl
            | :: y a, sublist-skip sl => impossible-sublist (SubList.shrink sl)
        }

      \lemma hcr-over-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                                   {color : Color}
                                   {A : Term env context s mc}
                                   (subst : Substitution {env} context new-context mc)
                                   (hcr : HasColoredRoot color A)
        : HasColoredRoot color (Substitution.apply {env} A subst) \elim color, A, hcr
        | red, func (inl s1) choosing, red-func-root => red-func-root
        | blue, func (inr s1) choosing, blue-func-root => blue-func-root
    }

  \func expand-reduction-over-weakening
    {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'}
    {gc : Color}
    (someColor : Maybe Color)
    (A B : Term env context s (EmptyMetaContext {env}))
    (bpr : BorderedParallelReduction gc someColor A B)
    (sublist : SubList context new-context)
    : BorderedParallelReduction gc someColor (weakening {env} A sublist) (weakening {env} B sublist) \elim someColor, A, bpr

    | just a, func f choosing, parallelization-f mediator _x (cr-rewrite tlcr idp) =>
      \let inductive i => expand-reduction-over-weakening (_x i).1 (choosing i) (mediator i) (_x i).3 (SubList.extend-right-both sublist)
      \in parallelization-f
          (\lam i => weakening {env} (mediator i) (SubList.extend-right-both sublist))
          (\lam i => ((_x i).1, (_x i).2, inductive i))
          (cr-rewrite (TClosure.lift {Term env context s (EmptyMetaContext {env})} {Term env new-context s (EmptyMetaContext {env})} {TopLevelColoredReduction a} {TopLevelColoredReduction a} (weakening {env} __ sublist) (\lam {X} {Y} tlcr => tlcr-over-weakening a X Y tlcr sublist) (func f mediator) B tlcr) idp)
    | cl , A, equal-trees p1 => equal-trees (pmap (weakening {env} __ sublist) p1)
    | nothing, func f choosing, parallelization-f mediator _x (cr-skip idp) =>
      \let inductive i => expand-reduction-over-weakening (_x i).1 (choosing i) (mediator i) (_x i).3 (SubList.extend-right-both sublist)
      \in parallelization-f (\lam index => weakening {env} (mediator index) (SubList.extend-right-both sublist)) (\lam i => ((_x i).1, (_x i).2, inductive i)) (cr-skip idp)

  \func tlcr-over-weakening
    {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'}
    (color : Color)
    (A B : Term env context s (EmptyMetaContext {env}))
    (tlcr : TopLevelColoredReduction color A B)
    (sublist : SubList context new-context)
    : TopLevelColoredReduction color (weakening {env} A sublist) (weakening {env} B sublist) =>
    \let | weakening-subst => weakening-as-substitution {env} sublist
         | substed-tlcr => tlcr-over-substitution weakening-subst tlcr
    \in repeat {2} (rewrite (weakening-as-substitution-eq {env})) substed-tlcr

  \func distributed-reduction-for-substitution {tc : TheoremContext} {context new-context : List Sort'} {s : Sort'}
                                               (A : PureTerm env context s)
                                               {gc : Color}
                                               (color : Maybe Color)
                                               (subst subst' : Substitution {env} context new-context (EmptyMetaContext {env}))
                                               (subst=>subst' : \Pi (i : Fin (length context)) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (subst i) (subst' i)))
    : \Sigma (color' : Maybe Color) (BorderedParallelReduction gc color' (Substitution.apply {env} A subst) (Substitution.apply {env} A subst')) \elim A
    | var index p => \case \elim s, \elim p \with {
      | s, idp => (subst=>subst' index)
    }
    | metavar m choosing => contradiction
    | func f choosing =>
      \let | inner-reductions i => distributed-reduction-for-substitution (choosing i) {gc} color (append-context-right {env} subst) (append-context-right {env} subst') (expand-reduction-right subst subst' subst=>subst')
           | (sc, med, inrd, cwr) => collect-reductions-together-raw f
               (\lam index => (Substitution.apply {env} (choosing index) (append-context-right {env} subst)))
               (\lam index => (Substitution.apply {env} (choosing index) (append-context-right {env} subst')))
               inner-reductions \in (sc, parallelization-f med inrd cwr)

  \func collect-reductions-together-tlcr
    {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
    {gc : Color}
    (someColor : Maybe Color)
    (f : env.symbol s)
    (choosing-A choosing-B : \Pi (index : Fin (length (env.domain f))) -> Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc)
    (tlcrs : \Pi (index : Fin (length (env.domain f))) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (choosing-A index) (choosing-B index)))
    (C : Term env context s mc)
    (B~>*C : ColorwiseReduction gc someColor (func {env} f choosing-B) C)
    : \Sigma
    (someColor : Maybe Color)
    (mediator : \Pi (index : Fin (length (env.domain f))) ->
        Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc)
    (\Pi (i : F-param-index {env} f) -> \Sigma
      (someColor : Maybe Color)
      ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
      (BorderedParallelReduction gc someColor (choosing-A i) (mediator i)))
    (ColorwiseReduction gc someColor (func f mediator) (C)) =>
    \let | common-reduction i => unfold-bpr (color-of-root f) (choosing-A i) (choosing-B i) (tlcrs i).2
         | ind-last =>
           progressive-induction
               (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc)
               (\lam curmed => \Sigma (someColor : Maybe Color) (ColorwiseReduction gc someColor (func f curmed) C))
               (choosing-B)
               (\lam i => (common-reduction i).1)
               (someColor, B~>*C)
               (\lam delim prev-result => \let arg-rewrite => (common-reduction delim).7
                                          \in propagate-rewriting f C choosing-B (\lam i => (common-reduction i).1) delim prev-result.1 prev-result.2 (common-reduction delim).5 (common-reduction delim).6 arg-rewrite
               )
    \in (ind-last.1, \lam index => (common-reduction index).1, \lam i => ((common-reduction i).2, (common-reduction i).4, (common-reduction i).3), ind-last.2)
    \where {
      \func propagate-rewriting
        {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
        {gc : Color}
        (f : env.symbol s)
        (C : Term env context s mc)
        (choosing-B midterms : \Pi (index : Fin (length (env.domain f))) -> Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc)
        (delim : Fin (length (env.domain f)))
        (prev-rd-cl : Maybe Color)
        (pred-rd-cwr : ColorwiseReduction gc prev-rd-cl (func f (modular-function
            (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc)
            choosing-B midterms delim)) C)
        (point-rd-cl : Maybe Color)
        (point-coherence : (point-rd-cl = nothing) `Or` (point-rd-cl = just (color-of-root f)))
        (point-rd-cwr : ColorwiseReduction gc point-rd-cl (midterms delim) (choosing-B delim)) :
        \Sigma (someColor : Maybe Color) (ColorwiseReduction gc someColor (func f (modular-function
            (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc)
            choosing-B midterms (suc delim))) C) \elim prev-rd-cl, pred-rd-cwr, point-rd-cl, point-coherence, point-rd-cwr
        | nothing, cr-skip p, nothing, point-coherence, cr-skip p1
        => (nothing, cr-skip ((pmap (func {env} f) (inv (modular-function.modular-jump.ext' (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc) choosing-B midterms delim (inv p1)))) *> p))
        | nothing, cr-skip p, just color, inl (), _
        | nothing, cr-skip idp, just color, inr b, cr-rewrite ind1~>ind' idp => (just gc, cr-rewrite (upgrade-iterated-reduction f (Maybe.unjust-eq (inv b)) choosing-B midterms delim ind1~>ind') idp)
        | just color, cr-rewrite tlcr p, nothing, point-coherence, cr-skip p1
        => (just color, cr-rewrite (rewrite (inv (modular-function.modular-jump.ext' (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc) choosing-B midterms delim (inv p1))) tlcr) p)
        | just color, cr-rewrite before~>C idp, just color1, inl (), _
        | just color, cr-rewrite before~>C idp, just color1, inr b, cr-rewrite ind1~>ind' idp =>
          (just gc, cr-rewrite (TClosure.compose (upgrade-iterated-reduction f (Maybe.unjust-eq (inv b)) choosing-B midterms delim ind1~>ind') before~>C) idp)

      \func upgrade-iterated-reduction
        {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
        {gc : Color}
        (f : env.symbol s)
        (eq : color-of-root f = gc)
        (choosing-A choosing-B : \Pi (index : Fin (length (env.domain f))) -> Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc)
        (index : Fin (length (env.domain f)))
        (rd : TClosure (TopLevelColoredReduction gc) (choosing-B index) (choosing-A index))
        : TClosure (TopLevelColoredReduction gc) (func {env} f (modular-function
          (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc)
          choosing-A choosing-B (suc index))) (func f (modular-function
          (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc)
          choosing-A choosing-B (index))) =>
        \let | some => TClosure.extract rd
             | modular => (modular-function
                 (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc)
                 choosing-A choosing-B (index))
             | some' => insert-term {env} f modular index (choosing-B index)
             | mapped => TClosure.lift {_} {_}
                 {TopLevelColoredReduction gc {mc} {context ++ f env.!!param index} {f env.!!sort index}}
                 {TopLevelColoredReduction gc {mc} {context} {s}}
                 (insert-term {env} f modular index)
                 (\lam rel => rewrite-with-parameter-f-colored idp eq index (rewrite pointed-at-index (rewrite pointed-at-index rel)) (\lam j j-not-index => rewrite (pointed-not-at-index _ _ index _ j (j-not-index)) (rewrite (pointed-not-at-index _ _ index _ j (j-not-index)) idp)))
                 (choosing-B index) (choosing-A index)
                 rd
        \in rewrite (pointed-with-modular-1.ext' (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc) choosing-A choosing-B) (rewrite {2} (pointed-with-modular-2.ext' (\lam index => Term env (context ++ f env.!!param index) (f env.!!sort index) mc) choosing-A choosing-B) mapped)

      \func pointed-function {n : Nat} (C : Fin n -> \Type)
                             (f : \Pi (i : Fin n) -> C i)
                             (index : Fin n)
                             (point : C index)
                             (j : Fin n)
        : C j \elim n, index, j
        | suc n, 0, 0 => point
        | suc n, 0, suc j => f (suc j)
        | suc n, suc index, 0 => f 0
        | suc n, suc index, suc j => pointed-function (\lam i => C (suc i)) (\lam i => f (suc i)) index point j

      \func pointed-induction {n : Nat} (C : Fin n -> \Type)
                              (Q : \Pi (i : Fin n) -> (C i) -> \Type)
                              (f : \Pi (i : Fin n) -> C i)
                              (index : Fin n)
                              (point : C index)
                              (eq1 : Q index point)
                              (eq2 : \Pi (j : Fin n) (Not (j = index)) -> (Q j (f j)))
                              (i : Fin n) : Q i (pointed-function C f index point i) \elim n, index, i
        | suc n, 0, 0 => eq1
        | suc n, 0, suc i => eq2 (suc i) (\lam ())
        | suc n, suc index, 0 => eq2 0 (\lam ())
        | suc n, suc index, suc i => pointed-induction (\lam i => C (suc i)) (\lam i ci => Q (suc i) ci) (\lam i => f (suc i)) index point eq1 (\lam j ne => eq2 (suc j) (\lam p => ne (FinSet.suc-isInj _ _ p))) i

        \func unsuc {n : Nat} (a : Nat) : Nat \elim a
          | 0 => 0
          | suc a => a

      \func pointed-at-index
        {n : Nat} (C : Fin n -> \Type)
        (f : \Pi (i : Fin n) -> C i)
        (index : Fin n)
        (point : C index)
        : pointed-function C f index point index = point \elim n, index
        | suc n, 0 => idp
        | suc n, suc index => pointed-at-index (\lam i => C (suc i)) (\lam i => f (suc i)) index point

      \func pointed-not-at-index
        {n : Nat} (C : Fin n -> \Type)
        (f : \Pi (i : Fin n) -> C i)
        (index : Fin n)
        (point : C index)
        (j : Fin n)
        (j-not-index : j = index -> Empty)
        : pointed-function C f index point j = f j \elim n, index, j
        | suc n, 0, 0 => \let contra => j-not-index idp \in contradiction
        | suc n, 0, suc j => idp
        | suc n, suc index, 0 => idp
        | suc n, suc index, suc j => pointed-not-at-index (\lam i => C (suc i)) (\lam i => f (suc i)) index point j (\lam p => j-not-index (pmap fsuc p))

      \func pointed-with-modular-1 {n : Nat} (C : Fin n -> \Type)
                                   (f g : \Pi (i : Fin n) -> C i)
                                   (delim : Fin n)
                                   (i : Fin n)
        : modular-function C f g (suc delim) i = pointed-function C (modular-function C f g delim) delim (g delim) i \elim n, delim, i
        | suc n, 0, 0 => idp
        | suc n, 0, suc i => rewrite modular-function.left-eq idp
        | suc n, suc delim, 0 => idp
        | suc n, suc delim, suc i => pointed-with-modular-1 (\lam i => C (suc i)) (\lam i => f (suc i)) (\lam j => g (suc j)) (delim) i
        \where {
          \func ext'  {n : Nat} (C : Fin n -> \Type)
                      (f g : \Pi (i : Fin n) -> C i)
                      (delim : Fin n)
            : modular-function C f g (suc delim) = pointed-function C (modular-function C f g delim) delim (g delim) => ext (pointed-with-modular-1 C f g delim)
        }

      \func pointed-with-modular-2 {n : Nat} (C : Fin n -> \Type)
                                   (f g : \Pi (i : Fin n) -> C i)
                                   (delim : Fin n)
                                   (i : Fin n)
        : modular-function C f g delim i = pointed-function C (modular-function C f g delim) delim (f delim) i \elim n, delim, i
        | suc n, 0, 0 => idp
        | suc n, 0, suc i => idp
        | suc n, suc delim, 0 => idp
        | suc n, suc delim, suc i => pointed-with-modular-2 (\lam i => C (suc i)) (\lam i => f (suc i)) (\lam j => g (suc j)) (delim) i
        \where {
          \func ext'  {n : Nat} (C : Fin n -> \Type)
                      (f g : \Pi (i : Fin n) -> C i)
                      (delim : Fin n)
            : modular-function C f g delim = pointed-function C (modular-function C f g delim) delim (f delim) => ext (pointed-with-modular-2 C f g delim)
        }

      \func insert-term {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort} (f : symbol s)
                        (choosing : \Pi (index : Fin (length (env.domain f))) -> Term env (context ++ (f FSignature.!!param index)) (f FSignature.!!sort index) ms)
                        (index : Fin (length (env.domain f)))
                        (point : Term env (context ++ (f FSignature.!!param index)) (f FSignature.!!sort index) ms)
        : Term env context s ms =>
        func f
            (pointed-function
                (\lam index => Term env (context ++ (f FSignature.!!param index)) (f FSignature.!!sort index) ms)
                choosing
                index
                point)

      \func unfold-bpr
        {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
        {gc : Color} {someColor : Maybe Color} (required-color : Color)
        (A B : Term env context s mc)
        (bpr : BorderedParallelReduction gc someColor A B)
        : \Sigma (midterm : Term env context s mc)
                 (new-color : Maybe Color)
                 (bpr : BorderedParallelReduction gc new-color A midterm)
                 ((new-color = nothing) `Or` (new-color = just (Color.flip required-color)))
                 (nc' : Maybe Color)
                 ((nc' = nothing) `Or` (nc' = just required-color))
                 (cwr : ColorwiseReduction gc nc' midterm B)
      \elim someColor, A, bpr
        | _, A, equal-trees p => (A, nothing, equal-trees idp, inl idp, nothing, inl idp, cr-skip p)
        | nothing, func f choosing, parallelization-f mediator _x c => (func f mediator, nothing, parallelization-f mediator _x (cr-skip idp), inl idp, nothing, inl idp, c)
        | just a, func f choosing, parallelization-f mediator _x (cr-rewrite t p) => \case \elim gc, \elim required-color, \elim a, \elim _x, \elim t, \elim p \with {
          | red, red, red, _x, tlcr, p => ((func f mediator), nothing, parallelization-f mediator _x (cr-skip idp), inl idp, just red, inr idp, cr-rewrite tlcr idp)
          | red, blue, red, _x, tlcr, p => (B, just red, parallelization-f mediator _x (cr-rewrite tlcr idp), inr idp, nothing, inl idp, cr-skip idp)
          | blue, red, blue, _x, tlcr, p => (B, just blue, parallelization-f mediator _x (cr-rewrite tlcr idp), inr idp, nothing, inl idp, cr-skip idp)
          | blue, blue, blue, _x, tlcr, p => ((func f mediator), nothing, parallelization-f mediator _x (cr-skip idp), inl idp, just blue, inr idp, cr-rewrite tlcr idp)
        }
    }

  \func modular-function
    {n : Nat}
    (C : Fin n -> \Type)
    (f g : \Pi (i : Fin n) -> C i)
    (delim : Fin (suc n))
    (i : Fin n)
    : C i
  \elim n, delim, i
    | suc n, 0, i => f i
    | suc n, suc delim, 0 => g 0
    | suc n, suc delim, suc i => modular-function (\lam i => C (suc i)) (\lam i => f (suc i)) (\lam i => g (suc i)) delim i
    \where {
      \func left-eq {n : Nat}
                    (C : Fin (n) -> \Type)
                    (f g : \Pi (i : Fin (n)) -> C i)
                    (i : Fin n) : modular-function C f g 0 i = f i \elim n, i
        | suc n, i => idp

      \func left-eq-ext {n : Nat}
                        (C : Fin (n) -> \Type)
                        (f g : \Pi (i : Fin (n)) -> C i) :  modular-function C f g 0 = f => ext (left-eq C f g)

      \func inject-nat (n : Nat) : Fin (suc n) \elim n
        | 0 => 0
        | suc n => suc (inject-nat n)

      \func right-eq {n : Nat}
                     (C : Fin (n) -> \Type)
                     (f g : \Pi (i : Fin (n)) -> C i)
                     (i : Fin n)
        : modular-function C f g (inject-nat n) i = g i \elim n, i
        | suc n, 0 => idp
        | suc n, suc i => (right-eq (\lam i => C (suc i)) (\lam i => f (suc i)) (\lam i => g (suc i)) i)

      \func modular-jump {n : Nat}
                         (C : Fin (n) -> \Type)
                         (f g : \Pi (i : Fin (n)) -> C i)
                         (delim : Fin n)
                         (eq : f delim = g delim)
                         (j : Fin n)
        : modular-function C f g delim j = modular-function C f g (suc delim) j \elim n, delim, j
        | suc n, 0, 0 => eq
        | suc n, 0, suc j => rewrite left-eq idp
        | suc n, suc delim, 0 => idp
        | suc n, suc delim, suc j => modular-jump (\lam i => C (suc i)) (\lam i => f (suc i)) (\lam i => g (suc i)) delim eq j
        \where {
          \func ext' {n : Nat}
                     (C : Fin (n) -> \Type)
                     (f g : \Pi (i : Fin (n)) -> C i)
                     (delim : Fin n)
                     (eq : f delim = g delim) : modular-function C f g delim = modular-function C f g (suc delim) =>
            ext (modular-jump C f g delim eq)
        }

      \func right-eq-ext
        {n : Nat}
        (C : Fin (n) -> \Type)
        (f g : \Pi (i : Fin (n)) -> C i) : modular-function C f g (inject-nat n) = g => ext (right-eq C f g)
    }

  \func progressive-induction
    {n : Nat} (C : Fin n -> \Type)
    (Q : (\Pi (i : Fin n) -> C i) -> \Type)
    (f g : \Pi (i : Fin n) -> C i)
    (start : Q f)
    (step : \Pi (delim : Fin n) (Q (modular-function C f g delim)) -> Q (modular-function C f g (suc delim)))
    : Q g => transport Q (modular-function.right-eq-ext C f g) (progressive-induction-lemma {n} C Q f g step (modular-function.inject-nat n) start)
    \where {
      \func progressive-induction-lemma
        {n : Nat} (C : Fin n -> \Type)
        (Q : (\Pi (i : Fin n) -> C i) -> \Type)
        (f g : \Pi (i : Fin n) -> C i)
        (step : \Pi (delim : Fin n) (Q (modular-function C f g delim)) -> Q (modular-function C f g (suc delim)))
        (delim : Fin (suc n))
        (start : Q f)
        : Q (modular-function C f g delim) \elim n, delim
        | 0, 0 => transportInv (Q) (modular-function.left-eq-ext C f g) start
        | suc n, 0 => start
        | suc n, suc delim => step delim (progressive-induction-lemma {suc n} C Q f g step delim start)
    }

  \func collect-reductions-together-raw
    {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
    {gc : Color}
    (f : env.symbol s)
    (choosing-A choosing-B : \Pi (index : Fin (length (env.domain f))) -> Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc)
    (tlcrs : \Pi (index : Fin (length (env.domain f))) -> \Sigma (someColor : Maybe Color) (BorderedParallelReduction gc someColor (choosing-A index) (choosing-B index)))
    : \Sigma
    (someColor : Maybe Color)
    (mediator : \Pi (index : Fin (length (env.domain f))) ->
        Term env (context ++ (f env.!!param index)) (f env.!!sort index) mc)
    (\Pi (i : F-param-index {env} f) -> \Sigma
      (someColor : Maybe Color)
      ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root f))))
      (BorderedParallelReduction gc someColor (choosing-A i) (mediator i)))
    (ColorwiseReduction gc someColor (func f mediator) (func f choosing-B)) =>
    collect-reductions-together-tlcr nothing f (choosing-A) choosing-B tlcrs (func f choosing-B) (cr-skip idp)
}
