\import Data.List (length)
\import Data.Or
\import Logic
\import Logic.Meta
\import Paths
\import Set
\import TRS.HRS
\import TRS.List

\func F-param-index {Sort : \Set} {fs : FunctionalSignature Sort} {s : Sort} (f : fs.symbol s) : \Set =>
  Fin (length (fs.domain f))

\func promote-fin {x : Nat} {y : Fin x} (z : Fin y) : Fin x \elim x, y, z
  | suc x, suc y, 0 => 0
  | suc x, suc y, suc z => suc (promote-fin {x} {y} z)

\func Fin-neq {x : Nat} (y z : Fin x) : \Prop \elim x, y, z
  | suc n, zero, zero => \Sigma
  | suc n, zero, suc z => Empty
  | suc n, suc y, zero => Empty
  | suc n, suc y, suc z => Fin-neq y z

\func minusOne {n : Nat} (a : Fin n) : Fin n \elim n, a
  | suc n, zero => zero
  | suc n, suc a => a

\func FinDec {n : Nat} (x y : Fin n) : Dec (x = y) => {?}

\func transport2-to-transport {A B : \Type} {C : A -> B -> \Type} (a a' : A) (eq : a = a') (b : B) (c : C a b) : transport2 C eq idp c = transport (C __ b) eq c \elim eq
  | idp => idp

\func flip-or {A B : \Type} (x : Or A B) : Or B A \elim x
  | inl a => inr a
  | inr b => inl b

\data TripleOr (A B C : \Type)
  | in1 A
  | in2 B
  | in3 C