\import Data.List (::, List, nil)
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Set.Fin
\import TRS.HRS
\import TRS.List

\data SingularSort | lc-term

\data LC-Symbols : \Set | abstraction | application

\func LC-FSignature : FunctionalSignature SingularSort \cowith
  | symbol sort => LC-Symbols
  | domain symb => \case \elim symb \with {
    | abstraction => (lc-term :: nil, lc-term) :: nil
    | application => (nil, lc-term) :: (nil, lc-term) :: nil
  }

\func LC-MSignature : MetaSignature SingularSort \cowith
  | metasymbol sort => MetaVariables
  | metadomain var => \case \elim var \with {
    | metavar-a => lc-term :: nil
    | metavar-b => nil
  }

\data MetaVariables | metavar-a | metavar-b

\instance LC-Env : Environment \cowith
  | Sort => SingularSort
  | FunctionalSymbol => LC-FSignature
  | MetaVariable => LC-MSignature

\func BetaRedex : Term LC-Env nil lc-term =>
  func application
      (\lam i => \case \elim i \with {
        | fzero => MVarWithAbstraction
        | fsuc fzero => metavar metavar-b (\lam _ => contradiction)
        | fsuc (fsuc x) => contradiction
      })

\func MVarWithAbstraction : Term LC-Env nil lc-term =>
  func abstraction (\lam i => \case \elim i \with {
    | fzero => metavar metavar-a (\lam j => \case \elim j \with {
      | fzero => var fzero idp
      | fsuc j => contradiction
    })
    | fsuc i => contradiction
  })

\func BetaResult : Term LC-Env nil lc-term =>
  metavar metavar-a (\lam i => \case \elim i \with {
    | fzero => metavar metavar-b (\lam _ => contradiction)
    | fsuc i => contradiction
  })

\func beta-reduction : RewriteRule LC-Env \cowith
  | s => lc-term
  | l => BetaRedex
  | r => BetaResult
  | r-is-not-generating => {?}

\func LC-rules : IndexedSet (RewriteRule LC-Env) \cowith
  | J => \Sigma
  | get index => \case \elim index \with {
    | () => beta-reduction
  }

\instance UntypedLambdaCalculus : SimpleHigherOrderTermRewritingSystem \cowith
  | env => LC-Env
  | set-of-rules => LC-rules


-- \x.\y.x
\func K : Term LC-Env nil lc-term => func abstraction (\lam i => \case \elim i \with {
  | fzero => func abstraction (\lam j => \case \elim j \with {
    | fzero => var (fsuc fzero) idp
    | fsuc _ => contradiction
  })
  | fsuc _ => contradiction
})

-- \x.x
\func I : Term LC-Env nil lc-term => func abstraction (\lam i => \case \elim i \with {
  | fzero => var fzero idp
  | fsuc i => contradiction
})

-- (\x.x) (\x.x)
\func I_I : Term LC-Env nil lc-term =>
  func application (\lam i => \case \elim i \with {
    | fzero => I
    | fsuc fzero => I
    | fsuc (fsuc x) => contradiction
  })

\func suitable-substitution : MetaSubstitution LC-Env nil =>
  \lam {sort} mvar => \case \elim sort, \elim mvar \with {
    | lc-term, metavar-a => var fzero idp
    | lc-term, metavar-b => I
  }

\func rewrite-step : RewriteStep I_I I \cowith
  | rule => beta-reduction
  | substitution => suitable-substitution
  | left-coherence => {?}
  | right-coherence => {?}

\func I_I~>I : RewriteRelation LC-rules I_I I => rewrite-with-rule rewrite-step ((), idp)
