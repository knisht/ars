\import Data.List (++, List, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.List
\import TRS.Substitutions
\import TRS.Union
\import TRS.Utils
\open Confluence
\open Confluence.TheoremContext

\func join-tlcrs {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                 (color : Color)
                 (A B C : Term env context s meta-signature)
                 (A~>B : TopLevelColoredReduction color A B)
                 (A~>C : TopLevelColoredReduction color A C)
                 (monochrome-confluence : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin B C (Closure (TopLevelColoredReduction color)) =>
  \let | (inner-ms, a, subst, eq-a) => decompose-term color SubList.identity A
       | (b, eq-b, a~>b) => (decompose-along-reduction {_} {_} {_} {inner-ms} {meta-signature} color a B subst (transport (TopLevelColoredReduction color __ B) (inv eq-a) A~>B))
       | (c, eq-c, a~>c) => (decompose-along-reduction {_} {_} {_} {inner-ms} {meta-signature} color a C subst (transport (TopLevelColoredReduction color __ C) (inv eq-a) A~>C))
       | join-b-c : StraightJoin b c (Closure (monochrome-reduction color {_} {_} {inner-ms})) => join-monochrome-terms color {_} {_} {inner-ms} a b c a~>b a~>c monochrome-confluence
       | injected-reduct => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} join-b-c.common-reduct) SubList.identity subst
       | lifted-b~>d => Closure.lift {_} {_} {_} {\lam e f => TopLevelColoredReduction color e f}
           (\lam term => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} term) SubList.identity subst)
           (lift-relation {_} {_} {_} {inner-ms} color subst)
           b
           join-b-c.common-reduct
           join-b-c.a~>cr
       | lifted-c~>d => Closure.lift {_} {_} {_} {\lam e f => TopLevelColoredReduction color e f}
           (\lam term => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} term) SubList.identity subst)
           (lift-relation {_} {_} {_} {inner-ms} color subst)
           c
           join-b-c.common-reduct
           join-b-c.b~>cr
  \in \new StraightJoin {
    | common-reduct => injected-reduct
    | a~>cr => transport (Closure (TopLevelColoredReduction color) __ injected-reduct) eq-b lifted-b~>d
    | b~>cr => transport (Closure (TopLevelColoredReduction color) __ injected-reduct) eq-c lifted-c~>d
  }

\func lift-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature outer-meta-signature : MetaSignature Sort'}
                    (color : Color)
                    (subst : MetaSubstitution env context meta-signature outer-meta-signature)
                    {t u : Term (colored-env color) context s meta-signature}
                    (t~>u : monochrome-reduction color t u)
  : TopLevelColoredReduction color
    (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.identity subst)
    (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.identity subst) => {?}

\func decompose-term {tc : TheoremContext} {global-context context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                     (color : Color)
                     (sublist : SubList global-context context)
                     (A : Term env context s meta-signature) :
  \Sigma (new-meta-signature : MetaSignature Sort')
         (t : Term (colored-env {tc} color) context s new-meta-signature)
         (subst : MetaSubstitution env global-context new-meta-signature meta-signature)
         (MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist subst = A) \elim color, A
  | color, var index p =>
    \let | empty-signature => \new MetaSignature Sort' {
      | metaname _ => Empty
      | m-domain a => contradiction
    }
    \in (empty-signature, var index p, \lam _ => contradiction, \case \elim color, \elim empty-signature \with {
      | red, sig => idp
      | blue, sig => idp
    })
  | color, metavar m choosing =>
    \let | inner-results i => decompose-term color sublist (choosing i)
         | signature-producer i => (inner-results i).1
         | unified-metasignature => PointedModularMetaSignature {colored-env color} m signature-producer
         | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature =>
           \lam {s'} m => \case \elim m \with {
           | inl a => \let q => weakening {env} {_} {_} {meta-signature.m-domain m ++ global-context} (metavar {env} m (\lam index => var index idp)) ((SubList.extend-right-single SubList.identity)) \in transport (Term env (meta-signature.m-domain m ++ global-context) __ meta-signature) a q
           | inr b => ((inner-results (b.1)).3 b.2)
         }
    \in (unified-metasignature,
         metavar (inl idp) (\lam i => upgrade-metavariables-to-pointed {colored-env color} m signature-producer (inner-results i).2),
         unified-substitution,
         {?}) -- provable, technical
  | red, func (inl f) choosing => \let | inner-results (i : F-param-index {_} {env.FunctionalSymbol} (inl f)) => decompose-term red (SubList.extend-right-single-left sublist) (choosing i)
                                       | signature-producer i => (inner-results i).1
                                       | unified-metasignature => ModularMetaSignature {env} signature-producer
                                       | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam m => ((inner-results (m.1)).3 m.2)
                                  \in (unified-metasignature,
                                       func f (\lam index => upgrade-metavariables {envL} signature-producer (inner-results index).2),
                                       unified-substitution,
                                       pmap (func {env {tc}} (inl f)) (ext (\lam i => {?})))
  | blue, func (inl f) choosing => {?}
  | red, func (inr f) choosing =>
    \let | singular-signature => \new MetaSignature Sort' {
      | metaname s' => s = s'
      | m-domain p => context
    }
         | singular-term : Term envL context s singular-signature => metavar idp (\lam i => var i idp)
         | singular-metasubstitution : MetaSubstitution env global-context singular-signature meta-signature =>
           \lam m => weakening {env {tc}} (transport (Term env context __ meta-signature) m (func {env {tc}} (inr (f : tc.envR.FunctionalSymbol.symbol s)) choosing)) (SubList.extend-right-single SubList.identity)
    \in (singular-signature, singular-term, singular-metasubstitution, pmap (func {env} (inr f)) (ext (\lam i => {?})))
  | blue, func (inr b) choosing => {?}

\func join-monochrome-terms {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                            (a b c : Term (colored-env color) context s meta-signature)
                            (a~>b : monochrome-reduction color a b)
                            (a~>c : monochrome-reduction color a c)
                            (conf : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin b c (Closure (monochrome-reduction color)) \elim color
  | red => conf a b c a~>b a~>c
  | blue => conf a b c a~>b a~>c

\func decompose-along-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
                                (color : Color)
                                (t : Term (colored-env {tc} color) context s inner-meta-signature)
                                (B : Term env context s meta-signature)
                                (subst : MetaSubstitution env context inner-meta-signature meta-signature)
                                (A~>B : TopLevelColoredReduction color (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.identity subst) B)
  : \Sigma (u : Term (colored-env color) context s inner-meta-signature)
           (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.identity subst = B)
           (monochrome-reduction color t u) \elim color, t, B, A~>B
  | red, func f choosing, func f1 choosing1, rewrite-with-parameter-f-colored p h step => {?}
  | blue, func f choosing, func f1 choosing1, rewrite-with-parameter-f-colored p h step => {?}
  | red, var index p, B, rewrite-with-rule-colored h step => {?} -- top level symbol must be func
  | blue, var index p, B, rewrite-with-rule-colored h step => {?} -- same as above
  | red, metavar m choosing, B, A~>B => {?} -- deep diving in colors
  | blue, metavar m choosing, B, A~>B => {?}
  | color, func f choosing, B, rewrite-with-rule-colored h (((rule : LinearRewriteRule),injected-metasubst,l[inner-ms]=injt,r[inner-ms]=B)) =>
    \let | pattern => uninject-linear-pattern color rule.linear-pattern
         | linear-ms-eq : LinearMetasignature {colored-env color} pattern = LinearMetasignature {env} (rule.linear-pattern) => {?}
         | uninjected-metasubst => rewriteI linear-ms-eq injected-metasubst
         | modified-eq : MetaSubstitution.apply {env}
             (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} pattern)) sublist-trivial) SubList.identity uninjected-metasubst
           = MetaSubstitution.apply {env} (inject-monochrome-term color (func f choosing)) SubList.identity subst
         => {?}
         | (middle-subst, substitution-equality, l-eq) => decompose-metasubstitution color sublist-trivial pattern (func f choosing) uninjected-metasubst subst modified-eq
         | uninjected-r => rewriteI linear-ms-eq (uninject-term color rule.r)
         | term-u => MetaSubstitution.apply {colored-env color} (weakening {colored-env color} uninjected-r sublist-trivial) SubList.identity middle-subst
         | coh => coherent-application {env} (inv linear-ms-eq) injected-metasubst rule.r
         | x => {?}
    \in (term-u, (unfold term-u {?}) *> (inv coh) *> r[inner-ms]=B, produce-monochrome-reduction color pattern uninjected-r middle-subst (func f choosing) term-u l-eq idp)

\func coherent-application {env : Environment} {context  : List Sort} {inner-meta-signature meta-signature inner-meta-signature' : MetaSignature Sort}
                           (metasig-eq : inner-meta-signature = inner-meta-signature')
                           (subst : MetaSubstitution env context inner-meta-signature meta-signature)
                           {s : Sort}
                           (T : Term env nil s inner-meta-signature)
  : MetaSubstitution.apply (weakening T sublist-trivial) SubList.identity subst = MetaSubstitution.apply {_} {_} {_} {_} {inner-meta-signature'} (weakening (rewriteI metasig-eq T) sublist-trivial) SubList.identity (rewriteI metasig-eq subst) \elim inner-meta-signature, metasig-eq
  | metasig, idp => idp

\func produce-monochrome-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                                   (pattern : LinearPattern (colored-env color) nil s)
                                   (rule-r : Term (colored-env color) nil s (LinearMetasignature {colored-env color} pattern))
                                   (subst : MetaSubstitution (colored-env color) context (LinearMetasignature {colored-env color} pattern) meta-signature)
                                   (l r : Term (colored-env color) context s meta-signature)
                                   (l-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} pattern) sublist-trivial) SubList.identity subst = l)
                                   (r-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} rule-r sublist-trivial) SubList.identity subst = r)
  : monochrome-reduction color l r \elim color
  | red => rewrite-with-rule (\new RewriteStep {
    | rule => \new LinearRewriteRule {
      | linear-pattern => pattern
      | r => rule-r
      | l-is-func => {?} -- easy
    }
    | substitution => subst
    | left-coherence => l-eq
    | right-coherence => r-eq
  }) {?} -- easy
  | blue => {?} -- same as above

\func uninject-linear-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                              (l : LinearPattern env context s)
  : LinearPattern (colored-env color) context s \elim color, l
  | color, lp-var index p => lp-var index p
  | red, lp-func (inl f) choosing => lp-func f (\lam index => uninject-linear-pattern red (choosing index))
  | blue, lp-func (inr f) choosing => lp-func f (\lam index => uninject-linear-pattern blue (choosing index))
  | color, lp-metavar => lp-metavar {colored-env color}
  | red, lp-func (inr b) choosing => {?}
  | blue, lp-func (inl a) choosing => {?}

\func uninject-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                    (t : Term env context s meta-signature)
  : Term (colored-env color) context s meta-signature => {?}

\func metacomposition {env : Environment} {global-context : List Sort} {ms-a ms-b ms-c : MetaSignature Sort}
                      (subst-a : MetaSubstitution env global-context ms-a ms-b)
                      (subst-b : MetaSubstitution env global-context ms-b ms-c)
                      (subst-c : MetaSubstitution env global-context ms-a ms-c)
                      (eq : \Pi {s : Sort} (m : ms-a.metaname s) ->
                          subst-c m = MetaSubstitution.apply (subst-a m) (SubList.extend-right-single-left SubList.identity) subst-b)
                      {context : List Sort} {s : Sort} (sublist : SubList global-context context) (t : Term env context s ms-a)
  : MetaSubstitution.apply t sublist subst-c = MetaSubstitution.apply (MetaSubstitution.apply t sublist subst-a) sublist subst-b \elim t
  | var index p => idp
  | metavar m choosing =>
    \let inner : (\lam i => MetaSubstitution.apply (choosing i) sublist subst-c) = (\lam i => MetaSubstitution.apply (MetaSubstitution.apply (choosing i) sublist subst-a) sublist subst-b) => ext (\lam i => metacomposition subst-a subst-b subst-c eq sublist (choosing i))
    \in rewrite (eq m) (inv (rewrite inner (meta-ext.commutation sublist subst-b (\lam i => MetaSubstitution.apply (choosing i) sublist subst-a) (subst-a m))))
  | func f choosing => pmap (func f) (ext (\lam index => metacomposition subst-a subst-b subst-c eq (SubList.extend-right-single-left sublist) (choosing index)))

\func meta-ext {env : Environment} {global-context context : List Sort} {ms-a ms-b ms-c : MetaSignature Sort}
               (subst-a : MetaSubstitution env global-context ms-a ms-b)
               (subst-b : MetaSubstitution env global-context ms-b ms-c)
               (sublist : SubList global-context context)
               {s : Sort} (T : Term env context s ms-a)
  : MetaSubstitution.apply
    (MetaSubstitution.apply T sublist subst-a)
    sublist subst-b
  = MetaSubstitution.apply T sublist
        (\lam m => MetaSubstitution.apply (subst-a m) (SubList.extend-right-single-left SubList.identity) subst-b)
\elim T
  | var index p => idp
  | metavar m choosing =>
    \let | inner : (\lam i => MetaSubstitution.apply (MetaSubstitution.apply (choosing i) sublist subst-a) sublist subst-b) = (\lam i => MetaSubstitution.apply (choosing i) sublist (\lam m => MetaSubstitution.apply (subst-a m) (SubList.extend-right-single-left SubList.identity) subst-b))=> ext (\lam i => meta-ext subst-a subst-b sublist (choosing i))
    \in rewriteI inner (commutation sublist subst-b (\lam i => MetaSubstitution.apply (choosing i) sublist subst-a) (subst-a m))
  | func f choosing => pmap (func f) (ext (\lam index => meta-ext subst-a subst-b (SubList.extend-right-single-left sublist) (choosing index)))
  \where {
    \func commutation {env : Environment} {global-context inner-context context : List Sort} {s : Sort} {ms-a ms-b : MetaSignature Sort}
                      (sublist : SubList global-context context)
                      (metasubst : MetaSubstitution env global-context ms-a ms-b)
                      (subst : Substitution inner-context context ms-a)
                      (T : Term env (inner-context ++ global-context) s ms-a)
      : MetaSubstitution.apply (Substitution.apply T (extend-substitution-right sublist subst)) sublist metasubst =
    Substitution.apply (MetaSubstitution.apply T (SubList.extend-right-single-left SubList.identity) metasubst) (extend-substitution-right sublist (\lam i => MetaSubstitution.apply (subst i) sublist metasubst)) \elim T
      | var index p => \case \elim s, \elim p \with {
        | s, idp => {?}
      }
      | metavar m choosing => {?}
      | func f choosing => pmap (func f) (ext (\lam index => {?}))
  }

\func decompose-metasubstitution {tc : TheoremContext} {pattern-context context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
                                 (color : Color)
                                 (sublist : SubList pattern-context context)
                                 (l : LinearPattern (colored-env color) pattern-context s)
                                 (t : Term (colored-env color) context s inner-meta-signature)
                                 (uninjected-metasubst : MetaSubstitution env context (LinearMetasignature {colored-env color} l) meta-signature)
                                 (subst : MetaSubstitution env context inner-meta-signature meta-signature)
                                 (eq : MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} l)) sublist) SubList.identity uninjected-metasubst =
                                 MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.identity subst)
  : \Sigma (middle-subst : MetaSubstitution (colored-env color) context (LinearMetasignature {colored-env color} l) inner-meta-signature)
           (\Pi {s : Sort'} (m : metaname {LinearMetasignature {colored-env color} l} s) -> uninjected-metasubst m = MetaSubstitution.apply {env} (inject-monochrome-term color (middle-subst m)) (SubList.extend-right-single-left SubList.identity) subst)
           (MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} l) sublist) SubList.identity middle-subst = t) \elim color, l, t, eq
  | red, lp-var index p, var index1 p1, eq => {?}
  | red, lp-var index p, metavar m choosing, eq => {?}
  | red, lp-func f choosing, metavar m choosing1, eq => {?}
  | red, lp-func f choosing, func f1 choosing1, eq => {?}
  | red, lp-metavar, var index p, eq => {?}
  | red, lp-metavar, metavar m choosing, eq => {?}
  | red, lp-metavar, func f choosing, eq => {?}
  | blue, lp-var index p, var index1 p1, eq => {?}
  | blue, lp-var index p, metavar m choosing, eq => {?}
  | blue, lp-func f choosing, metavar m choosing1, eq => {?}
  | blue, lp-func f choosing, func f1 choosing1, eq => {?}
  | blue, lp-metavar, var index p, eq => {?}
  | blue, lp-metavar, metavar m choosing, eq => {?}
  | blue, lp-metavar, func f choosing, eq => {?}

