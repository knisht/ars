\import Data.List (++, List)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.List
\import TRS.Substitutions
\import TRS.Union
\import TRS.Utils
\open Confluence
\open Confluence.TheoremContext

\func join-tlcrs {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                 (color : Color)
                 (A B C : Term env context s meta-signature)
                 (A~>B : TopLevelColoredReduction color A B)
                 (A~>C : TopLevelColoredReduction color A C)
                 (monochrome-confluence : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin B C (Closure (TopLevelColoredReduction color)) =>
  \let | (inner-ms, a, subst, eq-a) => decompose-term color SubList.identity A
       | (b, eq-b, a~>b) => (decompose-along-reduction {_} {_} {_} {inner-ms} {meta-signature} color a B subst (transport (TopLevelColoredReduction color __ B) (inv eq-a) A~>B))
       | (c, eq-c, a~>c) => (decompose-along-reduction {_} {_} {_} {inner-ms} {meta-signature} color a C subst (transport (TopLevelColoredReduction color __ C) (inv eq-a) A~>C))
       | join-b-c : StraightJoin b c (Closure (monochrome-reduction color {_} {_} {inner-ms})) => join-monochrome-terms color {_} {_} {inner-ms} a b c a~>b a~>c monochrome-confluence
       | injected-reduct => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} join-b-c.common-reduct) SubList.identity subst
       | lifted-b~>d => Closure.lift {_} {_} {_} {\lam e f => TopLevelColoredReduction color e f}
           (\lam term => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} term) SubList.identity subst)
           (lift-relation {_} {_} {_} {inner-ms} color subst)
           b
           join-b-c.common-reduct
           join-b-c.a~>cr
       | lifted-c~>d => Closure.lift {_} {_} {_} {\lam e f => TopLevelColoredReduction color e f}
           (\lam term => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} term) SubList.identity subst)
           (lift-relation {_} {_} {_} {inner-ms} color subst)
           c
           join-b-c.common-reduct
           join-b-c.b~>cr
  \in \new StraightJoin {
    | common-reduct => injected-reduct
    | a~>cr => transport (Closure (TopLevelColoredReduction color) __ injected-reduct) eq-b lifted-b~>d
    | b~>cr => transport (Closure (TopLevelColoredReduction color) __ injected-reduct) eq-c lifted-c~>d
  }

\func lift-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature outer-meta-signature : MetaSignature Sort'}
                    (color : Color)
                    (subst : MetaSubstitution env context meta-signature outer-meta-signature)
                    {t u : Term (colored-env color) context s meta-signature}
                    (t~>u : monochrome-reduction color t u)
  : TopLevelColoredReduction color
    (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.identity subst)
    (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.identity subst) => {?}

\func decompose-term {tc : TheoremContext} {global-context context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                     (color : Color)
                     (sublist : SubList global-context context)
                     (A : Term env context s meta-signature) :
  \Sigma (new-meta-signature : MetaSignature Sort')
         (t : Term (colored-env {tc} color) context s new-meta-signature)
         (subst : MetaSubstitution env global-context new-meta-signature meta-signature)
         (MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist subst = A) \elim color, A
  | color, var index p =>
    \let | empty-signature => \new MetaSignature Sort' {
      | metaname _ => Empty
      | m-domain a => contradiction
    }
    \in (empty-signature, var index p, \lam _ => contradiction, \case \elim color, \elim empty-signature \with {
      | red, sig => idp
      | blue, sig => idp
    })
  | color, metavar m choosing =>
    \let | inner-results i => decompose-term color sublist (choosing i)
         | signature-producer i => (inner-results i).1
         | unified-metasignature => PointedModularMetaSignature {colored-env color} m signature-producer
         | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature =>
           \lam {s'} m => \case \elim m \with {
           | inl a => \let q => weakening {env} {_} {_} {meta-signature.m-domain m ++ global-context} (metavar {env} m (\lam index => var index idp)) ((SubList.extend-right-single SubList.identity)) \in transport (Term env (meta-signature.m-domain m ++ global-context) __ meta-signature) a q
           | inr b => ((inner-results (b.1)).3 b.2)
         }
    \in (unified-metasignature,
         metavar (inl idp) (\lam i => upgrade-metavariables-to-pointed {colored-env color} m signature-producer (inner-results i).2),
         unified-substitution,
         {?}) -- provable, technical
  | red, func (inl f) choosing => \let | inner-results (i : F-param-index {_} {env.FunctionalSymbol} (inl f)) => decompose-term red (SubList.extend-right-single-left sublist) (choosing i)
                                       | signature-producer i => (inner-results i).1
                                       | unified-metasignature => ModularMetaSignature {env} signature-producer
                                       | unified-substitution : MetaSubstitution env global-context unified-metasignature meta-signature => \lam m => ((inner-results (m.1)).3 m.2)
                                  \in (unified-metasignature,
                                       func f (\lam index => upgrade-metavariables {envL} signature-producer (inner-results index).2),
                                       unified-substitution,
                                       pmap (func {env {tc}} (inl f)) (ext (\lam i => {?})))
  | blue, func (inl f) choosing => {?}
  | red, func (inr f) choosing =>
    \let | singular-signature => \new MetaSignature Sort' {
      | metaname s' => s = s'
      | m-domain p => context
    }
         | singular-term : Term envL context s singular-signature => metavar idp (\lam i => var i idp)
         | singular-metasubstitution : MetaSubstitution env global-context singular-signature meta-signature =>
           \lam m => weakening {env {tc}} (transport (Term env context __ meta-signature) m (func {env {tc}} (inr (f : tc.envR.FunctionalSymbol.symbol s)) choosing)) (SubList.extend-right-single SubList.identity)
    \in (singular-signature, singular-term, singular-metasubstitution, pmap (func {env} (inr f)) (ext (\lam i => {?})))
  | blue, func (inr b) choosing => {?}

\func join-monochrome-terms {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                            (a b c : Term (colored-env color) context s meta-signature)
                            (a~>b : monochrome-reduction color a b)
                            (a~>c : monochrome-reduction color a c)
                            (conf : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin b c (Closure (monochrome-reduction color)) \elim color
  | red => conf a b c a~>b a~>c
  | blue => conf a b c a~>b a~>c

\func decompose-along-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
                                (color : Color)
                                (t : Term (colored-env {tc} color) context s inner-meta-signature)
                                (B : Term env context s meta-signature)
                                (subst : MetaSubstitution env context inner-meta-signature meta-signature)
                                (A~>B : TopLevelColoredReduction color (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.identity subst) B)
  : \Sigma (u : Term (colored-env color) context s inner-meta-signature)
           (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.identity subst = B)
           (monochrome-reduction color t u) \elim color, t, B, A~>B
  | red, func f choosing, func f1 choosing1, rewrite-with-parameter-f-colored p h step => {?}
  | blue, func f choosing, func f1 choosing1, rewrite-with-parameter-f-colored p h step => {?}
  | red, var index p, B, rewrite-with-rule-colored h step => {?} -- top level symbol must be func
  | blue, var index p, B, rewrite-with-rule-colored h step => {?} -- same as above
  | red, metavar m choosing, B, A~>B => {?} -- deep diving in colors
  | blue, metavar m choosing, B, A~>B => {?}
  | color, func f choosing, B, rewrite-with-rule-colored h (((rule : LinearRewriteRule),inner-ms,l[inner-ms]=injt,r[inner-ms]=B)) =>
    \let | pattern => uninject-linear-pattern color rule.linear-pattern
         | s-subst => downgrade-metasubstitution color inner-ms
         | linear-ms-eq : LinearMetasignature {colored-env color} pattern = LinearMetasignature {env} (rule.linear-pattern) => {?}
         | modified-eq : MetaSubstitution.apply {env}
             (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} pattern)) sublist-trivial) SubList.identity
             s-subst = MetaSubstitution.apply {env} (inject-monochrome-term color (func f choosing)) SubList.identity subst => {?}
         | (inner-subst, peq) => decompose-metasubstitution color sublist-trivial pattern (func f choosing) (s-subst) subst modified-eq
         | uninjected-r => rewriteI linear-ms-eq (uninject-term color rule.r)
         | term-u => MetaSubstitution.apply {colored-env color} (weakening {colored-env color} uninjected-r sublist-trivial) SubList.identity inner-subst
    \in (term-u, (unfold term-u {?}) *> r[inner-ms]=B, produce-monochrome-reduction color (func f choosing) term-u)

\func produce-monochrome-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                                   (l r : Term (colored-env color) context s meta-signature) : monochrome-reduction color l r => {?}

\func uninject-linear-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                              (l : LinearPattern env context s)
  : LinearPattern (colored-env color) context s => {?}

\func uninject-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                    (t : Term env context s meta-signature)
  : Term (colored-env color) context s meta-signature => {?}

\func downgrade-metasubstitution {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                                 {p : LinearPattern env context' s}
                                 (subst : MetaSubstitution env context (LinearMetasignature {env} p) meta-signature)
  : MetaSubstitution env context (LinearMetasignature {colored-env color} (uninject-linear-pattern color p)) meta-signature =>
  {?}

\func decompose-metasubstitution {tc : TheoremContext} {pattern-context context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
                                 (color : Color)
                                 (sublist : SubList pattern-context context)
                                 (l : LinearPattern (colored-env color) pattern-context s)
                                 (t : Term (colored-env color) context s inner-meta-signature)
                                 (subst-from-pattern : MetaSubstitution env context (LinearMetasignature {colored-env color} l) meta-signature)
                                 (subst-from-injected : MetaSubstitution env context inner-meta-signature meta-signature)
                                 (eq : MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} l)) sublist) SubList.identity subst-from-pattern =
                                 MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.identity subst-from-injected)
  : \Sigma (inter-subst : MetaSubstitution (colored-env color) context (LinearMetasignature {colored-env color} l) inner-meta-signature)
           (\Pi {s : Sort'} (m : metaname {LinearMetasignature {colored-env color} l} s) -> subst-from-pattern m = MetaSubstitution.apply {env} (inject-monochrome-term color (inter-subst m)) (SubList.extend-right-single-left SubList.identity) subst-from-injected) \elim color, l, t, eq
  | red, lp-var index p, var index1 p1, eq => {?}
  | red, lp-var index p, metavar m choosing, eq => {?}
  | red, lp-func f choosing, metavar m choosing1, eq => {?}
  | red, lp-func f choosing, func f1 choosing1, eq => {?}
  | red, lp-metavar, var index p, eq => {?}
  | red, lp-metavar, metavar m choosing, eq => {?}
  | red, lp-metavar, func f choosing, eq => {?}
  | blue, lp-var index p, var index1 p1, eq => {?}
  | blue, lp-var index p, metavar m choosing, eq => {?}
  | blue, lp-func f choosing, metavar m choosing1, eq => {?}
  | blue, lp-func f choosing, func f1 choosing1, eq => {?}
  | blue, lp-metavar, var index p, eq => {?}
  | blue, lp-metavar, metavar m choosing, eq => {?}
  | blue, lp-metavar, func f choosing, eq => {?}

