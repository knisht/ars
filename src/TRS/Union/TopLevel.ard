\import Data.List (++, ++-assoc, ++_nil, List, nil)
\import Data.Or
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Substitutions
\import TRS.Union
\import TRS.Utils
\open Confluence
\open Confluence.TheoremContext

\func join-tlcrs {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                 (color : Color)
                 (A B C : Term env context s meta-signature)
                 (A~>B : TopLevelColoredReduction color A B)
                 (A~>C : TopLevelColoredReduction color A C)
                 (monochrome-confluence : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : \Sigma (X : Term env context s meta-signature) (TopLevelColoredReduction color B X) (TopLevelColoredReduction color C X) =>
  \let | (a, subst, eq-a, _) => decompose-term color A
       | inner-ms => LinearMetasignatureT {colored-env color} a
       | (b, eq-b, a~>b) => (decompose-along-reduction {_} {_} {_} {meta-signature} color (a) B subst (transport (TopLevelColoredReduction color __ B) (inv eq-a) A~>B))
       | (c, eq-c, a~>c) => (decompose-along-reduction {_} {_} {_} {meta-signature} color (a) C subst (transport (TopLevelColoredReduction color __ C) (inv eq-a) A~>C))
       | join-b-c : StraightJoin b c (monochrome-reduction color {_} {_} {inner-ms}) => join-monochrome-terms color {_} {_} {inner-ms} (LinearTerm.convert-to-term {colored-env color} a) b c a~>b a~>c monochrome-confluence
       | injected-reduct => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} join-b-c.common-reduct) sublist-trivial subst
       | lifted-b~>d => lift-relation color subst join-b-c.a~>cr
       | lifted-c~>d => lift-relation color subst join-b-c.b~>cr
  \in (injected-reduct, transport (TopLevelColoredReduction color __ injected-reduct) eq-b lifted-b~>d, transport (TopLevelColoredReduction color __ injected-reduct) eq-c lifted-c~>d)

\func lift-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature outer-meta-signature : MetaSignature Sort'}
                    (color : Color)
                    (subst : MetaSubstitution env nil meta-signature outer-meta-signature)
                    {t u : Term (colored-env color) context s meta-signature}
                    (t~>u : monochrome-reduction color t u)
  : TopLevelColoredReduction color
    (MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist-trivial subst)
    (MetaSubstitution.apply {env} (inject-monochrome-term color u) sublist-trivial subst) => {?}

\data ColoringPredicate {tc : TheoremContext} {context context' : List Sort'} {s s'' : Sort'}
                        (color : Color)
                        {env' : Environment tc.Sort'}
                        {term : LinearTerm env' context s}
                        {meta-signature : MetaSignature Sort'}
                        {s' : Sort'}
                        (m : metaname {LinearMetasignatureT {env'} term} s')
                        (result-term : Term env context' s'' meta-signature) \elim term, m
  | lt-func f choosing, m => c-in-func (ColoringPredicate {tc} color {env'} m.2 result-term)
  | lt-metavar params choosing, inl eq => result-term-is-meta (HasMetaRoot {env {tc}} result-term)
  | lt-metavar params choosing, inr m => c-in-metavar (ColoringPredicate {tc} color {env'} m.2 result-term)
  | lt-full-metavar, m => result-term-has-other-color (HasColoredRoot {tc} color result-term)

\func decompose-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                     (color : Color)
                     (A : Term env context s meta-signature) :
  \Sigma (t : LinearTerm (colored-env {tc} color) context s)
         (subst : MetaSubstitution env nil (LinearMetasignatureT {colored-env color} t) meta-signature)
         (MetaSubstitution.apply {env} (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t)) sublist-trivial subst = A)
         (\Pi {s : Sort'} (m : metaname {LinearMetasignatureT {colored-env color} t} s) -> ColoringPredicate (Color.flip color) {colored-env color} m (subst m)) \elim color, A
  | color, var index p => (lt-var index p, \lam {s1} mvar => contradiction, \case \elim color \with {
    | red => idp
    | blue => idp
  }, \lam {s1} m => contradiction)
  | color, metavar m choosing =>
    \let | inner-results i => decompose-term color (choosing i)
         | signature-producer i => LinearMetasignatureT {colored-env color} (inner-results i).1
         | unified-metasignature => PointedModularMetaSignature {colored-env color} s (m-domain m) signature-producer
         | unified-substitution : MetaSubstitution env nil unified-metasignature meta-signature =>
           \lam {s'} m => \case \elim m \with {
             | inl s'=s => \case \elim s', \elim s'=s \with {
               | s', idp => rewrite ++_nil (metavar m (\lam i => var i idp))
             }
             | inr m => (inner-results m.1).2 m.2
           }
    \in (lt-metavar (m-domain m) (\lam i => (inner-results i).1),
         unified-substitution,
         {?},
         \lam {s1} m1 => {?}) -- provable, technical
  | red, func (inl f) choosing =>
    \let | inner-results i => decompose-term red (choosing i)
         | signature-producer i => LinearMetasignatureT {colored-env red} (inner-results i).1
         | unified-metasignature => ModularMetaSignature {env} signature-producer
         | unified-substitution : MetaSubstitution env nil unified-metasignature meta-signature => \lam m => (inner-results m.1).2 m.2
    \in (lt-func f (\lam i => (inner-results i).1),
         unified-substitution,
         {?},
         \lam {s1} m => c-in-func ((inner-results m.1).4 m.2))
  | red, func (inr f) choosing => (lt-full-metavar {colored-env red}, \lam {s1} mvar => rewrite ++_nil (\case \elim s1, \elim mvar \with {
    | s1, idp => (func {env} (inr f) choosing)
  }), {?}, \lam {s1} m => result-term-has-other-color {?})
  | blue, func (inl f) choosing => {?}
  | blue, func (inr b) choosing => {?}

\func join-monochrome-terms {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                            (a b c : Term (colored-env color) context s meta-signature)
                            (a~>b : monochrome-reduction color a b)
                            (a~>c : monochrome-reduction color a c)
                            (conf : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin b c ((monochrome-reduction color)) \elim color
  | red => conf a b c a~>b a~>c
  | blue => conf a b c a~>b a~>c

\func decompose-along-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                                (color : Color)
                                (t : LinearTerm (colored-env {tc} color) context s)
                                (B : Term env context s meta-signature)
                                (subst : MetaSubstitution env nil (LinearMetasignatureT {colored-env color} t) meta-signature)
                                (A~>B : TopLevelColoredReduction color (MetaSubstitution.apply {env} (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t)) sublist-trivial subst) B)
  : \Sigma (u : Term (colored-env color) context s (LinearMetasignatureT {colored-env color} t))
           (MetaSubstitution.apply {env} (inject-monochrome-term color u) sublist-trivial subst = B)
           (monochrome-reduction color (LinearTerm.convert-to-term {colored-env color} t) u)
\elim color, t, B, A~>B
  | red, lt-func f choosing, func f1 choosing1, rewrite-with-parameter-f-colored p h step => {?}
  | blue, lt-func f choosing, func f1 choosing1, rewrite-with-parameter-f-colored p h step => {?}
  | red, lt-var index p, B, rewrite-with-rule-colored h step => {?} -- top level symbol must be func
  | blue, lt-var index p, B, rewrite-with-rule-colored h step => {?} -- same as above
  | red, lt-metavar params choosing, B, A~>B => {?} -- show that substitute is a param, then go down
  | blue, lt-metavar params choosing, B, A~>B => {?}
  | red, lt-full-metavar, B, A~>B => {?} -- deep diving in colors
  | blue, lt-full-metavar, B, A~>B => {?}
  | color, lt-func f choosing, B, rewrite-with-rule-colored h (((rule : LinearRewriteRule),large-metasubst,l[inner-ms]=injt,r[inner-ms]=B)) =>
    \let | pattern => uninject-linear-pattern color rule.linear-pattern
         | linear-ms-eq : LinearMetasignature {colored-env color} pattern = LinearMetasignature {env} (rule.linear-pattern) => {?} -- univalencee
         | unlarge-metasubst => transport (\lam (x : MetaSignature (Sort {env})) => MetaSubstitution env context x meta-signature) (inv linear-ms-eq) large-metasubst
         | modified-eq : MetaSubstitution.apply {env}
             (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} pattern)) sublist-trivial) SubList.identity unlarge-metasubst
           = MetaSubstitution.apply {env} (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} (lt-func f choosing))) sublist-trivial subst
         => {?} *> l[inner-ms]=injt -- a bit technical
         | (middle-subst, substitution-equality, l-eq) => decompose-metasubstitution color sublist-trivial SubList.identity idp pattern (LinearTerm.convert-to-term {colored-env color} (lt-func f choosing)) unlarge-metasubst subst modified-eq
         | monochrome-r => transport (Term (colored-env color) nil s) (inv linear-ms-eq) (uninject-term color rule.r)
         | term-u => MetaSubstitution.apply {colored-env color} (weakening {colored-env color} monochrome-r sublist-trivial) SubList.identity middle-subst
         | coh => coherent-application {env} (inv linear-ms-eq) large-metasubst rule.r
         | colored-coherence => colored-metacomposition color middle-subst subst unlarge-metasubst substitution-equality SubList.identity (weakening {colored-env color} monochrome-r sublist-trivial)
    \in (term-u, (inv colored-coherence) *> (pmap (MetaSubstitution.apply {env} __ SubList.identity unlarge-metasubst) {?}) *> (inv coh) *> r[inner-ms]=B, produce-monochrome-reduction color pattern monochrome-r middle-subst (LinearTerm.convert-to-term {colored-env color} (lt-func f choosing)) term-u l-eq idp)

\func coherent-application {env : Environment} {context  : List Sort} {inner-meta-signature meta-signature inner-meta-signature' : MetaSignature Sort}
                           (metasig-eq : inner-meta-signature = inner-meta-signature')
                           (subst : MetaSubstitution env context inner-meta-signature meta-signature)
                           {s : Sort}
                           (T : Term env nil s inner-meta-signature)
  : MetaSubstitution.apply (weakening T sublist-trivial) SubList.identity subst = MetaSubstitution.apply {_} {_} {_} {_} {inner-meta-signature'} (weakening (rewriteI metasig-eq T) sublist-trivial) SubList.identity (rewriteI metasig-eq subst) \elim inner-meta-signature, metasig-eq
  | metasig, idp => idp

\func produce-monochrome-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                                   (pattern : LinearPattern (colored-env color) nil s)
                                   (rule-r : Term (colored-env color) nil s (LinearMetasignature {colored-env color} pattern))
                                   (subst : MetaSubstitution (colored-env color) context (LinearMetasignature {colored-env color} pattern) meta-signature)
                                   (l r : Term (colored-env color) context s meta-signature)
                                   (l-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} pattern) sublist-trivial) SubList.identity subst = l)
                                   (r-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} rule-r sublist-trivial) SubList.identity subst = r)
  : monochrome-reduction color l r \elim color
  | red => rewrite-with-rule (\new RewriteStep {
    | rule => \new LinearRewriteRule {
      | linear-pattern => pattern
      | r => rule-r
      | l-is-func => {?} -- easy
    }
    | substitution => subst
    | left-coherence => l-eq
    | right-coherence => r-eq
  }) {?} -- easy
  | blue => {?} -- same as above

\func uninject-linear-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                              (l : LinearPattern env context s)
  : LinearPattern (colored-env color) context s \elim color, l
  | red, lp-func (inl f) choosing => lp-func f (\lam index => uninject-linear-pattern red (choosing index))
  | blue, lp-func (inr f) choosing => lp-func f (\lam index => uninject-linear-pattern blue (choosing index))
  | color, lp-metavar => lp-metavar {colored-env color}
  | red, lp-func (inr b) choosing => {?}
  | blue, lp-func (inl a) choosing => {?}

\func inject-linear-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                            (l : LinearPattern (colored-env color) context s) : LinearPattern env context s => {?}

\func inject-linear-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                         (l : LinearTerm (colored-env color) context s) : LinearTerm env context s => {?}

\func uninject-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                    (t : Term env context s meta-signature)
  : Term (colored-env color) context s meta-signature => {?}

\func colored-metacomposition {tc : TheoremContext} {global-context : List Sort'} {ms-a ms-b ms-c : MetaSignature Sort'}
                              (color : Color)
                              (subst-a : MetaSubstitution (colored-env color) global-context ms-a ms-b)
                              (subst-b : MetaSubstitution env nil ms-b ms-c)
                              (subst-c : MetaSubstitution env global-context ms-a ms-c)
                              (eq : \Pi {s : Sort'} (m : ms-a.metaname s) -> subst-c m = MetaSubstitution.apply {env} (inject-monochrome-term color (subst-a m)) (sublist-trivial) subst-b)
                              {context : List Sort'} {s : Sort'} (sublist : SubList global-context context) (t : Term (colored-env color) context s ms-a)
  : MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term color (MetaSubstitution.apply {colored-env color} t sublist subst-a)) sublist-trivial subst-b \elim color, t
  | red, var index p => idp
  | red, metavar m choosing => {?}
  | red, func f choosing => {?}
  | blue, var index p => {?}
  | blue, metavar m choosing => {?}
  | blue, func f choosing => {?}

\func metacomposition {env : Environment} {global-context : List Sort} {ms-a ms-b ms-c : MetaSignature Sort}
                      (subst-a : MetaSubstitution env global-context ms-a ms-b)
                      (subst-b : MetaSubstitution env global-context ms-b ms-c)
                      (subst-c : MetaSubstitution env global-context ms-a ms-c)
                      (eq : \Pi {s : Sort} (m : ms-a.metaname s) ->
                          subst-c m = MetaSubstitution.apply (subst-a m) (SubList.extend-right-single-left SubList.identity) subst-b)
                      {context : List Sort} {s : Sort} (sublist : SubList global-context context) (t : Term env context s ms-a)
  : MetaSubstitution.apply t sublist subst-c = MetaSubstitution.apply (MetaSubstitution.apply t sublist subst-a) sublist subst-b \elim t
  | var index p => idp
  | metavar m choosing =>
    \let inner : (\lam i => MetaSubstitution.apply (choosing i) sublist subst-c) = (\lam i => MetaSubstitution.apply (MetaSubstitution.apply (choosing i) sublist subst-a) sublist subst-b) => ext (\lam i => metacomposition subst-a subst-b subst-c eq sublist (choosing i))
    \in rewrite (eq m) (inv (rewrite inner (meta-ext.commutation sublist subst-b (\lam i => MetaSubstitution.apply (choosing i) sublist subst-a) (subst-a m))))
  | func f choosing => pmap (func f) (ext (\lam index => metacomposition subst-a subst-b subst-c eq (SubList.extend-right-single-left sublist) (choosing index)))

\func meta-ext {env : Environment} {global-context context : List Sort} {ms-a ms-b ms-c : MetaSignature Sort}
               (subst-a : MetaSubstitution env global-context ms-a ms-b)
               (subst-b : MetaSubstitution env global-context ms-b ms-c)
               (sublist : SubList global-context context)
               {s : Sort} (T : Term env context s ms-a)
  : MetaSubstitution.apply
    (MetaSubstitution.apply T sublist subst-a)
    sublist subst-b
  = MetaSubstitution.apply T sublist
        (\lam m => MetaSubstitution.apply (subst-a m) (SubList.extend-right-single-left SubList.identity) subst-b)
\elim T
  | var index p => idp
  | metavar m choosing =>
    \let | inner : (\lam i => MetaSubstitution.apply (MetaSubstitution.apply (choosing i) sublist subst-a) sublist subst-b) = (\lam i => MetaSubstitution.apply (choosing i) sublist (\lam m => MetaSubstitution.apply (subst-a m) (SubList.extend-right-single-left SubList.identity) subst-b))=> ext (\lam i => meta-ext subst-a subst-b sublist (choosing i))
    \in rewriteI inner (commutation sublist subst-b (\lam i => MetaSubstitution.apply (choosing i) sublist subst-a) (subst-a m))
  | func f choosing => pmap (func f) (ext (\lam index => meta-ext subst-a subst-b (SubList.extend-right-single-left sublist) (choosing index)))
  \where {
    \func commutation {env : Environment} {global-context inner-context context : List Sort} {s : Sort} {ms-a ms-b : MetaSignature Sort}
                      (sublist : SubList global-context context)
                      (metasubst : MetaSubstitution env global-context ms-a ms-b)
                      (subst : Substitution inner-context context ms-a)
                      (T : Term env (inner-context ++ global-context) s ms-a)
      : MetaSubstitution.apply (Substitution.apply T (extend-substitution-right sublist subst)) sublist metasubst =
    Substitution.apply (MetaSubstitution.apply T (SubList.extend-right-single-left SubList.identity) metasubst) (extend-substitution-right sublist (\lam i => MetaSubstitution.apply (subst i) sublist metasubst)) \elim T
      | var index p => \case \elim s, \elim p \with {
        | s, idp => {?}
      }
      | metavar m choosing => {?}
      | func f choosing => pmap (func f) (ext (\lam index => {?}))
  }

\func decompose-metasubstitution
  {tc : TheoremContext} {pattern-context context core-context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
  (color : Color)
  (sublist : SubList pattern-context context)
  (sublist-core : SubList core-context context)
  (context-eqs : pattern-context ++ core-context = context)
  (l : LinearPattern (colored-env color) pattern-context s)
  (t : Term (colored-env color) context s inner-meta-signature)
  (big-substitution : MetaSubstitution env core-context (LinearMetasignature {colored-env color} l) meta-signature)
  (middle-substitution : MetaSubstitution env nil inner-meta-signature meta-signature)
  (eq :
  MetaSubstitution.apply {env}
      (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} l)) sublist)
      sublist-core big-substitution =
  MetaSubstitution.apply {env}
      (inject-monochrome-term color t)
      sublist-trivial
      middle-substitution)
  : \Sigma (inner-substitution : MetaSubstitution (colored-env color) core-context (LinearMetasignature {colored-env color} l) inner-meta-signature)
           (\Pi {s : Sort'} (m : metaname {LinearMetasignature {colored-env color} l} s) ->
               big-substitution m = MetaSubstitution.apply {env} (inject-monochrome-term color (inner-substitution m)) sublist-trivial middle-substitution)
           (MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} l) sublist) sublist-core inner-substitution = t) \elim color, l, t, eq
  | red, lp-func f choosing, metavar m choosing1, eq => {?} -- impossible by some outer lemma
  | red, lp-func f choosing, func f1 choosing1, eq =>
    \let | f-eq : f = f1 => {?}
    \in \case \elim f, \elim f-eq, \elim choosing, \elim big-substitution, \elim eq \with {
      | f, idp, choosing, big-substitution, eq =>
        \let | args-eq : (\lam i => MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (LinearPattern.upgrade-metavariables-p {envL}
            (\lam i => LinearMetasignature {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing i))))
            (SubList.extend-left sublist)) (SubList.extend-right-single-left sublist-core) big-substitution) = (\lam i => MetaSubstitution.apply {env}
            (Injections.inject-term-left envL envR (choosing1 i)) (SubList.extend-right-single-left sublist-trivial)
            middle-substitution) => {?}
             | inductive i => decompose-metasubstitution red
                 (SubList.extend-left sublist)
                 (SubList.extend-right-single-left sublist-core)
                 (rewrite ++-assoc (pmap ((domain f1 Data.List.!! i).1 ++ __) context-eqs))
                 (choosing i)
                 (choosing1 i)
                 (\lam m => big-substitution (i, m)) middle-substitution ({?} *> (pmap (__ i) args-eq) *> {?})
        \in (\lam {s1} mvar => (inductive mvar.1).1 mvar.2, \lam {s1} m => (inductive m.1).2 m.2, pmap (func {envL} f1) (ext (\lam index => {?}))) -- technical lemma about wrapping linear signature
    }
  | red, lp-metavar, t, eq => (\lam {s1} mvar => transport2 (\lam sort ctx => Term envL ctx sort inner-meta-signature) mvar (inv context-eqs) t, {?}, {?})
  -- symmetrical
  | blue, lp-func f choosing, metavar m choosing1, eq => {?}
  | blue, lp-func f choosing, func f1 choosing1, eq => {?}
  | blue, lp-metavar, t, eq => {?}

