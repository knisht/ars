\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.Linearity \hiding (linear-pattern)
\import TRS.List
\import TRS.Substitutions
\import TRS.Union
\import TRS.Utils
\open Confluence
\open Confluence.TheoremContext

\func join-tlcrs {tc : TheoremContext} {context : List Sort'} {s : Sort'}
                 (color : Color)
                 (A B C : PureTerm env context s)
                 (A~>B : TClosure (TopLevelColoredReduction color {EmptyMetasignature {env}} {context} {s}) A B)
                 (A~>C : TClosure (TopLevelColoredReduction color {EmptyMetasignature {env}} {context} {s}) A C)
                 (monochrome-confluence : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : \Sigma (X : PureTerm env context s) (TClosure (TopLevelColoredReduction color) B X) (TClosure (TopLevelColoredReduction color) C X) =>
  \let | (a, subst, eq-a, root-colors) => decompose-term color A
       | inner-ms => LinearMetasignatureT {colored-env color} a
       | (b, eq-b, a~>b) => unify-top.iterate-decomposition (LinearTerm.convert-to-term {colored-env color} a) subst B (rewrite unify-top.unwrap-injection eq-a) A~>B root-colors
       | (c, eq-c, a~>c) => unify-top.iterate-decomposition (LinearTerm.convert-to-term {colored-env color} a) subst C (rewrite unify-top.unwrap-injection eq-a) A~>C root-colors
       | join-b-c : StraightJoin b c (TClosure (monochrome-reduction color {_} {_} {inner-ms})) => join-monochrome-terms color {_} {_} {inner-ms} (LinearTerm.convert-to-term {colored-env color} a) b c a~>b a~>c monochrome-confluence
       | injected-reduct => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} join-b-c.common-reduct) SubList.sublist-trivial-skip subst
       | lifted-b~>d => TClosure.lift (\lam x => (MetaSubstitution.apply {env} (inject-monochrome-term color x) SubList.sublist-trivial-skip subst)) (\lam rel => lift-relation color subst rel) join-b-c.a common-reduct join-b-c.a~>cr
       | lifted-c~>d => TClosure.lift (\lam x => (MetaSubstitution.apply {env} (inject-monochrome-term color x) SubList.sublist-trivial-skip subst)) (\lam rel => lift-relation color subst rel) join-b-c.b common-reduct join-b-c.b~>cr
  \in (injected-reduct, transport (TClosure (TopLevelColoredReduction color) __ injected-reduct) eq-b lifted-b~>d, transport (TClosure (TopLevelColoredReduction color) __ injected-reduct) eq-c lifted-c~>d)

\func lift-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature outer-meta-signature : MetaSignature Sort'}
                    (color : Color)
                    (subst : MetaSubstitution env nil meta-signature outer-meta-signature)
                    {t u : Term (colored-env color) context s meta-signature}
                    (t~>u : monochrome-reduction color t u)
  : TopLevelColoredReduction color {outer-meta-signature} {context} {s}
    (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-skip subst)
    (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.sublist-trivial-skip subst) \elim t, u, t~>u
  | t, u, rewrite-with-rule ((rule,bsubst,l[bs]=injt,r[bs]=inju)) i => rewrite-with-rule-colored {?} {?} {?} {?} {?}
  | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f p r => {?}
  | metavar m-A choosing-A, metavar m-B choosing-B, rewrite-with-parameter-m p r => {?}

\func decompose-term {tc : TheoremContext} {context : List Sort'} {s : Sort'}
                     (color : Color)
                     (A : PureTerm env context s) :
  \Sigma (t : LinearTerm (colored-env {tc} color) context s)
         (subst : MetaSubstitution env nil (LinearMetasignatureT {colored-env color} t) (EmptyMetasignature {env}))
         (MetaSubstitution.apply {env} ((unify-top.convert-to-injected-term color t)) SubList.sublist-trivial-skip subst = A)
         (\Pi {s : Sort'} (m : metaname {LinearMetasignatureT {colored-env color} t} s) -> HasColoredRoot (Color.flip color) (subst m)) \elim color, A
  | color, var index p => (lt-var index p, \lam {s1} mvar => contradiction, \case \elim color \with {
    | red => idp
    | blue => idp
  }, \lam {s1} m => contradiction)
  | color, metavar m choosing => contradiction
  | red, func (inl f) choosing =>
    \let | inner-results i => decompose-term red (choosing i)
         | signature-producer i => LinearMetasignatureT {colored-env red} (inner-results i).1
         | unified-metasignature => ModularMetaSignature {env} signature-producer
         | unified-substitution : MetaSubstitution env nil unified-metasignature (EmptyMetasignature {env}) => \lam m => (inner-results m.1).2 m.2
    \in (lt-func f (\lam i => (inner-results i).1),
         unified-substitution,
         pmap (func {env} (inl f)) (ext (\lam index => (invariant-through-empty-subst {env} unified-substitution (SubList.extend-right-single SubList.sublist-trivial-skip) SubList.sublist-trivial-skip _) *>
         (inv (modular-commutation {env} (\lam i => LinearMetasignatureT {envL} (inner-results i).1) index SubList.sublist-trivial-skip (unify-top.convert-to-injected-term red ((inner-results index).1)) unified-substitution)) *>
         (inner-results index).3)),
         \lam {s1} m => ((inner-results m.1).4 m.2))
  | red, func (inr f) choosing =>
    (lt-full-metavar {colored-env red},
     \lam {s1} mvar => transport (PureTerm env context __) (inv mvar) (func (inr f) choosing),
     pmap (func {env} (inr f)) (ext (\lam index => rewrite (append-context-right-to-identity.ext' {env}) (rewrite (plain-identity-effect {env}) idp))),
     \lam {s1} m => \case \elim s1, \elim m \with {
       | s1, idp => blue-func-root
     })
  | blue, func (inl f) choosing => {?}
  | blue, func (inr b) choosing => {?}

\func join-monochrome-terms {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                            (a b c : Term (colored-env color) context s meta-signature)
                            (a~>b : TClosure (monochrome-reduction color) a b)
                            (a~>c : TClosure (monochrome-reduction color) a c)
                            (conf : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin b c (TClosure (monochrome-reduction color)) \elim color
  | red => conf a b c a~>b a~>c
  | blue => conf a b c a~>b a~>c

\func decompose-along-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
                                (color : Color)
                                (t : Term (colored-env {tc} color) context s inner-meta-signature)
                                (B : Term env context s meta-signature)
                                (subst : MetaSubstitution env nil (inner-meta-signature) meta-signature)
                                (root-colors : \Pi {s : Sort'} (m : inner-meta-signature.metaname s) -> HasColoredRoot (Color.flip color) (subst m))
                                (A~>B : TopLevelColoredReduction color {meta-signature} {context} {s} (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-skip subst) B)
  : \Sigma (u : Term (colored-env color) context s (inner-meta-signature))
           (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.sublist-trivial-skip subst = B)
           (monochrome-reduction color t u) \elim color, t, B, A~>B
  | red, func f choosing, func (inl f') choosing', rewrite-with-parameter-f-colored p _ step => {?}
  | red, func f choosing, B, rewrite-with-rule-colored hcr (rule : LinearRewriteRuleColored {tc} red s) big-subst l[bs]=injt r[bs]=B =>
    \let | (middle-subst, substitution-equality, l-eq) =>
      decompose-metasubstitution
          red rule.linear-pattern (transport (Term envL __ s inner-meta-signature) (inv ++_nil) (func {envL} f choosing)) big-subst subst
          (rewrite (unwrap-injection {_} {red} rule.linear-pattern) (rewrite (inv decompose-along-reduction.different-weakening.equate-sublists-3)
              (rewrite decompose-along-reduction.different-weakening.equate-sublists-2 (rewrite (transport-over-injection red)
                  (metasubst-over-transport-2 {env} ++_nil
                      (LinearPattern.convert-to-injected-term red rule.linear-pattern)
                      (func (inl f) (\lam i => inject-monochrome-term red (choosing i))) big-subst subst l[bs]=injt))))) root-colors
         | term-u => MetaSubstitution.apply {envL} (weakening {envL} rule.r SubList.sublist-trivial-skip) SubList.identity middle-subst
         | colored-coherence => colored-metacomposition red middle-subst subst big-subst substitution-equality SubList.identity (weakening {envL} rule.r SubList.sublist-trivial-skip)
    \in (term-u,
         inv (colored-coherence) *> (pmap (MetaSubstitution.apply {env} __ SubList.identity big-subst) (inv (injection-weakening-commutation red _ _))) *> r[bs]=B,
         produce-monochrome-reduction red rule.linear-pattern rule.r middle-subst (func f choosing) term-u
             (rewrite (different-weakening {envL}) (metasubst-over-transport {envL} ++_nil _ (func f choosing) middle-subst
                 ((rewrite (inv decompose-along-reduction.different-weakening.equate-sublists-2)
                     (pmap (\lam sl => MetaSubstitution.apply {envL} (weakening {envL} (LinearPattern.convert-to-term {envL} rule.linear-pattern) sl) (SubList.extend-right-single SubList.identity) middle-subst)
                         decompose-along-reduction.different-weakening.equate-sublists-3)) *> l-eq)))
             idp rule.l-is-func)
  | red, metavar m choosing, B, A~>B =>
    \let
      | other-root-color => root-colors m
      | root-color => TopLevelColoredReduction.extract-root-coloring A~>B
      | empty : Empty => eliminate-colors {tc} (blue) other-root-color root-color
    \in contradiction
  | red, var index p, B, A~>B => \let rc => TopLevelColoredReduction.extract-root-coloring A~>B \in \case \elim rc \with {}
  | red, func f choosing, func (inr s1) choosing1, rewrite-with-parameter-f-colored p p1 r => contradiction
  | blue, t, B, A~>B => {?}
  \where {
    \func eliminate-colors {tc : TheoremContext} (color : Color) {context context' : List Sort'} {s : Sort'} {msig : MetaSignature Sort'}
                           {T : Term env context s msig} {subst : Substitution {env} context context' msig} (hcr : HasColoredRoot color T)
                           (hcr' : HasColoredRoot (Color.flip color) (Substitution.apply {env} T subst))
      : Empty \elim color, T, hcr, hcr'
      | red, func (inl s1) choosing, red-func-root, ()
      | blue, var index p, (), hcr'
      | blue, metavar m choosing, (), hcr'
      | blue, func f choosing1, hcr, hcr' =>
        \let | eq => (inv (HasColoredRoot.reorganize red hcr')) *> HasColoredRoot.reorganize blue hcr
        \in contradiction

    \func different-weakening {env : Environment} {context : List Sort} {s : Sort} {ms : MetaSignature Sort}
                              (T : Term env nil s ms)
      : weakening T (SubList.sublist-trivial-skip {_} {context}) =
    transport (Term env __ s ms) (++_nil) (weakening T (SubList.extend-right-single SubList.identity)) \elim context
      | nil => idp
      | :: a context => lemma (++_nil) (sublist-skip SubList.sublist-trivial-skip) (sublist-skip SubList.sublist-trivial-skip) equate-sublists T
      \where {
        \func lemma  {env : Environment} {context context' : List Sort} {s : Sort} {ms : MetaSignature Sort}
                     (eq : context' = context) (sl : SubList nil context) (sl' : SubList nil context') (sl=sl' : sl = (transport (SubList nil) eq sl')) (T : Term env nil s ms) :
          weakening T sl = transport (Term env __ s ms) eq (weakening T sl') \elim context, eq, sl=sl'
          | nil, idp, idp => idp
          | :: a context, idp, idp => idp

        \func equate-sublists {A : \Type} {a : List A} : SubList.sublist-trivial-skip {_} {a} = transport (SubList nil) ++_nil (SubList.sublist-trivial-skip) \elim a
          | nil => idp
          | :: a a1 => (rewrite (equate-sublists {A} {a1}) (commute-skip ++_nil (SubList.sublist-trivial-skip)))
          \where {
            \func commute-skip {A : \Type} {x : A} {a b c : List A} (eq : a = b) (sl : SubList c a) : SubList.sublist-skip (transport (SubList c) eq sl) = transport (SubList c) (pmap (x ::) eq) (sublist-skip sl) \elim eq
              | idp => idp
          }

        \func equate-sublists-2 {A : \Type} {a : List A} : SubList.extend-right-single SubList.identity = transport (SubList a) (inv ++_nil) SubList.identity \elim a
          | nil => idp
          | :: a a1 => rewrite (equate-sublists-2 {_} {a1}) (commute-match _ _)
            \where {
              \func commute-match {A : \Type} {x : A} {a b c : List A} (eq : c = b) (sl : SubList a b):
                SubList.sublist-match idp (transport (SubList a) (inv eq) sl) = transport (SubList (x :: a)) (inv (pmap (x ::) eq)) (sublist-match idp sl) \elim eq
                | idp => idp
            }

        \func equate-sublists-3 {A : \Type} {a : List A} : SubList.sublist-trivial-skip {_} {a ++ nil} = SubList.extend-left-single sublist-trivial {a} \elim a
          | nil => idp
          | :: a a1 => pmap sublist-skip equate-sublists-3
      }

    \func metasubst-over-transport {env : Environment} {context context' : List Sort} {s : Sort} {ms ms' : MetaSignature Sort} (eq : context = context')
                                   (T : Term env context s ms) (S : Term env context' s ms') (msubst : MetaSubstitution env context' ms ms')
                                   (eq' : MetaSubstitution.apply T (transport (SubList context') (inv eq) SubList.identity) msubst = (transport (Term env __ s ms') (inv eq) S))
      : MetaSubstitution.apply (transport (Term env __ s ms) eq T) (SubList.identity) msubst = S \elim eq
      | idp => eq'

    \func transport-over-injection {tc : TheoremContext} {context context' : List Sort'} (color : Color) (eq : context = context') {s : Sort'} {ms : MetaSignature Sort'}
      (T : Term (colored-env color) context s ms) : inject-monochrome-term color (transport (Term (colored-env color) __ s ms) eq T) = transport (Term env __ s ms) eq (inject-monochrome-term color T) \elim color, eq
      | red, idp => idp
      | blue, idp => idp

    \func metasubst-over-transport-2 {env : Environment} {context context' : List Sort} {s : Sort} {ms ms' ms'' : MetaSignature Sort}
                                     (eq : context' = context)
                                     (T : Term env nil s ms) (S : Term env context s ms'')
                                     (msubst : MetaSubstitution env context ms ms')
                                     (msubst2 : MetaSubstitution env nil ms'' ms')
                                     (eq' : MetaSubstitution.apply (weakening T SubList.sublist-trivial-skip) SubList.identity msubst = MetaSubstitution.apply S SubList.sublist-trivial-skip msubst2)
      : MetaSubstitution.apply (weakening T SubList.sublist-trivial-skip) (transport (SubList context) (inv eq) SubList.identity) msubst = MetaSubstitution.apply (transport (Term env __ s ms'') (inv eq) S) SubList.sublist-trivial-skip msubst2 \elim eq
      | idp => eq'

    \func unwrap-injection {tc : TheoremContext} {color : Color} {context : List Sort'} {s : Sort'} (t : LinearPattern (colored-env color) context s) :
      inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} t) = LinearPattern.convert-to-injected-term color {context} {s} t \elim color, t
      | red, lp-func f choosing => pmap (func {env} (inl f))
          (ext (\lam index => rewriteI (unwrap-injection {_} {red} (choosing index)) (swap red (\lam i => LinearMetasignature {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing index)))))
      | blue, lp-func f choosing => pmap (func {env} (inr f))
          (ext (\lam index => rewriteI (unwrap-injection {_} {blue} (choosing index)) (swap blue (\lam i => LinearMetasignature {envR} (choosing i)) (LinearPattern.convert-to-term {envR} (choosing index)))))
      | red, lp-metavar => idp
      | blue, lp-metavar => idp
      \where {
        \func swap
          {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {n : Nat} {i : Fin n} (msigs : \Pi (i : Fin n) -> MetaSignature Sort')
          (t : Term (colored-env color) context s (msigs i)) :
          inject-monochrome-term color (LinearPattern.upgrade-metavariables-p {colored-env color} msigs t) =
          LinearPattern.upgrade-metavariables-p {env} msigs (inject-monochrome-term color t) \elim color, t
          | red, var index p => idp
          | red, metavar m choosing =>
            \let extt : (\lam i1 => Injections.inject-term-left tc.envL tc.envR (LinearPattern.upgrade-metavariables-p {envL} msigs (choosing i1))) = (\lam i1 => (LinearPattern.upgrade-metavariables-p {env} msigs (Injections.inject-term-left tc.envL tc.envR (choosing i1)))) => ext (\lam i => swap red msigs (choosing i))
            \in rewrite extt idp
          | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => (swap red msigs (choosing index))))
          | blue, var index p => idp
          | blue, metavar m choosing =>
            \let extt : (\lam i1 => Injections.inject-term-right tc.envL tc.envR (LinearPattern.upgrade-metavariables-p {envR} msigs (choosing i1))) = (\lam i1 => (LinearPattern.upgrade-metavariables-p {env} msigs (Injections.inject-term-right tc.envL tc.envR (choosing i1)))) => ext (\lam i => swap blue msigs (choosing i))
            \in rewrite extt idp
          | blue, func f choosing => pmap (func {env} (inr f)) (ext (\lam index => (swap blue msigs (choosing index))))
      }
  }

\func produce-monochrome-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                                   (pattern : LinearPattern (colored-env color) nil s)
                                   (rule-r : Term (colored-env color) nil s (LinearMetasignature {colored-env color} pattern))
                                   (subst : MetaSubstitution (colored-env color) context (LinearMetasignature {colored-env color} pattern) meta-signature)
                                   (l r : Term (colored-env color) context s meta-signature)
                                   (l-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} pattern) SubList.sublist-trivial-skip) SubList.identity subst = l)
                                   (r-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} rule-r SubList.sublist-trivial-skip) SubList.identity subst = r)
                                   (l-is-func : FunctionalRoot {colored-env color} (LinearPattern.convert-to-term {colored-env color} pattern))
  : monochrome-reduction color l r \elim color
  | red => rewrite-with-rule (\new RewriteStep {
    | rule => \new LinearRewriteRule {
      | linear-pattern => pattern
      | r => rule-r
      | l-is-func => l-is-func
    }
    | substitution => subst
    | left-coherence => l-eq
    | right-coherence => r-eq
  }) {?} -- easy
  | blue => {?} -- same as above

\func inject-linear-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                            (l : LinearPattern (colored-env color) context s) : LinearPattern env context s \elim color, l
  | red, lp-func f choosing => lp-func (inl f) (\lam i => inject-linear-pattern red (choosing i))
  | color, lp-metavar => lp-metavar {env}
  | blue, lp-func f choosing => lp-func (inr f) (\lam i => inject-linear-pattern blue (choosing i))
  \where {
    \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} (l : LinearPattern env context s) \elim l
      | lp-func f choosing =>
      lp-witness-f (color-of-root {tc} f = color)
                   (\Pi (i : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> InjectionWitness {tc} color (choosing i))
      | lp-metavar => lp-witness-fm
  }

\func inject-linear-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                         (l : LinearTerm (colored-env color) context s) : LinearTerm env context s \elim color, l
  | red, lt-func f choosing => lt-func (inl f) (\lam i => inject-linear-term red (choosing i))
  | blue, lt-func f choosing => lt-func (inr f) (\lam i => inject-linear-term blue (choosing i))
  | color, lt-full-metavar => lt-full-metavar {env}
  | color, lt-var index p => lt-var index p
  \where {
    \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} (l : LinearTerm env context s) \elim l
      | lt-func f choosing =>
      lt-witness-f (color-of-root {tc} f = color)
                   (\Pi (i : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> InjectionWitness {tc} color (choosing i))
      | lt-var _ _ => lt-witness-v
      | lt-full-metavar => lt-witness-fm

    \func generate-injection-witness {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                                     (l : LinearTerm (colored-env color) context s) : InjectionWitness color (inject-linear-term color l) \elim color, l
      | red, lt-func f choosing => lt-witness-f idp (\lam i => generate-injection-witness red (choosing i))
      | blue, lt-func f choosing => lt-witness-f idp (\lam i => generate-injection-witness blue (choosing i))
      | red, lt-full-metavar => lt-witness-fm
      | blue, lt-full-metavar => lt-witness-fm
      | red, lt-var index p => lt-witness-v
      | blue, lt-var index p => lt-witness-v

    \func extract-from-witness {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color) (f : env.FunctionalSymbol.symbol s)
                               (choosing :  \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> LinearTerm env (context ++ f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
                               (witness : InjectionWitness color (lt-func {env} f choosing))
      : \Sigma (\Pi (i : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> InjectionWitness {tc} color (choosing i)) (color-of-root f = color) \elim color, witness
      | color, lt-witness-f p _x => (_x, p)
  }

\func colored-metacomposition {tc : TheoremContext} {global-context : List Sort'} {ms-a ms-b ms-c : MetaSignature Sort'}
                              (color : Color)
                              (subst-a : MetaSubstitution (colored-env color) global-context ms-a ms-b)
                              (subst-b : MetaSubstitution env nil ms-b ms-c)
                              (subst-c : MetaSubstitution env global-context ms-a ms-c)
                              (eq : \Pi {s : Sort'} (m : ms-a.metaname s) -> subst-c m = MetaSubstitution.apply {env} (inject-monochrome-term color (subst-a m)) (SubList.sublist-trivial-skip) subst-b)
                              {context : List Sort'} {s : Sort'} (sublist : SubList global-context context) (t : Term (colored-env color) context s ms-a)
  : MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term color (MetaSubstitution.apply {colored-env color} t sublist subst-a)) SubList.sublist-trivial-skip subst-b \elim color, t
  | red, var index p => idp
  | red, metavar m choosing =>
    \let | inner i : MetaSubstitution.apply {env} (inject-monochrome-term red (choosing i)) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (choosing i) sublist subst-a)) SubList.sublist-trivial-skip subst-b => colored-metacomposition red subst-a subst-b subst-c eq sublist (choosing i)
         | inner-ext : (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (choosing i)) sublist subst-c) = (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (choosing i) sublist subst-a)) SubList.sublist-trivial-skip subst-b) => ext inner
    \in rewrite (eq m) (inv (rewrite inner-ext (rewrite twist-application (commutation sublist subst-b (\lam i => MetaSubstitution.apply {envL} (choosing i) sublist subst-a) (subst-a m)))))
  | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => (colored-metacomposition red subst-a subst-b subst-c eq (SubList.extend-right-single sublist) (choosing index)) *> invariant-through-empty-subst {env} subst-b SubList.sublist-trivial-skip (SubList.extend-right-single SubList.sublist-trivial-skip) _))
  | blue, t => {?} -- completely symmetrical
  \where {
    \func commutation {tc : TheoremContext} {global-context inner-context context : List Sort'} {s : Sort'} {ms-a ms-b : MetaSignature Sort'}
                      (sublist : SubList global-context context)
                      (metasubst : MetaSubstitution env nil ms-a ms-b)
                      (subst : Substitution {envL} inner-context context ms-a)
                      (T : Term envL (global-context ++ inner-context) s ms-a)
      :
      MetaSubstitution.apply {env}
          (Substitution.apply {env} (Injections.inject-term-left envL envR T) (\lam i => Injections.inject-term-left envL envR (extend-substitution-left {envL} sublist subst i)))
          SubList.sublist-trivial-skip
          metasubst =
      Substitution.apply {env}
          (MetaSubstitution.apply {env} (Injections.inject-term-left envL envR T) (SubList.sublist-trivial-skip) metasubst)
          (extend-substitution-left {env} sublist
              (\lam i => MetaSubstitution.apply {env} (Injections.inject-term-left envL envR (subst i)) SubList.sublist-trivial-skip metasubst)) \elim T
      | var index p => \case \elim s, \elim global-context, \elim sublist, \elim index, \elim p \with {
        | s, nil, sublist, index, idp => idp
        | s, :: a global-context, sublist, 0, idp => idp
        | s, :: a global-context, sublist, suc index, idp => {?}
      }
      | metavar m choosing => {?}
      | func f choosing => pmap (func {env} (inl f)) (ext (\lam index => {?}))

    \func twist-application
      {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {ms : MetaSignature Sort'}
      (t : Term envL context s ms) (subst : Substitution {envL} context context' ms)
      : Injections.inject-term-left envL envR (Substitution.apply {envL} t subst) = Substitution.apply {env} (Injections.inject-term-left envL envR t) (\lam i => Injections.inject-term-left envL envR (subst i)) \elim t
      | var index p => \case \elim s, \elim p \with {
        | s, idp => idp
      }
      | metavar m choosing => pmap (metavar {env} m) (ext (\lam index => twist-application (choosing index) subst))
      | func f choosing => pmap (func {env} (inl f)) (ext (\lam index => rewrite (push-append-context-right subst) (twist-application (choosing index) (append-context-right {envL} subst))))
      \where {
        \func push-append-context-right {tc : TheoremContext} {context context' additional-context : List Sort'} {ms : MetaSignature Sort'}
                                        (subst : Substitution {envL} context context' ms)
          : (append-context-right {env} {_} {_} {_} {additional-context} (\lam i => Injections.inject-term-left tc.envL tc.envR (subst i))) =
        (\lam i => Injections.inject-term-left tc.envL tc.envR (append-context-right {envL} subst i)) =>
          ext (push-append-context-right-ext subst)

        \func push-append-context-right-ext {tc : TheoremContext} {context context' additional-context : List Sort'} {ms : MetaSignature Sort'}
                                            (subst : Substitution {envL} context context' ms) (index : Fin (length (context ++ additional-context)))
          : (append-context-right {env} {_} {_} {_} {additional-context} (\lam i => Injections.inject-term-left tc.envL tc.envR (subst i))) index =
        (Injections.inject-term-left tc.envL tc.envR (append-context-right {envL} subst index)) \elim context, index
          | nil, index => idp
          | :: a context, 0 => injection-weakening-commutation red (SubList.extend-right-single SubList.identity) _
          | :: a additional-context, suc index => push-append-context-right-ext (\lam i => subst (suc i)) index
      }
  }

\func injection-weakening-commutation
  {tc : TheoremContext} (color : Color) {context context' : List Sort'} {ms : MetaSignature Sort'} {s : Sort'}
  (sublist : SubList context context')
  (t : Term (colored-env color) context s ms)
  : weakening {env} (inject-monochrome-term color t) sublist = inject-monochrome-term color (weakening {colored-env color} t sublist) \elim color, t
  | red, var index p => idp
  | red, metavar m choosing => pmap (metavar {env} m) (ext (\lam index => injection-weakening-commutation red sublist (choosing index)))
  | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => injection-weakening-commutation red (SubList.extend-right-both sublist) (choosing index)))
  | blue, var index p => idp
  | blue, metavar m choosing => pmap (metavar {env} m) (ext (\lam index => injection-weakening-commutation blue sublist (choosing index)))
  | blue, func f choosing => pmap (func {env} (inr f)) (ext (\lam index => injection-weakening-commutation blue (SubList.extend-right-both sublist) (choosing index)))

--\func transport-application {env : Environment}

--\data Depth

\func decompose-metasubstitution
  {tc : TheoremContext} {pattern-context core-context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
  (color : Color)
  (l : LinearPattern (colored-env color) pattern-context s)
  (t : Term (colored-env color) (core-context ++ pattern-context) s inner-meta-signature)
  (big-substitution : MetaSubstitution env core-context (LinearMetasignature {colored-env color} l) meta-signature)
  (middle-substitution : MetaSubstitution env nil inner-meta-signature meta-signature)
  (eq :
  MetaSubstitution.apply {env}
      (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} l)) (SubList.extend-left-single SubList.identity {core-context}))
      (SubList.extend-right-single SubList.identity) big-substitution =
  MetaSubstitution.apply {env}
      (inject-monochrome-term color t)
      SubList.sublist-trivial-skip
      middle-substitution)
  (root-colors : \Pi {s : Sort'} (m : inner-meta-signature.metaname s) -> HasColoredRoot (Color.flip color) (middle-substitution m))
  : \Sigma (inner-substitution : MetaSubstitution (colored-env color) core-context (LinearMetasignature {colored-env color} l) inner-meta-signature)
           (\Pi {s : Sort'} (m : metaname {LinearMetasignature {colored-env color} l} s) ->
               big-substitution m = MetaSubstitution.apply {env} (inject-monochrome-term color (inner-substitution m)) SubList.sublist-trivial-skip middle-substitution)
           (MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} l) (SubList.extend-left-single SubList.identity {core-context})) (SubList.extend-right-single SubList.identity) inner-substitution = t)
\elim color, l, t
  | red, lp-func f choosing, metavar m choosing1 =>
    \let | opposite-color-for-m => root-colors m
         | colored-root-for-f : HasColoredRoot red (func (inl f)
             (\lam i => MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left tc.envL tc.envR (LinearPattern.upgrade-metavariables-p {envL}
                 (\lam i => LinearMetasignature {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing i))))
                 (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)) => red-func-root
         | colored-root-for-m : HasColoredRoot red (Substitution.apply {env} (middle-substitution m) (extend-substitution-left {env} SubList.sublist-trivial-skip
             (\lam i => MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR (choosing1 i)) SubList.sublist-trivial-skip middle-substitution))) => rewriteI eq colored-root-for-f
         | empty => decompose-along-reduction.eliminate-colors blue opposite-color-for-m colored-root-for-m
    \in contradiction
  | red, lp-func f choosing, func f1 choosing1 =>
    \let | f-eq : f = f1 => pmap (unor f) (pmap (unfunc {env} (inl f)) eq)
    \in inductive-step f f1 f-eq choosing choosing1 big-substitution middle-substitution root-colors eq
  | red, lp-metavar, t =>
    (\lam {s1} mvar => transport (\lam sort => Term envL (core-context ++ pattern-context) sort inner-meta-signature) mvar t,
     \lam {s1} m => \case \elim s, \elim t, \elim big-substitution, \elim eq, \elim m \with {
       | s, t, big-substitution, eq, idp =>
         (rewrite {1} (inv (plain-identity-effect {env} (big-substitution idp))) (pmap (Substitution.apply {env} (big-substitution idp)) (inv (weakening-extension-ext {env})))) *> eq
     },
     (unfold transport (transport (\lam sbst => Substitution.apply {envL} t sbst = t) (inv (weakening-extension-ext {envL} {core-context} {pattern-context} {inner-meta-signature})) (plain-identity-effect {envL} _))))
  | blue, _, _ => {?}
  \where {
    \func unfunc-eq {env : Environment} {context : List Sort} {s : Sort} {ms : MetaSignature Sort} (f f' : FunctionalSymbol.symbol s)
                    (choosing : \Pi (index : Fin (length (domain f))) -> Term env (context ++ (f FunctionalSignature.!!param index)) (f FunctionalSignature.!!sort index) ms)
                    (choosing' : \Pi (index : Fin (length (domain f'))) -> Term env (context ++ (f' FunctionalSignature.!!param index)) (f' FunctionalSignature.!!sort index) ms)
                    (eq : (func f choosing) = (func f' choosing')) : f = f' => pmap (unfunc f) eq

    \func unfunc {env : Environment} {context : List Sort} {s : Sort} {ms : MetaSignature Sort} (f : FunctionalSymbol.symbol s)
                 (T : Term env context s ms) : FunctionalSymbol.symbol s \elim T
      | var index p => f
      | metavar m choosing => f
      | func f1 choosing => f1

    --    \func unchoosing {env : Environment} {context : List Sort} {s : Sort} {ms : MetaSignature Sort} {f : FunctionalSymbol.symbol s}
    --                     (choosing : )
    --                     (T : Term env context s ms)

    \func inductive-step
      {tc : TheoremContext} {pattern-context core-context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
      (f : symbol {FunctionalSymbol {envL}} s)
      (f1 : symbol {FunctionalSymbol {envL}} s)
      (eq : f = f1)
      (choosing :
      \Pi (index : Fin (length (domain {FunctionalSymbol {envL}} f))) ->
          LinearPattern (envL) (pattern-context ++ f FunctionalSignature.!!param index) (f FunctionalSignature.!!sort index))
      (choosing1 :
      \Pi (index : Fin (length (domain {FunctionalSymbol {envL}} f1))) ->
          Term envL ((core-context ++ pattern-context) ++ f1 FunctionalSignature.!!param index) (f1 FunctionalSignature.!!sort index)
              inner-meta-signature)
      (big-substitution : MetaSubstitution env core-context (LinearMetasignature {envL} (lp-func f choosing)) meta-signature)
      (middle-substitution : MetaSubstitution env nil inner-meta-signature meta-signature)
      (root-colors : \Pi {s : Sort'} (m : inner-meta-signature.metaname s) -> HasColoredRoot (blue) (middle-substitution m))
      (eq' : MetaSubstitution.apply {env}
          (weakening {env} (inject-monochrome-term red (LinearPattern.convert-to-term {colored-env red} (lp-func {envL} f choosing))) (SubList.extend-left-single SubList.identity {core-context}))
          (SubList.extend-right-single SubList.identity) big-substitution =
      MetaSubstitution.apply {env}
          (inject-monochrome-term red (func {envL} f1 choosing1))
          SubList.sublist-trivial-skip
          middle-substitution):
      \Sigma (inner-substitution : MetaSubstitution (envL) core-context (LinearMetasignature {envL} (lp-func f choosing)) inner-meta-signature)
             (\Pi {s : Sort'} (m : metaname {LinearMetasignature {envL} (lp-func f choosing)} s) ->
                 big-substitution m = MetaSubstitution.apply {env} (inject-monochrome-term red (inner-substitution m)) SubList.sublist-trivial-skip middle-substitution)
             (MetaSubstitution.apply {envL} (weakening {envL} (LinearPattern.convert-to-term {envL} (lp-func f choosing)) (SubList.extend-left-single SubList.identity {core-context})) (SubList.extend-right-single SubList.identity) inner-substitution = (func f1 choosing1))
    \elim eq
      | idp =>
        \let | args-eq i : ( MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (LinearPattern.upgrade-metavariables-p {envL}
            (\lam i => LinearMetasignature {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing i))))
            (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)
          =
        (MetaSubstitution.apply {env}
            (Injections.inject-term-left envL envR (choosing1 i)) (SubList.extend-left-single SubList.sublist-trivial-skip)
            middle-substitution) => ({?})
             | inductive i => decompose-metasubstitution red
                 (choosing i)
                 (transport (Term envL __ _ inner-meta-signature) (++-assoc {_} {core-context} {pattern-context} {f1 FunctionalSignature.!!param i}) (choosing1 i))
                 (\lam m => big-substitution (i, m))
                 middle-substitution
                 ({?})
                 root-colors

        \in (\lam {s1} mvar => (inductive mvar.1).1 mvar.2,
             \lam {s1} m => (inductive m.1).2 m.2,
             pmap (func {envL} f1) (ext (\lam index =>
                 \let ind => (inductive index).3
                 \in rewrite (inv (alternate-subst.apply-modularity {envL}
                     (\lam i => LinearMetasignature {envL} (choosing i))
                     (\lam i => (inductive i).1)
                     (SubList.extend-right-single (SubList.extend-right-single SubList.identity))
                     (SubList.extend-right-both (SubList.extend-left-single SubList.identity))
                     (LinearPattern.convert-to-term {envL} (choosing index))))
                     (rewrite (weakening-over-double-extend)
                         (rewrite weakening-over-double-extend-2
                             (expand-substitution-3 {envL} _ _ _ _ _ _ ind))))))
  }

\func weakening-extension-ext {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
  :
  extend-substitution-left {_} {left-context} {right-context} {_} {meta-signature} (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) = plain-identity {_} {_} {meta-signature} =>
  ext (weakening-extension)

\func weakening-extension {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                          (i : Fin (length (left-context ++ right-context)))
  : extend-substitution-left (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i = plain-identity {_} {_} {meta-signature} i =>
  partial-fin-induction {Sort}
      {left-context}
      {right-context}
      (\lam i =>
          extend-substitution-left (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i
            =
          plain-identity {_} {_} {meta-signature} i)
      (\lam i1 => \let | q => extend-substitution-left.for-left-context {env} {left-context} {right-context} {left-context ++ right-context} {meta-signature} (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i1
                       | (right-eq, big-eq) => weakening.recalculate-index-over-right-extension' {Sort} {left-context} {right-context} i1
                       | q' : right-eq = (expand-fin-eq i1) => Path.inProp _ _
                  \in q *> (rewriteI q' (pmap to-var big-eq)))
      (\lam i1 => \let | q => extend-substitution-left.for-right-context {env} {left-context} {right-context} {left-context ++ right-context} {meta-signature} (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i1
                       | big-eq => weakening.recalculate-index-over-left-extension' {Sort} {left-context} {right-context} i1
                  \in q *> (rewrite (pmap to-var big-eq) (append-context-right-to-identity.lem2 {env} {left-context ++ right-context} {_} {_} {meta-signature} (expand-fin-late i1) (inv (expand-fin-eq-late i1)) idp (inv (expand-fin-eq-late i1)))))
      i

\func weakening-over-double-extend {A : \Type} {context-a context-b context-c : List A}
  : (SubList.extend-right-both (SubList.extend-left-single (SubList.identity {_} {context-b}) {context-a}) {context-c}) = transport (SubList (context-b ++ context-c)) (inv ++-assoc) (SubList.extend-left-single SubList.identity) \elim context-a, context-b, context-c
  | nil, nil, context-c => idp
  | nil, :: a context-b, context-c => rewrite (weakening-over-double-extend {_} {nil} {context-b} {_}) (idp)
  | :: a context-a, nil, :: a1 context-c => rewrite (weakening-over-double-extend {_} {_} {nil}) (rewrite (decompose-along-reduction.different-weakening.equate-sublists.commute-skip {A} {a} _ (SubList.extend-left-single (sublist-match idp SubList.identity))) (transport-lemma (SubList (a1 :: nil ++ context-c)) (:: a) _ _))
  | :: a context-a, nil, nil => rewrite (weakening-over-double-extend {_} {_} {nil}) (rewrite (decompose-along-reduction.different-weakening.equate-sublists.commute-skip {A} {a} _ (SubList.extend-left-single (sublist-trivial))) (transport-lemma (SubList (nil)) (:: a) _ _))
  | :: a context-a, :: a1 context-b, context-c => rewrite (weakening-over-double-extend {_} {_} {:: a1 context-b}) (rewrite (decompose-along-reduction.different-weakening.equate-sublists.commute-skip {A} {a} _ (SubList.extend-left-single (sublist-match idp SubList.identity))) (transport-lemma (SubList (a1 :: context-b ++ context-c)) (:: a) _ _))
 \where {
   \func transport-lemma {A B : \Type} (C : B -> \Type) (map : A -> B) {a a' : A} (eq : a = a') (x : C (map a')) : transport C (pmap map (inv eq)) x = transport C (inv (path (\lam i => map (eq @ i)))) x \elim eq
     | idp => idp
 }


\func weakening-over-double-extend-2 {A : \Type} {context-a context-b context-c : List A}
  : (SubList.extend-right-single (SubList.extend-right-single (SubList.identity {_} {context-a}) {context-b}) {context-c}) = transport (SubList (context-a)) (inv ++-assoc) (SubList.extend-right-single SubList.identity) \elim context-a, context-b, context-c
  | nil, context-b, context-c => extension-lemma
  | :: a context-a, context-b, context-c => rewrite (weakening-over-double-extend-2 {_} {context-a}) (rewrite decompose-along-reduction.different-weakening.equate-sublists-2.commute-match idp)
  \where {
    \func extension-lemma {A : \Type} {context-a context-b : List A}
          : SubList.extend-right-single SubList.sublist-trivial-skip {context-b} = SubList.sublist-trivial-skip {_} {context-a ++ context-b} \elim context-a, context-b
      | nil, context-b => idp
      | :: a context-a,  context-b => pmap sublist-skip extension-lemma
  }


\func expand-substitution-3 {env : Environment} {term-context ms-context big-context big-context' : List Sort} {s : Sort} {ms ms' : MetaSignature Sort}
                            (T : Term env term-context s ms)
                            (msubst : MetaSubstitution env ms-context ms ms')
                            (sublist : SubList term-context big-context)
                            (sublist' : SubList ms-context big-context)
                            (S : Term env big-context' s ms')
                            (eq : big-context' = big-context)
                            (target : MetaSubstitution.apply (weakening T sublist) sublist' msubst = transport (Term env __ s ms') eq S)
                            : MetaSubstitution.apply (weakening T (transport (SubList term-context) (inv eq) sublist)) (transport (SubList ms-context) (inv eq) sublist') msubst = S \elim eq
  | idp => target
