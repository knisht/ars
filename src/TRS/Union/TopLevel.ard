\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set \hiding (#)
\import TRS.HRS
\import TRS.Linearity \hiding (linear-pattern)
\import TRS.List
\import TRS.Substitutions
\import TRS.Union
\import TRS.Union.Embedding
\import TRS.Utils
\open Confluence
\open Confluence.TheoremContext

\func join-tlcrs {tc : TheoremContext} {context : List Sort'} {s : Sort'}
                 (color : Color)
                 (A B C : PureTerm env context s)
                 (A~>B : TClosure (TopLevelColoredReduction color {EmptyMetaContext {env}} {context} {s}) A B)
                 (A~>C : TClosure (TopLevelColoredReduction color {EmptyMetaContext {env}} {context} {s}) A C)
                 (monochrome-confluence : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
                 (all-rules-are-linear : LinearDump)
  : \Sigma (X : PureTerm env context s) (TClosure (TopLevelColoredReduction color) B X) (TClosure (TopLevelColoredReduction color) C X) =>
  \let | (a, subst, eq-a, root-colors) => decompose-term color A
       | inner-ms => LinearMetaContextT {colored-env color} a
       | (b, eq-b, a~>b) => unify-top.iterate-decomposition (LinearTerm.convert-to-term {colored-env color} a) subst B (rewrite unify-top.unwrap-injection eq-a) A~>B root-colors
       | (c, eq-c, a~>c) => unify-top.iterate-decomposition (LinearTerm.convert-to-term {colored-env color} a) subst C (rewrite unify-top.unwrap-injection eq-a) A~>C root-colors
       | join-b-c : StraightJoin b c (TClosure (\lam x y => \Sigma (rd : monochrome-reduction color x y) (FunctionalWitness {colored-env color} {colored-set-of-rules color} rd))) => join-monochrome-terms color {_} {_} {inner-ms} (LinearTerm.convert-to-term {colored-env color} a) b c (TClosure.lift (\lam t => t) (\lam rel => rel.1) _ _ a~>b) (TClosure.lift (\lam t => t) (\lam rel => rel.1) _ _ a~>c) monochrome-confluence
       | injected-reduct => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} join-b-c.common-reduct) SubList.sublist-trivial-skip subst
       | lifted-b~>d => TClosure.lift (\lam x => (MetaSubstitution.apply {env} (inject-monochrome-term color x) SubList.sublist-trivial-skip subst)) (\lam rel => lift-relation color subst rel.1 rel.2 all-rules-are-linear) join-b-c.a common-reduct join-b-c.a~>cr
       | lifted-c~>d => TClosure.lift (\lam x => (MetaSubstitution.apply {env} (inject-monochrome-term color x) SubList.sublist-trivial-skip subst)) (\lam rel => lift-relation color subst rel.1 rel.2 all-rules-are-linear) join-b-c.b common-reduct join-b-c.b~>cr
  \in (injected-reduct, transport (TClosure (TopLevelColoredReduction color) __ injected-reduct) eq-b lifted-b~>d, transport (TClosure (TopLevelColoredReduction color) __ injected-reduct) eq-c lifted-c~>d)

\func lift-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                    (color : Color)
                    (subst : MetaSubstitution env nil mc (EmptyMetaContext {env}))
                    {t u : Term (colored-env color) context s mc}
                    (t~>u : monochrome-reduction color t u)
                    (fw : FunctionalWitness {colored-env color} {colored-set-of-rules color} t~>u)
                    (all-rules-are-linear : LinearDump)
  : TopLevelColoredReduction color {_} {context} {s}
    (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-skip subst)
    (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.sublist-trivial-skip subst) \elim color, t, u, t~>u, fw
  | red, t, u, rewrite-with-rule idx sort-eqs msubst msubst[l]=t msubst[r]=u, fw =>
    \let | (lp, meq, lcoh) => all-rules-are-linear (inl idx)
         | (uninjected-r, inject-uninj) => break-down-rule (inl idx)
         | (new-lp, new-r, composed, new-lcoh) => untransport lp meq sort-eqs msubst subst _ _ t u msubst[l]=t msubst[r]=u lcoh
    \in rewrite-with-rule-colored {?} new-lp new-r {?} composed new-lcoh {?} {?}
  | blue, t, u, rewrite-with-rule idx sort-eqs msubst msubst[l]=t msubst[r]=u, fw =>
    \let (lp, meq, lcoh) => all-rules-are-linear (inr idx)
    \in rewrite-with-rule-colored {?} {?} {?} {?} {?} {?} {?} {?}
  | red, func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f idp index rd eq, param-rewriting fw =>
    rewrite-with-parameter-f-colored idp idp index
        (rewrite (decompose-along-reduction.any-nil-sublist-equate (SubList.extend-right-single SubList.sublist-trivial-skip) (SubList.sublist-trivial-skip)) (transport (\lam sl => TopLevelColoredReduction red (MetaSubstitution.apply {env}
            (Injections.inject-term-left envL envR (choosing-A index)) SubList.sublist-trivial-skip subst)
            ((MetaSubstitution.apply {env}
                (Injections.inject-term-left envL envR (choosing-B index)) (sl)
                subst))) (decompose-along-reduction.any-nil-sublist-equate (SubList.sublist-trivial-skip) (SubList.extend-right-single SubList.sublist-trivial-skip) ) (lift-relation red subst rd fw all-rules-are-linear)))
        (\lam j _x => rewrite (eq j _x) idp)
  | blue, func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f p i rd eq, fw => {?}
  | red, metavar m-A choosing-A, metavar m-B choosing-B, rewrite-with-parameter-m idp i rd eq, ()
  | blue, metavar m-A choosing-A, metavar m-B choosing-B, rewrite-with-parameter-m p i rd eq, ()
  \where {
    \func untransport
      {tc : TheoremContext} {context : List Sort'} {s rule-s : Sort'} {mc mc' mc'' : MetaContext Sort'}
      (lp : LinearPattern envL nil rule-s)
      (meq : mc = LinearMetaContext {envL} lp)
      (sort-eqs : s = rule-s)
      (msubst : MetaSubstitution envL context mc mc')
      (outer-subst : MetaSubstitution env nil mc' mc'')
      (l r : Term envL nil rule-s mc)
      (t u : Term envL context s mc')
      (ms-leq : MetaSubstitution.apply {envL} (weakening {envL} l SubList.sublist-trivial-skip) SubList.identity msubst = transport (Term envL context __ mc') sort-eqs t)
      (ms-req : MetaSubstitution.apply {envL} (weakening {envL} r SubList.sublist-trivial-skip) SubList.identity msubst = transport (Term envL context __ mc') sort-eqs u)
      (lcoh : LinearPattern.convert-to-injected-term red lp = transport (Term env nil rule-s) meq (inject-monochrome-term red l))
      : \Sigma (new-lp : LinearPattern envL nil s)
               (new-r : Term envL nil s (LinearMetaContext {envL} new-lp))
               (composed : MetaSubstitution env context (LinearMetaContext {envL} new-lp) mc'')
               (new-lcoh : MetaSubstitution.apply {env}
                   (weakening {env} (LinearPattern.convert-to-injected-term red new-lp) SubList.sublist-trivial-skip) SubList.identity composed = MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR t) SubList.sublist-trivial-skip outer-subst)
    \elim meq, sort-eqs
      | idp, idp =>
        (lp,
         r,
         \lam {s1} mvar => MetaSubstitution.apply {env} (inject-monochrome-term red (msubst mvar)) SubList.sublist-trivial-skip outer-subst,
         rewrite lcoh (rewriteI ms-leq (unfold transport (rewrite (injection-weakening-commutation red) (rewrite (push-injection red) (metacommutation {env} (\lam m => Injections.inject-term-left envL envR (msubst m)) outer-subst  _ SubList.identity))))))

    \func push-injection
      {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {mc mc' : MetaContext Sort'} (color : Color)
      (msubst : MetaSubstitution (colored-env color) context' mc mc')
      (t : Term (colored-env color) context s mc)
      (sublist : SubList context' context)
      : inject-monochrome-term color (MetaSubstitution.apply {colored-env color} t sublist msubst) = MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist (\lam m => inject-monochrome-term color (msubst m)) =>
      {?}

    \func metacommutation {env : FSignature} {context context' : List Sort} {s : Sort} {mc mc' mc'' : MetaContext Sort}
                          (msubst : MetaSubstitution env context' mc mc')
                          (msubst2 : MetaSubstitution env nil mc' mc'')
                          (t : Term env context s mc)
                          (sublist : SubList context' context)
      :
      MetaSubstitution.apply t sublist (\lam m => MetaSubstitution.apply (msubst m) SubList.sublist-trivial-skip msubst2)
        =
      MetaSubstitution.apply (MetaSubstitution.apply t sublist msubst) SubList.sublist-trivial-skip msubst2 \elim t
      | var index p => idp
      | metavar m choosing =>
        \let inductive : (\lam i => MetaSubstitution.apply (choosing i) sublist
            (\lam {s : env.Sort} (m : mc.metaname s) => MetaSubstitution.apply (msubst m) SubList.sublist-trivial-skip msubst2)) = (\lam i => MetaSubstitution.apply (MetaSubstitution.apply (choosing i) sublist msubst) SubList.sublist-trivial-skip msubst2) => ext (\lam i => metacommutation msubst msubst2 (choosing i) sublist)
        \in rewrite inductive (rewrite (subst-extend-left-comm.ext' msubst2 sublist (\lam (i : Fin (length (mc.m-domain m))) => MetaSubstitution.apply (choosing i) sublist msubst)) (subst-metasubst-comm msubst2 (msubst m) _))
      | func f choosing => pmap (func f) (ext (\lam index => rewrite (decompose-along-reduction.any-nil-sublist-equate (SubList.extend-right-single SubList.sublist-trivial-skip) (SubList.sublist-trivial-skip)) (metacommutation msubst msubst2 (choosing index) (SubList.extend-right-single sublist))))

    \func subst-metasubst-comm
      {env : FSignature} {context context' : List Sort} {s : Sort} {mc' mc'' : MetaContext Sort}
      (msubst2 : MetaSubstitution env nil mc' mc'')
      (t : Term env (context') s mc')
      (subst : Substitution context' context mc')
      :
      Substitution.apply (MetaSubstitution.apply t SubList.sublist-trivial-skip msubst2) (\lam i => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip msubst2)
        =
      MetaSubstitution.apply (Substitution.apply t (subst)) SubList.sublist-trivial-skip msubst2 \elim t
      | var index idp => idp
      | metavar m choosing => \let inductive-ext : (\lam i => Substitution.apply (MetaSubstitution.apply (choosing i) SubList.sublist-trivial-skip msubst2) (\lam i => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip msubst2))
        =
      (\lam i => MetaSubstitution.apply (Substitution.apply (choosing i) (subst)) SubList.sublist-trivial-skip msubst2) => ext (\lam i => subst-metasubst-comm msubst2 (choosing i) subst) \in rewriteI inductive-ext (tlcr-over-substitution.commutation.subst-comm _ _ _)
      | func f choosing => pmap (func f) (ext (\lam index => rewrite (decompose-along-reduction.any-nil-sublist-equate (SubList.extend-right-single SubList.sublist-trivial-skip) SubList.sublist-trivial-skip) (rewrite (decompose-along-reduction.any-nil-sublist-equate (SubList.extend-right-single SubList.sublist-trivial-skip) SubList.sublist-trivial-skip) (rewriteI (subst-metasubst-comm msubst2 (choosing index) (append-context-right subst)) (pmap (Substitution.apply (MetaSubstitution.apply (choosing index) SubList.sublist-trivial-skip msubst2)) (ext (append-context-right-inside-metaapply subst msubst2)))))))

    \func append-context-right-inside-metaapply
      {env : FSignature} {context context' add-context : List Sort} {mc' mc'' : MetaContext Sort}
      (subst : Substitution context context' mc')
      (msubst : MetaSubstitution env nil mc' mc'')
      (index : Fin (length (context ++ add-context)))
      : append-context-right (\lam i => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip msubst) {add-context} index = MetaSubstitution.apply (append-context-right subst index) SubList.sublist-trivial-skip msubst =>
      partial-fin-induction
          (\lam fin => append-context-right (\lam i => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip msubst) {add-context} fin = MetaSubstitution.apply (append-context-right subst fin) SubList.sublist-trivial-skip msubst)
          (\lam fin => repeat {2} (rewrite append-context-right-begin) (untransport2 _ (subst fin) msubst _))
          (\lam fin => repeat {2} (rewrite append-context-right-end) idp)
          index
      \where {
        \func untransport2 {env : FSignature} {s s' : Sort} (eq : s = s') {mc mc' : MetaContext Sort} {context context' : List Sort}
                           (t : Term env context s mc)
                           (msubst : MetaSubstitution env nil mc mc')
                           (sublist : SubList context context')
          : weakening (transport (\lam (p0 : env.Sort) => Term env context p0 mc') eq
            (MetaSubstitution.apply t SubList.sublist-trivial-skip msubst)) sublist =
        MetaSubstitution.apply
            (weakening (transport (\lam (p0 : env.Sort) => Term env context p0 mc) eq t)
                (sublist)) SubList.sublist-trivial-skip msubst \elim eq, t
          | idp, var index p => idp
          | idp, metavar m choosing => \let inductive-ext : (\lam i => weakening ((MetaSubstitution.apply (choosing i) SubList.sublist-trivial-skip msubst)) sublist) =
              (\lam i => MetaSubstitution.apply
              (weakening (choosing i)
                  (sublist)) SubList.sublist-trivial-skip msubst) => ext (\lam i => untransport2 idp (choosing i) msubst sublist) \in unfold transport (rewriteI inductive-ext (rewrite weakening-as-substitution-eq (\let induced : (\lam (i : Fin (length (mc.m-domain m))) =>
              weakening (MetaSubstitution.apply (choosing i) SubList.sublist-trivial-skip msubst) sublist) = (\lam i => Substitution.apply (MetaSubstitution.apply (choosing i) SubList.sublist-trivial-skip msubst) (weakening-as-substitution sublist)) => ext (\lam i => rewrite weakening-as-substitution-eq idp) \in rewrite induced (tlcr-over-substitution.commutation.subst-comm _ _ _))))
          | idp, func f choosing => (pmap (func f) (ext (\lam index => rewrite (decompose-along-reduction.any-nil-sublist-equate (SubList.extend-right-single SubList.sublist-trivial-skip) SubList.sublist-trivial-skip) (rewrite (decompose-along-reduction.any-nil-sublist-equate (SubList.extend-right-single SubList.sublist-trivial-skip) SubList.sublist-trivial-skip) (untransport2 idp (choosing index) msubst (SubList.extend-right-both sublist))))))
      }

    \func subst-extend-left-comm {env : FSignature} {context context' add-context : List Sort} {mc' mc'' : MetaContext Sort}
                                 (msubst2 : MetaSubstitution env nil mc' mc'')
                                 (sublist : SubList context' context)
                                 (subst : Substitution add-context context mc')
                                 (index : Fin (length (context' ++ add-context)))
      : (extend-substitution-left
        sublist (\lam (i : Fin (length add-context)) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip msubst2)) index = (MetaSubstitution.apply (extend-substitution-left sublist subst index) SubList.sublist-trivial-skip msubst2) =>
      partial-fin-induction
          (\lam fin => (extend-substitution-left
              sublist (\lam (i : Fin (length add-context)) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip msubst2)) fin = (MetaSubstitution.apply (extend-substitution-left sublist subst fin) SubList.sublist-trivial-skip msubst2))
          (\lam fin => repeat {2} (rewrite (extend-substitution-left.for-left-context)) idp)
          (\lam fin => repeat {2} (rewrite (extend-substitution-left.for-right-context)) (untransport-2 _ (subst fin) msubst2))
          index
      \where {
        \func ext' {env : FSignature} {context context' add-context : List Sort} {mc' mc'' : MetaContext Sort}
                   (msubst2 : MetaSubstitution env nil mc' mc'')
                   (sublist : SubList context' context)
                   (subst : Substitution add-context context mc')
          : (extend-substitution-left
            sublist (\lam (i : Fin (length add-context)) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip msubst2)) = (\lam i => MetaSubstitution.apply (extend-substitution-left sublist subst i) SubList.sublist-trivial-skip msubst2) =>
          ext (subst-extend-left-comm msubst2 sublist subst)
      }

    \func untransport-2 {env : FSignature} {s s' : Sort} (eq : s = s') {mc mc' : MetaContext Sort} {context : List Sort}
                        (t : Term env context s mc)
                        (msubst : MetaSubstitution env nil mc mc'): transport (\lam (p0 : env.Sort) => Term env context p0 mc') (eq)
        (MetaSubstitution.apply (t) SubList.sublist-trivial-skip msubst) = MetaSubstitution.apply
                                                                               (transport (\lam (p0 : env.Sort) => Term env context p0 mc) (eq) (t))
                                                                               SubList.sublist-trivial-skip msubst \elim eq
      | idp => idp
  }

\func decompose-term {tc : TheoremContext} {context : List Sort'} {s : Sort'}
                     (color : Color)
                     (A : PureTerm env context s) :
  \Sigma (t : LinearTerm (colored-env color) context s)
         (subst : MetaSubstitution env nil (LinearMetaContextT {colored-env color} t) (EmptyMetaContext {env}))
         (MetaSubstitution.apply {env} ((unify-top.convert-to-injected-term color t)) SubList.sublist-trivial-skip subst = A)
         (\Pi {s : Sort'} (m : metaname {LinearMetaContextT {colored-env color} t} s) -> HasColoredRoot (Color.flip color) (subst m)) \elim color, A
  | color, var index p => (lt-var index p, \lam {s1} mvar => contradiction, \case \elim color \with {
    | red => idp
    | blue => idp
  }, \lam {s1} m => contradiction)
  | color, metavar m choosing => contradiction
  | red, func (inl f) choosing =>
    \let | inner-results i => decompose-term red (choosing i)
         | context-producer i => LinearMetaContextT {colored-env red} (inner-results i).1
         | unified-meta-context => ModularMetaContext {env} context-producer
         | unified-substitution : MetaSubstitution env nil unified-meta-context (EmptyMetaContext {env}) => \lam m => (inner-results m.1).2 m.2
    \in (lt-func f (\lam i => (inner-results i).1),
         unified-substitution,
         pmap (func {env} (inl f)) (ext (\lam index => (invariant-through-empty-subst {env} unified-substitution (SubList.extend-right-single SubList.sublist-trivial-skip) SubList.sublist-trivial-skip _) *>
         (inv (modular-commutation {env} (\lam i => LinearMetaContextT {envL} (inner-results i).1) index SubList.sublist-trivial-skip (unify-top.convert-to-injected-term red ((inner-results index).1)) unified-substitution)) *>
         (inner-results index).3)),
         \lam {s1} m => ((inner-results m.1).4 m.2))
  | red, func (inr f) choosing =>
    (lt-full-metavar {colored-env red},
     \lam {s1} mvar => transport (PureTerm env context __) (inv mvar) (func (inr f) choosing),
     pmap (func {env} (inr f)) (ext (\lam index => rewrite (append-context-right-to-identity.ext' {env}) (rewrite (plain-identity-effect {env}) idp))),
     \lam {s1} m => \case \elim s1, \elim m \with {
       | s1, idp => blue-func-root
     })
  | blue, func (inl f) choosing => {?}
  | blue, func (inr b) choosing => {?}

\func join-monochrome-terms {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                            (a b c : Term (colored-env color) context s mc)
                            (a~>b : TClosure (monochrome-reduction color) a b)
                            (a~>c : TClosure (monochrome-reduction color) a c)
                            (conf : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin b c (TClosure (\lam x y => \Sigma (rd : monochrome-reduction color x y) (FunctionalWitness {colored-env color} {colored-set-of-rules color} rd))) \elim color
  | red => conf a b c a~>b a~>c
  | blue => conf a b c a~>b a~>c

\func decompose-along-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
                                (color : Color)
                                (t : Term (colored-env color) context s inner-mc)
                                (B : Term env context s mc)
                                (subst : MetaSubstitution env nil inner-mc mc)
                                (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip color) (subst m))
                                (A~>B : TopLevelColoredReduction color {mc} {context} {s} (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-skip subst) B)
  : \Sigma (u : Term (colored-env color) context s (inner-mc))
           (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.sublist-trivial-skip subst = B)
           (rd : monochrome-reduction color t u)
           (FunctionalWitness {colored-env color} {colored-set-of-rules color} rd)\elim color, t, B, A~>B
  | red, func f choosing, func (inl f') choosing', rewrite-with-parameter-f-colored p p1 i tlcr eq =>
    \let | unmap => pmap (unor {_} {envR.symbol s} f) p
         | eq-p : p = pmap (inl) unmap => Path.inProp _ _
    \in inductive _ _ unmap choosing choosing' subst root-colors i (rewriteI eq-p tlcr) (rewriteI eq-p eq)
  | red, func f choosing, B, rewrite-with-rule-colored hcr lr r lf big-subst l[bs]=injt r[bs]=B (inh : Inherited {tc} red s lr r) =>
    \let | (middle-subst, substitution-equality, l-eq) =>
      decompose-metasubstitution
          red lr (transport (Term envL __ s inner-mc) (inv ++_nil) (func {envL} f choosing)) big-subst subst
          (rewrite (unwrap-injection {_} {red} lr) (rewrite (inv decompose-along-reduction.different-weakening.equate-sublists-3)
              (rewrite decompose-along-reduction.different-weakening.equate-sublists-2 (rewrite (transport-over-injection red)
                  (metasubst-over-transport-2 {env} ++_nil
                      (LinearPattern.convert-to-injected-term red lr)
                      (func (inl f) (\lam i => inject-monochrome-term red (choosing i))) big-subst subst l[bs]=injt))))) root-colors
         | term-u => MetaSubstitution.apply {envL} (weakening {envL} r SubList.sublist-trivial-skip) SubList.identity middle-subst
         | colored-coherence => colored-metacomposition red middle-subst subst big-subst substitution-equality SubList.identity (weakening {envL} r SubList.sublist-trivial-skip)
    \in (term-u,
         inv (colored-coherence) *> (pmap (MetaSubstitution.apply {env} __ SubList.identity big-subst) (inv (injection-weakening-commutation red _ _))) *> r[bs]=B,
         produce-monochrome-reduction red lr r middle-subst (func f choosing) term-u
             (rewrite (different-weakening {envL}) (metasubst-over-transport {envL} ++_nil _ (func f choosing) middle-subst
                 ((rewrite (inv decompose-along-reduction.different-weakening.equate-sublists-2)
                     (pmap (\lam sl => MetaSubstitution.apply {envL} (weakening {envL} (LinearPattern.convert-to-term {envL} lr) sl) (SubList.extend-right-single SubList.identity) middle-subst)
                         decompose-along-reduction.different-weakening.equate-sublists-3)) *> l-eq)))
             idp lf inh.idx inh.i-sort-eq inh.i-meta-eq inh.idx-l-eq inh.ifx-r-eq,
         {?})
  | red, metavar m choosing, B, A~>B =>
    \let
      | other-root-color => root-colors m
      | root-color => TopLevelColoredReduction.extract-root-coloring A~>B
      | empty : Empty => eliminate-colors (blue) other-root-color root-color
    \in contradiction
  | red, var index p, B, A~>B => \let rc => TopLevelColoredReduction.extract-root-coloring A~>B \in \case \elim rc \with {
  }
  | red, func f choosing, func (inr s1) choosing1, rewrite-with-parameter-f-colored p p1 i tlcr eq => contradiction
  | blue, t, B, A~>B => {?}
  \where {
    \func inductive {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
                    (f f' : envL.symbol s)
                    (eq : f = f')
                    (choosing :
                    \Pi (index : Fin (length (envL.domain f))) ->
                        Term tc.envL (context ++ f envL.!!param index) (f envL.!!sort index) inner-mc)
                    (choosing' :
                    \Pi (index : Fin (length (env.domain (inl f')))) ->
                        Term env (context ++ inl f' env.!!param index) (inl f' env.!!sort index) mc)
                    (subst : MetaSubstitution env nil (inner-mc) mc)
                    (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip red) (subst m))
                    (i : Fin (length (domain {env} (inl f))))
                    (tlcr : TopLevelColoredReduction red (MetaSubstitution.apply {env}
                        (Injections.inject-term-left envL envR (choosing i)) (SubList.extend-right-single SubList.sublist-trivial-skip)
                        subst) (transport-chooser-f {env} (pmap (inl {_} {envR.symbol s}) eq) choosing' i))
                    (eq' :
                    \Pi (j : Fin (length (domain {env} (inl f)))) -> (j = i -> Empty) -> MetaSubstitution.apply {env}
                        (Injections.inject-term-left envL envR (choosing j)) (SubList.extend-right-single SubList.sublist-trivial-skip)
                        subst = transport-chooser-f {env} (pmap (inl {_} {envR.symbol s}) eq) choosing' j)
      :  \Sigma (u : Term envL context s inner-mc)
                (MetaSubstitution.apply {env} (Injections.inject-term-left envL envR u) SubList.sublist-trivial-skip subst = func (inl f') choosing')
                (rd : monochrome-reduction red (func f choosing) u)
                (FunctionalWitness {colored-env red} {L-rules} rd)\elim eq
      | idp => \let inductive-step => (decompose-along-reduction red (choosing i) (choosing' i) subst root-colors (rewrite any-nil-sublist-equate tlcr)) \in
        (func f (collect-reductions-together-tlcr.pointed-function (\lam index => Term envL (context ++ f FSignature.!!param {envL} index) (f FSignature.!!sort {envL} index) inner-mc) choosing i (inductive-step).1),
         pmap (func {env} (inl f))
             (ext (\lam index => collect-reductions-together-tlcr.pointed-induction
                 (\lam index => Term envL (context ++ f FSignature.!!param {envL} index) (f FSignature.!!sort {envL} index) inner-mc) (\lam j fx => MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR
                     (fx)) (SubList.extend-right-single SubList.sublist-trivial-skip) subst = choosing' j)
                 choosing
                 i
                 (inductive-step).1
                 (rewrite any-nil-sublist-equate inductive-step.2)
                 (\lam j n => eq' j n)
                 index)),
         rewrite-with-parameter-f idp i (rewrite collect-reductions-together-tlcr.pointed-at-index (inductive-step.3)) (\lam j _x => inv (collect-reductions-together-tlcr.pointed-not-at-index _ choosing _ _ j _x)),
         param-rewriting (unifying-lemma _ _ _ _ _ inductive-step.4))
      \where {
        \func unifying-lemma {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                             (t u v : Term envL context s mc) (eq : v = u) (rd : RewriteRelation {envL} L-rules t u)
          (fw : FunctionalWitness {envL} {L-rules} rd):
          FunctionalWitness {envL} {L-rules} (transportInv (RewriteRelation {envL} tc.L-rules t) (eq) rd) \elim eq | idp => fw
      }

    \lemma eliminate-colors {tc : TheoremContext} (color : Color) {context context' : List Sort'} {s : Sort'} {msig : MetaContext Sort'}
                           {T : Term env context s msig} {subst : Substitution {env} context context' msig} (hcr : HasColoredRoot color T)
                           (hcr' : HasColoredRoot (Color.flip color) (Substitution.apply {env} T subst))
      : Empty \elim color, T, hcr, hcr'
      | red, func (inl s1) choosing, red-func-root, ()
      | blue, var index p, (), hcr'
      | blue, metavar m choosing, (), hcr'
      | blue, func f choosing1, hcr, hcr' =>
        \let | eq => (inv (HasColoredRoot.reorganize red hcr')) *> HasColoredRoot.reorganize blue hcr
        \in contradiction

    \func any-nil-sublist-equate {A : \Type} {a : List A} (sl sl' : SubList nil a) : sl = sl' \elim a, sl, sl'
      | nil, sublist-trivial, sublist-trivial => idp
      | :: y a, sublist-skip sl, sublist-skip sl' => pmap sublist-skip (any-nil-sublist-equate sl sl')

    \lemma different-weakening {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort}
                              (T : Term env nil s ms)
      : weakening T (SubList.sublist-trivial-skip {_} {context}) =
    transport (Term env __ s ms) (++_nil) (weakening T (SubList.extend-right-single SubList.identity)) \elim context
      | nil => idp
      | :: a context => lemma (++_nil) (sublist-skip SubList.sublist-trivial-skip) (sublist-skip SubList.sublist-trivial-skip) equate-sublists T
      \where {
        \lemma lemma  {env : FSignature} {context context' : List Sort} {s : Sort} {ms : MetaContext Sort}
                     (eq : context' = context) (sl : SubList nil context) (sl' : SubList nil context') (sl=sl' : sl = (transport (SubList nil) eq sl')) (T : Term env nil s ms) :
          weakening T sl = transport (Term env __ s ms) eq (weakening T sl') \elim context, eq, sl=sl'
          | nil, idp, idp => idp
          | :: a context, idp, idp => idp

        \func equate-sublists {A : \Type} {a : List A} : SubList.sublist-trivial-skip {_} {a} = transport (SubList nil) ++_nil (SubList.sublist-trivial-skip) \elim a
          | nil => idp
          | :: a a1 => (rewrite (equate-sublists {A} {a1}) (commute-skip ++_nil (SubList.sublist-trivial-skip)))
          \where {
            \func commute-skip {A : \Type} {x : A} {a b c : List A} (eq : a = b) (sl : SubList c a) : SubList.sublist-skip (transport (SubList c) eq sl) = transport (SubList c) (pmap (x ::) eq) (sublist-skip sl) \elim eq
              | idp => idp

            \func commute-skip-2 {A : \Type} {x : A} {a b c : List A} (eq : a = b) (sl : SubList (a) (c)) : SubList.sublist-skip (transport (SubList __ c) (eq) sl) = transport (SubList __ (x :: c)) (eq) (sublist-skip sl) \elim eq
              | idp => idp
          }

        \func equate-sublists-2 {A : \Type} {a : List A} : SubList.extend-right-single SubList.identity = transport (SubList a) (inv ++_nil) SubList.identity \elim a
          | nil => idp
          | :: a a1 => rewrite (equate-sublists-2 {_} {a1}) (commute-match _ _)
          \where {
            \func commute-match {A : \Type} {x : A} {a b c : List A} (eq : c = b) (sl : SubList a b):
              SubList.sublist-match idp (transport (SubList a) (inv eq) sl) = transport (SubList (x :: a)) (inv (pmap (x ::) eq)) (sublist-match idp sl) \elim eq
              | idp => idp

            \func commute-match-straight {A : \Type} {x : A} {a b c : List A} (eq : b = c) (sl : SubList a b):
              SubList.sublist-match idp (transport (SubList a) (eq) sl) = transport (SubList (x :: a)) ((pmap (x ::) eq)) (sublist-match idp sl) \elim eq
              | idp => idp

            \func commute-match-straight-2 {A : \Type} {x : A} {a b c : List A} (eq : b = c) (sl : SubList b a):
              SubList.sublist-match idp (transport (SubList __ a) (eq) sl) = transport (SubList __ (x :: a)) ((pmap (x ::) eq)) (sublist-match idp sl) \elim eq
              | idp => idp
          }

        \func equate-sublists-3 {A : \Type} {a : List A} : SubList.sublist-trivial-skip {_} {a ++ nil} = SubList.extend-left-single sublist-trivial {a} \elim a
          | nil => idp
          | :: a a1 => pmap sublist-skip equate-sublists-3
      }

    \lemma metasubst-over-transport {env : FSignature} {context context' : List Sort} {s : Sort} {ms ms' : MetaContext Sort} (eq : context = context')
                                    (T : Term env context s ms) (S : Term env context' s ms') (msubst : MetaSubstitution env context' ms ms')
                                    (eq' : MetaSubstitution.apply T (transport (SubList context') (inv eq) SubList.identity) msubst = (transport (Term env __ s ms') (inv eq) S))
      : MetaSubstitution.apply (transport (Term env __ s ms) eq T) (SubList.identity) msubst = S \elim eq
      | idp => eq'

    \lemma transport-over-injection {tc : TheoremContext} {context context' : List Sort'} (color : Color) (eq : context = context') {s : Sort'} {ms : MetaContext Sort'}
                                    (T : Term (colored-env color) context s ms) : inject-monochrome-term color (transport (Term (colored-env color) __ s ms) eq T) = transport (Term env __ s ms) eq (inject-monochrome-term color T) \elim color, eq
      | red, idp => idp
      | blue, idp => idp

    \lemma metasubst-over-transport-2 {env : FSignature} {context context' : List Sort} {s : Sort} {ms ms' ms'' : MetaContext Sort}
                                      (eq : context' = context)
                                      (T : Term env nil s ms) (S : Term env context s ms'')
                                      (msubst : MetaSubstitution env context ms ms')
                                      (msubst2 : MetaSubstitution env nil ms'' ms')
                                      (eq' : MetaSubstitution.apply (weakening T SubList.sublist-trivial-skip) SubList.identity msubst = MetaSubstitution.apply S SubList.sublist-trivial-skip msubst2)
      : MetaSubstitution.apply (weakening T SubList.sublist-trivial-skip) (transport (SubList context) (inv eq) SubList.identity) msubst = MetaSubstitution.apply (transport (Term env __ s ms'') (inv eq) S) SubList.sublist-trivial-skip msubst2 \elim eq
      | idp => eq'

    \lemma unwrap-injection {tc : TheoremContext} {color : Color} {context : List Sort'} {s : Sort'} (t : LinearPattern (colored-env color) context s) :
      inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} t) = LinearPattern.convert-to-injected-term color {context} {s} t \elim color, t
      | red, lp-func f choosing => pmap (func {env} (inl f))
          (ext (\lam index => rewriteI (unwrap-injection {_} {red} (choosing index)) (swap red (\lam i => LinearMetaContext {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing index)))))
      | blue, lp-func f choosing => pmap (func {env} (inr f))
          (ext (\lam index => rewriteI (unwrap-injection {_} {blue} (choosing index)) (swap blue (\lam i => LinearMetaContext {envR} (choosing i)) (LinearPattern.convert-to-term {envR} (choosing index)))))
      | red, lp-metavar => idp
      | blue, lp-metavar => idp
      \where {
        \lemma swap
          {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {n : Nat} {i : Fin n} (msigs : \Pi (i : Fin n) -> MetaContext Sort')
          (t : Term (colored-env color) context s (msigs i)) :
          inject-monochrome-term color (LinearPattern.upgrade-metavariables-p {colored-env color} msigs t) =
          LinearPattern.upgrade-metavariables-p {env} msigs (inject-monochrome-term color t) \elim color, t
          | red, var index p => idp
          | red, metavar m choosing =>
            \let extt : (\lam i1 => Injections.inject-term-left envL envR (LinearPattern.upgrade-metavariables-p {envL} msigs (choosing i1))) = (\lam i1 => (LinearPattern.upgrade-metavariables-p {env} msigs (Injections.inject-term-left envL envR (choosing i1)))) => ext (\lam i => swap red msigs (choosing i))
            \in rewrite extt idp
          | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => (swap red msigs (choosing index))))
          | blue, var index p => idp
          | blue, metavar m choosing =>
            \let extt : (\lam i1 => Injections.inject-term-right envL envR (LinearPattern.upgrade-metavariables-p {envR} msigs (choosing i1))) = (\lam i1 => (LinearPattern.upgrade-metavariables-p {env} msigs (Injections.inject-term-right envL envR (choosing i1)))) => ext (\lam i => swap blue msigs (choosing i))
            \in rewrite extt idp
          | blue, func f choosing => pmap (func {env} (inr f)) (ext (\lam index => (swap blue msigs (choosing index))))
      }
  }

\func produce-monochrome-reduction
  {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (color : Color)
  (pattern : LinearPattern (colored-env color) nil s)
  (rule-r : Term (colored-env color) nil s (LinearMetaContext {colored-env color} pattern))
  (subst : MetaSubstitution (colored-env color) context (LinearMetaContext {colored-env color} pattern) mc)
  (l r : Term (colored-env color) context s mc)
  (l-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} pattern) SubList.sublist-trivial-skip) SubList.identity subst = l)
  (r-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} rule-r SubList.sublist-trivial-skip) SubList.identity subst = r)
  (l-is-func : FunctionalRoot {colored-env color} (LinearPattern.convert-to-term {colored-env color} pattern))
  (idx : J {JointRules {_} {envL} {envR} L-rules R-rules})
  (i-sort-eq : s = RewriteRule.s {get {JointRules {_} {envL} {envR} L-rules R-rules} idx})
  (i-meta-eq : (LinearMetaContext {colored-env color} pattern) = RewriteRule.meta-context {get {JointRules {_} {envL} {envR} L-rules R-rules} idx})
  (idx-l-eq : RewriteRule.l {get {JointRules {_} {envL} {envR} L-rules R-rules} idx} = transport2 (\lam sort mc => Term env nil sort mc) (i-sort-eq) i-meta-eq (LinearPattern.convert-to-injected-term color pattern))
  (ifx-r-eq : RewriteRule.r {get {JointRules {_} {envL} {envR} L-rules R-rules} idx} = transport2 (\lam sort mc => Term env nil sort mc) i-sort-eq i-meta-eq (inject-monochrome-term color rule-r))
  : monochrome-reduction color l r \elim color, idx
  | red, inl idx => rewrite-with-rule idx i-sort-eq (rewriteI i-meta-eq subst) (unembed-tlcr.untransport {envL} i-sort-eq i-meta-eq subst (LinearPattern.convert-to-term {envL} pattern) (RewriteRule.l {L-rules.get idx}) l l-eq {?}) {?}
  | blue, inr idx => {?}
  | red, inr b => \let | l-hcr => get-colored-root-for-l (inr b)
                       | lp-hcr => infer-hcr red pattern l-is-func \in \let q => contradictory _ _ _ _ idx-l-eq l-hcr lp-hcr \in contradiction
  | blue, inl a => \let | l-hcr => get-colored-root-for-l (inl a)
                        | lp-hcr => infer-hcr blue pattern l-is-func \in \let q => contradictory _ _ _ _ idx-l-eq l-hcr lp-hcr \in contradiction
  \where {
    \func infer-hcr {tc : TheoremContext} {s : Sort'} (color : Color) (lp : LinearPattern (colored-env color) nil s) (fr : FunctionalRoot {colored-env color} (LinearPattern.convert-to-term {colored-env color} lp)) : HasColoredRoot color (LinearPattern.convert-to-injected-term color lp) \elim color, lp, fr
      | red, lp-func f choosing, T-has-functional-root => red-func-root
      | blue, lp-func f choosing, T-has-functional-root => blue-func-root

    \func contradictory {tc : TheoremContext} {color : Color} {s s' : Sort'} {mc mc' : MetaContext Sort'} (eq1 : s = s') (eq2 : mc = mc') (t : Term env nil s' mc') (t2 : Term env nil s mc) (eqt : t = transport2 (Term env nil) eq1 eq2 t2)  (hcr1 : HasColoredRoot color t) (hcr2 : HasColoredRoot (Color.flip color) t2) : Empty \elim color, eq1, eq2, t, t2, hcr1, hcr2
      | red, idp, idp, func (inl s1) choosing, func (inr b) choosing1, red-func-root, blue-func-root => \let q => pmap (decompose-metasubstitution.unfunc {env} (inl s1)) eqt \in contradiction
      | blue, idp, idp, func (inr s1) choosing, func (inl a) choosing1, blue-func-root, hcr2 => \let q => pmap (decompose-metasubstitution.unfunc {env} (inr s1)) eqt \in contradiction
  }

\func inject-linear-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                            (l : LinearPattern (colored-env color) context s) : LinearPattern env context s \elim color, l
  | red, lp-func f choosing => lp-func (inl f) (\lam i => inject-linear-pattern red (choosing i))
  | color, lp-metavar => lp-metavar {env}
  | blue, lp-func f choosing => lp-func (inr f) (\lam i => inject-linear-pattern blue (choosing i))
  \where {
    \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} (l : LinearPattern env context s) \elim l
      | lp-func f choosing =>
      lp-witness-f (color-of-root f = color)
                   (\Pi (i : Fin (length (env.domain f))) -> InjectionWitness color (choosing i))
      | lp-metavar => lp-witness-fm
  }

\func inject-linear-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                         (l : LinearTerm (colored-env color) context s) : LinearTerm env context s \elim color, l
  | red, lt-func f choosing => lt-func (inl f) (\lam i => inject-linear-term red (choosing i))
  | blue, lt-func f choosing => lt-func (inr f) (\lam i => inject-linear-term blue (choosing i))
  | color, lt-full-metavar => lt-full-metavar {env}
  | color, lt-var index p => lt-var index p
  \where {
    \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} (l : LinearTerm env context s) \elim l
      | lt-func f choosing =>
      lt-witness-f (color-of-root f = color)
                   (\Pi (i : Fin (length (env.domain f))) -> InjectionWitness color (choosing i))
      | lt-var _ _ => lt-witness-v
      | lt-full-metavar => lt-witness-fm

    \lemma generate-injection-witness {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                                      (l : LinearTerm (colored-env color) context s) : InjectionWitness color (inject-linear-term color l) \elim color, l
      | red, lt-func f choosing => lt-witness-f idp (\lam i => generate-injection-witness red (choosing i))
      | blue, lt-func f choosing => lt-witness-f idp (\lam i => generate-injection-witness blue (choosing i))
      | red, lt-full-metavar => lt-witness-fm
      | blue, lt-full-metavar => lt-witness-fm
      | red, lt-var index p => lt-witness-v
      | blue, lt-var index p => lt-witness-v

    \lemma extract-from-witness {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color) (f : env.symbol s)
                                (choosing :  \Pi (index : Fin (length (env.domain f))) -> LinearTerm env (context ++ f env.!!param index) (f env.!!sort index)) -- Why env?
                                (witness : InjectionWitness color (lt-func {env} f choosing))
      : \Sigma (\Pi (i : Fin (length (env.domain f))) -> InjectionWitness color (choosing i)) (color-of-root f = color) \elim color, witness
      | color, lt-witness-f p _x => (_x, p)
  }

\lemma colored-metacomposition {tc : TheoremContext} {global-context : List Sort'} {ms-a ms-b ms-c : MetaContext Sort'}
                               (color : Color)
                               (subst-a : MetaSubstitution (colored-env color) global-context ms-a ms-b)
                               (subst-b : MetaSubstitution env nil ms-b ms-c)
                               (subst-c : MetaSubstitution env global-context ms-a ms-c)
                               (eq : \Pi {s : Sort'} (m : ms-a.metaname s) -> subst-c m = MetaSubstitution.apply {env} (inject-monochrome-term color (subst-a m)) (SubList.sublist-trivial-skip) subst-b)
                               {context : List Sort'} {s : Sort'}
                               (sublist : SubList global-context context)
                               (t : Term (colored-env color) context s ms-a)
  : MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term color (MetaSubstitution.apply {colored-env color} t sublist subst-a)) SubList.sublist-trivial-skip subst-b \elim color, t
  | red, var index p => idp
  | red, metavar m choosing =>
    \let | inner i : MetaSubstitution.apply {env} (inject-monochrome-term red (choosing i)) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (choosing i) sublist subst-a)) SubList.sublist-trivial-skip subst-b => colored-metacomposition red subst-a subst-b subst-c eq sublist (choosing i)
         | inner-ext : (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (choosing i)) sublist subst-c) = (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (choosing i) sublist subst-a)) SubList.sublist-trivial-skip subst-b) => ext inner
    \in rewrite (eq m) (inv (rewrite inner-ext (rewrite twist-application (commutation subst-b (\lam ind => Injections.inject-term-left tc.envL tc.envR (extend-substitution-left {envL} sublist (\lam i => MetaSubstitution.apply {envL} (choosing i) sublist subst-a) ind)) (Injections.inject-term-left envL envR (subst-a m)) *> (pmap (Substitution.apply {env} (MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR (subst-a m)) SubList.sublist-trivial-skip subst-b)) (extend-left-commutation.ext' _ _ _))))))
  | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => (colored-metacomposition red subst-a subst-b subst-c eq (SubList.extend-right-single sublist) (choosing index)) *> invariant-through-empty-subst {env} subst-b SubList.sublist-trivial-skip (SubList.extend-right-single SubList.sublist-trivial-skip) _))
  | blue, t => {?} -- completely symmetrical
  \where {
    \func extend-left-commutation {tc : TheoremContext} {context-a context-b context-c : List Sort'} {mc mc' : MetaContext Sort'}
                                  (subst : Substitution {envL} context-b context-c mc)
                                  (sublist : SubList context-a context-c)
                                  (msubst : MetaSubstitution env nil mc mc')
                                  (i : Fin (length (context-a ++ context-b))) :
      (MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR (extend-substitution-left {envL} sublist subst i))
            SubList.sublist-trivial-skip msubst) = extend-substitution-left {env} sublist (\lam (j : Fin (length (context-b))) => MetaSubstitution.apply {env}
        (Injections.inject-term-left tc.envL tc.envR (subst j)) SubList.sublist-trivial-skip msubst) i =>
      partial-fin-induction (\lam fin => (MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR (extend-substitution-left {envL} sublist subst fin))
          SubList.sublist-trivial-skip msubst) = extend-substitution-left {env} sublist (\lam (j : Fin (length (context-b))) => MetaSubstitution.apply {env}
          (Injections.inject-term-left tc.envL tc.envR (subst j)) SubList.sublist-trivial-skip msubst) fin)
          (\lam i1 => rewrite (extend-substitution-left.for-left-context {env}) (rewrite (extend-substitution-left.for-left-context {envL}) idp))
          (\lam i1 => rewrite (extend-substitution-left.for-right-context {env}) (rewrite (extend-substitution-left.for-right-context {envL}) (untransport sublist msubst _ _)))
          i
    \where {
      \func ext' {tc : TheoremContext} {context-a context-b context-c : List Sort'} {mc mc' : MetaContext Sort'}
                 (subst : Substitution {envL} context-b context-c mc)
                 (sublist : SubList context-a context-c)
                 (msubst : MetaSubstitution env nil mc mc'):
        (\lam (i : Fin (length (context-a ++ context-b))) =>
          MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR (extend-substitution-left {envL} sublist subst i))
              SubList.sublist-trivial-skip msubst) = extend-substitution-left {env} sublist (\lam (i : Fin (length (context-b))) => MetaSubstitution.apply {env}
          (Injections.inject-term-left tc.envL tc.envR (subst i))
          SubList.sublist-trivial-skip msubst) => ext (extend-left-commutation _ _ _)

      \func untransport {tc : TheoremContext} {s s' : Sort'} {context-a context-c : List Sort'} {mc mc' : MetaContext Sort'}
                        (sublist : SubList context-a context-c)
                        (msubst : MetaSubstitution env nil mc mc')
                        (t : Term envL context-c s mc)
                        (eq : s = s')
                        : MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR
                        (transport (Term tc.envL context-c __ mc) eq (t)))
        SubList.sublist-trivial-skip msubst = transport (Term env context-c __ mc') eq
      (MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR t) SubList.sublist-trivial-skip msubst) \elim eq
        | idp => idp
    }


    \lemma commutation {tc : TheoremContext} {term-context context : List Sort'} {s : Sort'} {ms-a ms-b : MetaContext Sort'}
                       (metasubst : MetaSubstitution env nil ms-a ms-b)
                       (subst : Substitution {env} term-context context ms-a)
                       (T : Term env term-context s ms-a)
      :
      MetaSubstitution.apply {env}
          (Substitution.apply {env} (T) (subst))
          SubList.sublist-trivial-skip
          metasubst =
      Substitution.apply {env}
          (MetaSubstitution.apply {env} (T) (SubList.sublist-trivial-skip) metasubst)
          ((\lam i => MetaSubstitution.apply {env} (subst i) SubList.sublist-trivial-skip metasubst)) \elim T
      | var index idp => idp
      | metavar m choosing => rewrite (tlcr-over-substitution.commutation.subst-comm {env}) (pmap (Substitution.apply {env} (metasubst m)) (ext (\lam index => commutation metasubst subst (choosing index))))
      | func f choosing => pmap (func {env} (f)) (ext (\lam index => \let inductive => commutation metasubst (append-context-right {env} subst) (choosing index) \in ((rewrite (decompose-along-reduction.any-nil-sublist-equate _ (SubList.sublist-trivial-skip))) (inductive *> ((rewrite (decompose-along-reduction.any-nil-sublist-equate (SubList.extend-right-single SubList.sublist-trivial-skip) (SubList.sublist-trivial-skip))) (pmap (Substitution.apply {env} (MetaSubstitution.apply {env} (choosing index) SubList.sublist-trivial-skip metasubst)) (append-context-right-commutation.ext' {env} subst metasubst)))))))
      \where {
        \func append-context-right-commutation {env : FSignature} {context-a context-b context-c : List Sort} {ms ms' : MetaContext Sort}
                                               (subst : Substitution context-a context-c ms)
                                               (metasubst : MetaSubstitution env nil ms ms')
                                               (i : Fin (length (context-a ++ context-b)))
          : (MetaSubstitution.apply (append-context-right subst i) SubList.sublist-trivial-skip metasubst) =
        append-context-right
            (\lam (i : Fin (length context-a)) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip metasubst) i =>
          partial-fin-induction
              (\lam ind => (MetaSubstitution.apply (append-context-right subst ind) SubList.sublist-trivial-skip metasubst) =
              append-context-right
                  (\lam (i : Fin (length context-a)) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip metasubst) ind)
              (\lam i1 => repeat {2} (rewrite (append-context-right-begin)) (untransport _ _ _ _))
              (\lam i1 => repeat {2} (rewrite (append-context-right-end)) idp)
              i
          \where {
            \func ext' {env : FSignature} {context-a context-b context-c : List Sort} {ms ms' : MetaContext Sort}
                       (subst : Substitution context-a context-c ms)
                       (metasubst : MetaSubstitution env nil ms ms')
              : (\lam (i : Fin (length (context-a ++ context-b))) => MetaSubstitution.apply (append-context-right subst i) SubList.sublist-trivial-skip metasubst) =
            append-context-right (\lam (i : Fin (length context-a)) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-skip metasubst) =>
              ext (append-context-right-commutation _ _)

            \func untransport {env : FSignature} {context-a context-c : List Sort} {s s' : Sort} {ms ms' : MetaContext Sort}
                              (t : Term env context-a s ms)
                              (metasubst : MetaSubstitution env nil ms ms')
                              (sublist : SubList context-a context-c)
                              (eq : s = s')
              : MetaSubstitution.apply
                (weakening (transport (Term env context-a __ ms) eq t)
                    (sublist)) SubList.sublist-trivial-skip metasubst = weakening (transport (Term env context-a __ ms') eq
                (MetaSubstitution.apply t SubList.sublist-trivial-skip metasubst)) (sublist) \elim t, eq
              | var index p, idp => idp
              | metavar m choosing, idp => \let | inductive i => untransport (choosing i) metasubst sublist idp
                                           | inductive-ext : (\lam i => MetaSubstitution.apply
                                               (weakening ((choosing i)) sublist)
                                               SubList.sublist-trivial-skip metasubst) = (\lam i => weakening ((MetaSubstitution.apply (choosing i) SubList.sublist-trivial-skip metasubst)) sublist) => ext inductive \in unfold transport (rewrite (weakening-as-substitution-eq sublist ((Substitution.apply (metasubst m)
                  (\lam (j : Fin (length (nil ++ ms.m-domain m))) => MetaSubstitution.apply (choosing j) SubList.sublist-trivial-skip metasubst)))) (rewrite inductive-ext (rewrite (internal-lemma choosing sublist metasubst) (inv (tlcr-over-substitution.commutation.subst-comm _ _ _)))))
              | func f choosing, idp => pmap (func f) (ext (\lam index => repeat {2} (rewrite (decompose-along-reduction.any-nil-sublist-equate (SubList.extend-right-single SubList.sublist-trivial-skip) (SubList.sublist-trivial-skip))) (untransport (choosing index) metasubst (SubList.extend-right-both sublist) idp)))

            \func internal-lemma {env : FSignature} {s : Sort} {context context-b : List Sort} {ms ms' : MetaContext Sort} {m : ms.metaname s}
                                 (choosing : \Pi (index : Fin (length (ms.m-domain m))) -> Term env context (ms.m-domain m !! index) ms)
                                 (sublist : SubList context context-b)
                                 (metasubst : MetaSubstitution env nil ms ms')
              : (\lam (j : Fin (length (nil ++ ms.m-domain m))) =>
                weakening (MetaSubstitution.apply (choosing j) SubList.sublist-trivial-skip metasubst) sublist) = (\lam (j : Fin (length (nil ++ ms.m-domain m))) =>
                Substitution.apply (MetaSubstitution.apply (choosing j) SubList.sublist-trivial-skip metasubst) (weakening-as-substitution sublist)) => ext (\lam j => rewrite weakening-as-substitution-eq idp)
          }
      }

    \lemma twist-application
      {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {ms : MetaContext Sort'}
      (t : Term envL context s ms) (subst : Substitution {envL} context context' ms)
      : Injections.inject-term-left envL envR (Substitution.apply {envL} t subst) = Substitution.apply {env} (Injections.inject-term-left envL envR t) (\lam i => Injections.inject-term-left envL envR (subst i)) \elim t
      | var index p => \case \elim s, \elim p \with {
        | s, idp => idp
      }
      | metavar m choosing => pmap (metavar {env} m) (ext (\lam index => twist-application (choosing index) subst))
      | func f choosing => pmap (func {env} (inl f)) (ext (\lam index => rewrite (push-append-context-right subst) (twist-application (choosing index) (append-context-right {envL} subst))))
      \where {
        \lemma push-append-context-right {tc : TheoremContext} {context context' additional-context : List Sort'} {ms : MetaContext Sort'}
                                         (subst : Substitution {envL} context context' ms)
          : (append-context-right {env} {_} {_} {_} (\lam i => Injections.inject-term-left envL envR (subst i)) {additional-context}) =
        (\lam i => Injections.inject-term-left envL envR (append-context-right {envL} subst i)) =>
          ext (push-append-context-right-ext subst)

        \lemma push-append-context-right-ext {tc : TheoremContext} {context context' additional-context : List Sort'} {ms : MetaContext Sort'}
                                             (subst : Substitution {envL} context context' ms) (index : Fin (length (context ++ additional-context)))
          : (append-context-right {env} {_} {_} {_} (\lam i => Injections.inject-term-left envL envR (subst i))) {additional-context}  index =
        (Injections.inject-term-left envL envR (append-context-right {envL} subst index)) \elim context, index
          | nil, index => idp
          | :: a context, 0 => injection-weakening-commutation red (SubList.extend-right-single SubList.identity) _
          | :: a additional-context, suc index => push-append-context-right-ext (\lam i => subst (suc i)) index
      }
  }

\lemma injection-weakening-commutation
  {tc : TheoremContext} (color : Color) {context context' : List Sort'} {ms : MetaContext Sort'} {s : Sort'}
  (sublist : SubList context context')
  (t : Term (colored-env color) context s ms)
  : weakening {env} (inject-monochrome-term color t) sublist = inject-monochrome-term color (weakening {colored-env color} t sublist) \elim color, t
  | red, var index p => idp
  | red, metavar m choosing => pmap (metavar {env} m) (ext (\lam index => injection-weakening-commutation red sublist (choosing index)))
  | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => injection-weakening-commutation red (SubList.extend-right-both sublist) (choosing index)))
  | blue, var index p => idp
  | blue, metavar m choosing => pmap (metavar {env} m) (ext (\lam index => injection-weakening-commutation blue sublist (choosing index)))
  | blue, func f choosing => pmap (func {env} (inr f)) (ext (\lam index => injection-weakening-commutation blue (SubList.extend-right-both sublist) (choosing index)))


\func decompose-metasubstitution
  {tc : TheoremContext} {pattern-context core-context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
  (color : Color)
  (l : LinearPattern (colored-env color) pattern-context s)
  (t : Term (colored-env color) (core-context ++ pattern-context) s inner-mc)
  (big-substitution : MetaSubstitution env core-context (LinearMetaContext {colored-env color} l) mc)
  (middle-substitution : MetaSubstitution env nil inner-mc mc)
  (eq :
  MetaSubstitution.apply {env}
      (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} l)) (SubList.extend-left-single SubList.identity {core-context}))
      (SubList.extend-right-single SubList.identity) big-substitution =
  MetaSubstitution.apply {env}
      (inject-monochrome-term color t)
      SubList.sublist-trivial-skip
      middle-substitution)
  (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip color) (middle-substitution m))
  : \Sigma (inner-substitution : MetaSubstitution (colored-env color) core-context (LinearMetaContext {colored-env color} l) inner-mc)
           (\Pi {s : Sort'} (m : metaname {LinearMetaContext {colored-env color} l} s) ->
               big-substitution m = MetaSubstitution.apply {env} (inject-monochrome-term color (inner-substitution m)) SubList.sublist-trivial-skip middle-substitution)
           (MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} l) (SubList.extend-left-single SubList.identity {core-context})) (SubList.extend-right-single SubList.identity) inner-substitution = t)
\elim color, l, t
  | red, lp-func f choosing, metavar m choosing1 =>
    \let | opposite-color-for-m => root-colors m
         | colored-root-for-f : HasColoredRoot red (func (inl f)
             (\lam i => MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (LinearPattern.upgrade-metavariables-p {envL}
                 (\lam i => LinearMetaContext {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing i))))
                 (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)) => red-func-root
         | colored-root-for-m : HasColoredRoot red (Substitution.apply {env} (middle-substitution m) (extend-substitution-left {env} SubList.sublist-trivial-skip
             (\lam i => MetaSubstitution.apply {env} (Injections.inject-term-left envL envR (choosing1 i)) SubList.sublist-trivial-skip middle-substitution))) => rewriteI eq colored-root-for-f
         | empty => decompose-along-reduction.eliminate-colors blue opposite-color-for-m colored-root-for-m
    \in contradiction
  | red, lp-func f choosing, func f1 choosing1 =>
    \let | f-eq : f = f1 => pmap (unor f) (pmap (unfunc {env} (inl f)) eq)
    \in inductive-step f f1 f-eq choosing choosing1 big-substitution middle-substitution root-colors eq
  | red, lp-metavar, t =>
    (\lam {s1} mvar => transport (\lam sort => Term envL (core-context ++ pattern-context) sort inner-mc) mvar t,
     \lam {s1} m => \case \elim s, \elim t, \elim big-substitution, \elim eq, \elim m \with {
       | s, t, big-substitution, eq, idp =>
         (rewrite {1} (inv (plain-identity-effect {env} (big-substitution idp))) (pmap (Substitution.apply {env} (big-substitution idp)) (inv (weakening-extension-ext {env})))) *> eq
     },
     (unfold transport (transport (\lam sbst => Substitution.apply {envL} t sbst = t) (inv (weakening-extension-ext {envL} {core-context} {pattern-context} {inner-mc})) (plain-identity-effect {envL} _))))
  | blue, _, _ => {?}
  \where {
    \lemma unfunc-eq {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort} (f f' : symbol s)
                     (choosing : \Pi (index : Fin (length (domain f))) -> Term env (context ++ (f FSignature.!!param index)) (f FSignature.!!sort index) ms)
                     (choosing' : \Pi (index : Fin (length (domain f'))) -> Term env (context ++ (f' FSignature.!!param index)) (f' FSignature.!!sort index) ms)
                     (eq : (func f choosing) = (func f' choosing')) : f = f' => pmap (unfunc f) eq

    \func unfunc {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort} (f : symbol s)
                 (T : Term env context s ms) : symbol s \elim T
      | var index p => f
      | metavar m choosing => f
      | func f1 choosing => f1

    \func inductive-step
      {tc : TheoremContext} {pattern-context core-context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
      (f : symbol {envL} s)
      (f1 : symbol {envL} s)
      (eq : f = f1)
      (choosing :
      \Pi (index : Fin (length (domain {envL} f))) ->
          LinearPattern (envL) (pattern-context ++ f envL.!!param index) (f envL.!!sort index))
      (choosing1 :
      \Pi (index : Fin (length (domain {envL} f1))) ->
          Term envL ((core-context ++ pattern-context) ++ f1 envL.!!param index) (f1 envL.!!sort index)
              inner-mc)
      (big-substitution : MetaSubstitution env core-context (LinearMetaContext {envL} (lp-func f choosing)) mc)
      (middle-substitution : MetaSubstitution env nil inner-mc mc)
      (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (blue) (middle-substitution m))
      (eq' : MetaSubstitution.apply {env}
          (weakening {env} (inject-monochrome-term red (LinearPattern.convert-to-term {colored-env red} (lp-func {envL} f choosing))) (SubList.extend-left-single SubList.identity {core-context}))
          (SubList.extend-right-single SubList.identity) big-substitution =
      MetaSubstitution.apply {env}
          (inject-monochrome-term red (func {envL} f1 choosing1))
          SubList.sublist-trivial-skip
          middle-substitution):
      \Sigma (inner-substitution : MetaSubstitution (envL) core-context (LinearMetaContext {envL} (lp-func f choosing)) inner-mc)
             (\Pi {s : Sort'} (m : metaname {LinearMetaContext {envL} (lp-func f choosing)} s) ->
                 big-substitution m = MetaSubstitution.apply {env} (inject-monochrome-term red (inner-substitution m)) SubList.sublist-trivial-skip middle-substitution)
             (MetaSubstitution.apply {envL} (weakening {envL} (LinearPattern.convert-to-term {envL} (lp-func f choosing)) (SubList.extend-left-single SubList.identity {core-context})) (SubList.extend-right-single SubList.identity) inner-substitution = (func f1 choosing1))
    \elim eq
      | idp =>
        \let | args-eq i  : (MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (LinearPattern.upgrade-metavariables-p {envL}
            (\lam i => LinearMetaContext {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing i))))
            (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)
          =
        (MetaSubstitution.apply {env}
            (Injections.inject-term-left envL envR (choosing1 i)) (SubList.extend-right-single SubList.sublist-trivial-skip)
            middle-substitution) =>
          (\let | sigmas-or =>  (pmap (alternate-subst.unwrap-func {env}) eq')
                | inf : env.symbol s => inl f
                | z => pmap (unor-r {Nat} {(\Sigma (f : symbol {env} s) (\Pi (index : Fin (length (domain {env} f))) ->
                    Term env ((core-context ++ pattern-context) ++ f env.!!param index) (f env.!!sort index)
                        mc))} ((inl {_} {envR.symbol s} f, \lam i => MetaSubstitution.apply {env}
                    (Injections.inject-term-left envL envR (choosing1 i)) (SubList.extend-right-single SubList.sublist-trivial-skip)
                    middle-substitution))) sigmas-or
                | rhs => sigmas-or @ left
                | res => alternate-subst.sigma-set-equalizer {symbol {env} s} ((\lam f => \Pi (index : Fin (length (domain {env} f))) ->
                    Term env ((core-context ++ pattern-context) ++ f env.!!param index) (f env.!!sort index)
                        mc)) {inl f} z
                | res' => pmap (__ i) res
           \in res')
             | inductive i => decompose-metasubstitution red
                 (choosing i)
                 (transport (Term envL __ _ inner-mc) (++-assoc {_} {core-context} {pattern-context} {f1 envL.!!param i}) (choosing1 i))
                 (\lam m => big-substitution (i, m))
                 middle-substitution
                 (\let ind : ( MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (LinearPattern.upgrade-metavariables-p {envL}
                     (\lam i => LinearMetaContext {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing i))))
                     (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)
                   =
                 (MetaSubstitution.apply {env}
                     (Injections.inject-term-left envL envR (choosing1 i)) (SubList.extend-right-single SubList.sublist-trivial-skip)
                     middle-substitution) => args-eq i \in apply-modularity-colored red (\lam i => LinearMetaContext {envL} (choosing i)) (\lam j m => big-substitution (j, m)) _ _ _ *> (rewrite weakening-over-double-extend.inv' (rewrite weakening-over-double-extend-2.inv' (rewrite weakening-over-double-extend-3 (ad-hoc-lemma red (\lam i => LinearMetaContext {envL} (choosing i))  (LinearPattern.convert-to-term {envL} (choosing i)) ++-assoc _ _ (\lam {s1} m => big-substitution (m.1, m.2)) (choosing1 i) middle-substitution _ ind))))
                 )
                 root-colors
        \in (\lam {s1} mvar => (inductive mvar.1).1 mvar.2,
             \lam {s1} m => (inductive m.1).2 m.2,
             pmap (func {envL} f1) (ext (\lam index =>
                 \let ind => (inductive index).3
                 \in rewrite (inv (alternate-subst.apply-modularity {envL}
                     (\lam i => LinearMetaContext {envL} (choosing i))
                     (\lam i => (inductive i).1)
                     (SubList.extend-right-single (SubList.extend-right-single SubList.identity))
                     (SubList.extend-right-both (SubList.extend-left-single SubList.identity))
                     (LinearPattern.convert-to-term {envL} (choosing index))))
                     (rewrite (weakening-over-double-extend)
                         (rewrite weakening-over-double-extend-2
                             (expand-substitution-3 {envL} _ _ _ _ _ _ ind))))))

    \lemma ad-hoc-lemma
      {tc : TheoremContext} {subst-context context  big-context big-context' : List Sort'} {s : Sort'} {ms-a ms-b : MetaContext Sort'}
      {n : Nat} {index : Fin n}
      (color : Color)
      (producer : Fin n -> MetaContext Sort')
      (term : Term (colored-env color) context s (producer index))
      (eq : big-context = big-context')
      (sublist : SubList context big-context)
      (sublist' : SubList subst-context big-context)
      (msubst : MetaSubstitution env subst-context (ModularMetaContext {env} producer) ms-b)
      (S : Term (colored-env color) big-context s ms-a)
      (msubst' : MetaSubstitution env nil ms-a ms-b)
      (sublist'' : SubList nil big-context)
      (target-eq : MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color (LinearPattern.upgrade-metavariables-p {colored-env color} producer term)) sublist) sublist' msubst = MetaSubstitution.apply {env} (inject-monochrome-term color S) sublist'' msubst')
      : MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color (LinearPattern.upgrade-metavariables-p {colored-env color} producer term)) (transport (SubList context) eq sublist)) (transport (SubList subst-context) eq sublist') msubst = MetaSubstitution.apply {env} (inject-monochrome-term color (transport (Term (colored-env color) __ s ms-a) eq S)) (transport (SubList nil) eq sublist'') msubst' \elim color, eq
      | red, idp => target-eq
      | blue, idp => target-eq
  }


\lemma weakening-extension-ext {env : FSignature} {left-context right-context : List Sort} {mc : MetaContext Sort}
  : extend-substitution-left {_} {left-context} {right-context} (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) = plain-identity {_} {_} {mc}
  => ext (weakening-extension)

\lemma weakening-extension {env : FSignature} {left-context right-context : List Sort} {mc : MetaContext Sort}
                          (i : Fin (length (left-context ++ right-context)))
  : extend-substitution-left (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i = plain-identity {_} {_} {mc} i =>
  partial-fin-induction
      (\lam i =>
          extend-substitution-left (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i
            =
          plain-identity {_} {_} {mc} i)
      (\lam i1 => \let | q => extend-substitution-left.for-left-context (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i1
                       | (right-eq, big-eq) => weakening.recalculate-index-over-right-extension' {Sort} {left-context} {right-context} i1
                       | q' : right-eq = (expand-fin-eq i1) => Path.inProp _ _
                  \in q *> (rewriteI q' (pmap to-var big-eq)))
      (\lam i1 => \let | q => extend-substitution-left.for-right-context (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i1
                       | big-eq => weakening.recalculate-index-over-left-extension' {Sort} {left-context} {right-context} i1
                  \in q *> (rewrite (pmap to-var big-eq) (append-context-right-to-identity.lem2 (expand-fin-late i1) (inv (expand-fin-eq-late i1)) idp (inv (expand-fin-eq-late i1)))))
      i

\func weakening-over-double-extend {A : \Type} {context-a context-b context-c : List A}
  : (SubList.extend-right-both (SubList.extend-left-single (SubList.identity {_} {context-b}) {context-a}) {context-c}) = transport (SubList (context-b ++ context-c)) (inv ++-assoc) (SubList.extend-left-single SubList.identity)
\elim context-a, context-b, context-c
  | nil, nil, context-c => idp
  | nil, :: a context-b, context-c => rewrite (weakening-over-double-extend {_} {nil} {context-b} {_}) (idp)
  | :: a context-a, nil, :: a1 context-c => rewrite (weakening-over-double-extend {_} {_} {nil}) (rewrite (decompose-along-reduction.different-weakening.equate-sublists.commute-skip {A} {a} _ (SubList.extend-left-single (sublist-match idp SubList.identity))) (transport-lemma (SubList (a1 :: nil ++ context-c)) (:: a) _ _))
  | :: a context-a, nil, nil => rewrite (weakening-over-double-extend {_} {_} {nil}) (rewrite (decompose-along-reduction.different-weakening.equate-sublists.commute-skip {A} {a} _ (SubList.extend-left-single (sublist-trivial))) (transport-lemma (SubList (nil)) (:: a) _ _))
  | :: a context-a, :: a1 context-b, context-c => rewrite (weakening-over-double-extend {_} {_} {:: a1 context-b}) (rewrite (decompose-along-reduction.different-weakening.equate-sublists.commute-skip {A} {a} _ (SubList.extend-left-single (sublist-match idp SubList.identity))) (transport-lemma (SubList (a1 :: context-b ++ context-c)) (:: a) _ _))
  \where {
    \func transport-lemma {A B : \Type} (C : B -> \Type) (map : A -> B) {a a' : A} (eq : a = a') (x : C (map a')) : transport C (pmap map (inv eq)) x = transport C (inv (path (\lam i => map (eq @ i)))) x \elim eq
      | idp => idp

    \func inv' {A : \Type} {context-a context-b context-c : List A}
      : (SubList.extend-left-single SubList.identity) = transport (SubList (context-b ++ context-c)) (++-assoc) (SubList.extend-right-both (SubList.extend-left-single (SubList.identity {_} {context-b}) {context-a}) {context-c}) =>
      inv (transport_id_inv (SubList (context-b ++ context-c)) ++-assoc _) *> (pmap (transport (SubList (context-b ++ context-c)) (++-assoc)) (inv weakening-over-double-extend))
  }


\func weakening-over-double-extend-2 {A : \Type} {context-a context-b context-c : List A}
  : (SubList.extend-right-single (SubList.extend-right-single (SubList.identity {_} {context-a}) {context-b}) {context-c}) = transport (SubList (context-a)) (inv ++-assoc) (SubList.extend-right-single SubList.identity) \elim context-a, context-b, context-c
  | nil, context-b, context-c => extension-lemma
  | :: a context-a, context-b, context-c => rewrite (weakening-over-double-extend-2 {_} {context-a}) (rewrite decompose-along-reduction.different-weakening.equate-sublists-2.commute-match idp)
  \where {
    \func extension-lemma {A : \Type} {context-a context-b : List A}
      : SubList.extend-right-single SubList.sublist-trivial-skip {context-b} = SubList.sublist-trivial-skip {_} {context-a ++ context-b} \elim context-a, context-b
      | nil, context-b => idp
      | :: a context-a, context-b => pmap sublist-skip extension-lemma

    \func inv' {A : \Type} {context-a context-b context-c : List A}
      : (SubList.extend-right-single SubList.identity) = transport (SubList (context-a)) (++-assoc) (SubList.extend-right-single (SubList.extend-right-single (SubList.identity {_} {context-a}) {context-b}) {context-c}) =>
      inv (transport_id_inv (SubList (context-a)) ++-assoc _) *> (pmap (transport (SubList (context-a)) (++-assoc)) (inv weakening-over-double-extend-2))
  }

\func weakening-over-double-extend-3 {A : \Type} {context-a context-b context-c : List A}
  : SubList.sublist-trivial-skip {_} {context-a ++ context-b ++ context-c} = transport (SubList nil) ++-assoc (SubList.extend-right-single (SubList.sublist-trivial-skip {_} {context-a ++ context-b}) {context-c})
\elim context-a, context-b, context-c
  | nil, nil, context-c => idp
  | nil, :: a context-b, context-c => rewrite (weakening-over-double-extend-3 {_} {nil} {context-b} {context-c}) idp
  | :: a context-a, context-b, context-c => rewrite (weakening-over-double-extend-3 {_} {context-a} {context-b} {context-c}) (rewrite decompose-along-reduction.different-weakening.equate-sublists.commute-skip idp)
  \where {
    \func transport-lemma {A B : \Type} (C : B -> \Type) (map : A -> B) {a a' : A} (eq : a = a') (x : C (map a)) : transport C (pmap map (eq)) x = transport C ((path (\lam i => map (eq @ i)))) x \elim eq
      | idp => idp
  }

\func weakening-over-double-extend-4 {A : \Type} {context-a context-b context-c context-d : List A}
  (sublist : SubList context-c context-d)
  : SubList.extend-right-both (SubList.extend-right-both sublist {context-b}) {context-a} = transport (SubList __ ((context-d ++ context-b) ++ context-a)) (inv ++-assoc) (transport (SubList (context-c ++ context-b ++ context-a)) (inv ++-assoc) (SubList.extend-right-both sublist {context-b ++ context-a}))
  \elim context-b, context-c, context-d, sublist
    | context-b, nil, nil, sublist-trivial => SubList.extend-right-identity-eq
    | context-b, :: x context-c, :: y context-d, sublist-match idp sublist => rewriteI (pmap_inv-comm (y ::) (++-assoc)) (rewriteI (pmap_inv-comm (x ::) (++-assoc)) (rewriteI (decompose-along-reduction.different-weakening.equate-sublists-2.commute-match-straight (inv ++-assoc) (SubList.extend-right-both sublist)) (rewriteI decompose-along-reduction.different-weakening.equate-sublists-2.commute-match-straight-2 (pmap (sublist-match idp) (weakening-over-double-extend-4 sublist)))))
    | nil, nil, :: y context-d, sublist-skip sublist => rewriteI (pmap_inv-comm (y ::) (++-assoc {A} {context-d} {nil} {context-a})) ((rewriteI decompose-along-reduction.different-weakening.equate-sublists.commute-skip ((pmap (sublist-skip) (weakening-over-double-extend-4 sublist)))))
    | :: a context-b, nil, :: y context-d, sublist-skip sublist => rewriteI (pmap_inv-comm (y ::) (++-assoc {A} {context-d} {a :: context-b} {context-a})) (rewriteI decompose-along-reduction.different-weakening.equate-sublists.commute-skip ((pmap (sublist-skip) (weakening-over-double-extend-4 sublist))))
    | context-b, :: a context-c, :: y context-d, sublist-skip sublist => rewrite (weakening-over-double-extend-4 sublist) (rewriteI (pmap_inv-comm (y ::) (++-assoc)) (rewriteI (pmap_inv-comm (a ::)) (rewriteI decompose-along-reduction.different-weakening.equate-sublists.commute-skip (rewriteI decompose-along-reduction.different-weakening.equate-sublists.commute-skip-2 idp))))

\lemma expand-substitution-3 {env : FSignature} {term-context ms-context big-context big-context' : List Sort} {s : Sort} {ms ms' : MetaContext Sort}
                             (T : Term env term-context s ms)
                             (msubst : MetaSubstitution env ms-context ms ms')
                             (sublist : SubList term-context big-context)
                             (sublist' : SubList ms-context big-context)
                             (S : Term env big-context' s ms')
                             (eq : big-context' = big-context)
                             (target : MetaSubstitution.apply (weakening T sublist) sublist' msubst = transport (Term env __ s ms') eq S)
  : MetaSubstitution.apply (weakening T (transport (SubList term-context) (inv eq) sublist)) (transport (SubList ms-context) (inv eq) sublist') msubst = S \elim eq
  | idp => target

\lemma apply-modularity-colored
  {tc : TheoremContext} {context subst-context pattern-context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} {n : Nat} {index : Fin n}
  (color : Color)
  (producer : Fin n -> MetaContext Sort')
  (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) mc)
  (sublist : SubList subst-context context)
  (pat-sublist : SubList pattern-context context)
  (t : Term (colored-env color) pattern-context s (producer index)) :
  MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color t) pat-sublist) sublist (substitutions index) = MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color (LinearPattern.upgrade-metavariables-p {colored-env color} producer t)) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim color, t
  | red, var index1 p => idp
  | red, metavar m choosing => pmap (\lam e => Substitution.apply {env} (substitutions index m) (extend-substitution-left {env} sublist e)) (ext (\lam i => apply-modularity-colored red producer substitutions sublist pat-sublist (choosing i)))
  | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam i => apply-modularity-colored red producer substitutions (SubList.extend-right-single sublist) (SubList.extend-right-both pat-sublist) (choosing i)))
  | blue, var index1 p => idp
  | blue, metavar m choosing => pmap (\lam e => Substitution.apply {env} (substitutions index m) (extend-substitution-left {env} sublist e)) (ext (\lam i => apply-modularity-colored blue producer substitutions sublist pat-sublist (choosing i)))
  | blue, func f choosing => pmap (func {env} (inr f)) (ext (\lam i => apply-modularity-colored blue producer substitutions (SubList.extend-right-single sublist) (SubList.extend-right-both pat-sublist) (choosing i)))
