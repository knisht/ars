\import Data.List (++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Substitutions
\import TRS.Union
\import TRS.Utils
\open Confluence
\open Confluence.TheoremContext

\func join-tlcrs {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                 (color : Color)
                 (A B C : Term env context s meta-signature)
                 (A~>B : TClosure (TopLevelColoredReduction color) A B)
                 (A~>C : TClosure (TopLevelColoredReduction color) A C)
                 (monochrome-confluence : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : \Sigma (X : Term env context s meta-signature) (TClosure (TopLevelColoredReduction color) B X) (TClosure (TopLevelColoredReduction color) C X) =>
  \let | (a, subst, eq-a, root-colors) => decompose-term color A
       | inner-ms => LinearMetasignatureT {colored-env color} a
       | (b, eq-b, a~>b) => unify-top.iterate-decomposition (LinearTerm.convert-to-term {colored-env color} a) subst B eq-a A~>B root-colors
       | (c, eq-c, a~>c) => unify-top.iterate-decomposition (LinearTerm.convert-to-term {colored-env color} a) subst C eq-a A~>C root-colors
       | join-b-c : StraightJoin b c (TClosure (monochrome-reduction color {_} {_} {inner-ms})) => join-monochrome-terms color {_} {_} {inner-ms} (LinearTerm.convert-to-term {colored-env color} a) b c a~>b a~>c monochrome-confluence
       | injected-reduct => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} join-b-c.common-reduct) sublist-trivial subst
       | lifted-b~>d => TClosure.lift (\lam x => (MetaSubstitution.apply {env} (inject-monochrome-term color x) sublist-trivial subst)) (\lam rel => lift-relation color subst rel) join-b-c.a common-reduct join-b-c.a~>cr
       | lifted-c~>d => TClosure.lift (\lam x => (MetaSubstitution.apply {env} (inject-monochrome-term color x) sublist-trivial subst)) (\lam rel => lift-relation color subst rel) join-b-c.b common-reduct join-b-c.b~>cr
  \in (injected-reduct, transport (TClosure (TopLevelColoredReduction color) __ injected-reduct) eq-b lifted-b~>d, transport (TClosure (TopLevelColoredReduction color) __ injected-reduct) eq-c lifted-c~>d)

\func lift-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature outer-meta-signature : MetaSignature Sort'}
                    (color : Color)
                    (subst : MetaSubstitution env nil meta-signature outer-meta-signature)
                    {t u : Term (colored-env color) context s meta-signature}
                    (t~>u : monochrome-reduction color t u)
  : TopLevelColoredReduction color
    (MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist-trivial subst)
    (MetaSubstitution.apply {env} (inject-monochrome-term color u) sublist-trivial subst) \elim t, u, t~>u
  | t, u, rewrite-with-rule ((rule,bsubst,l[bs]=injt,r[bs]=inju)) i => rewrite-with-rule-colored {?} {?}
  | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f p r => {?}
  | metavar m-A choosing-A, metavar m-B choosing-B, rewrite-with-parameter-m p r => {?}

\func decompose-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                     (color : Color)
                     (A : Term env context s meta-signature) :
  \Sigma (t : LinearTerm (colored-env {tc} color) context s)
         (subst : MetaSubstitution env nil (LinearMetasignatureT {colored-env color} t) meta-signature)
         (MetaSubstitution.apply {env} (inject-monochrome-term color (LinearTerm.convert-to-term {colored-env color} t)) sublist-trivial subst = A)
         (\Pi {s : Sort'} (m : metaname {LinearMetasignatureT {colored-env color} t} s) -> HasColoredRoot (Color.flip color) (subst m)) \elim color, A
  | color, var index p => (lt-var index p, \lam {s1} mvar => contradiction, \case \elim color \with {
    | red => idp
    | blue => idp
  }, \lam {s1} m => contradiction)
  | color, metavar m choosing =>
    \let | inner-results i => decompose-term color (choosing i)
         | signature-producer i => LinearMetasignatureT {colored-env color} (inner-results i).1
         | unified-metasignature => PointedModularMetaSignature {colored-env color} s (m-domain m) signature-producer
         | unified-substitution : MetaSubstitution env nil unified-metasignature meta-signature =>
           \lam {s'} m => \case \elim m \with {
             | inl s'=s => \case \elim s', \elim s'=s \with {
               | s', idp => rewrite ++_nil (metavar m (\lam i => var i idp))
             }
             | inr m => (inner-results m.1).2 m.2
           }
    \in (lt-metavar (m-domain m) (\lam i => (inner-results i).1),
         unified-substitution,
         {?},
         \lam {s1} m1 => {?}) -- provable, technical
  | red, func (inl f) choosing =>
    \let | inner-results i => decompose-term red (choosing i)
         | signature-producer i => LinearMetasignatureT {colored-env red} (inner-results i).1
         | unified-metasignature => ModularMetaSignature {env} signature-producer
         | unified-substitution : MetaSubstitution env nil unified-metasignature meta-signature => \lam m => (inner-results m.1).2 m.2
    \in (lt-func f (\lam i => (inner-results i).1),
         unified-substitution,
         pmap (func {env} (inl f)) (ext (\lam index => ({?}) *> (inner-results index).3)),
         \lam {s1} m => ((inner-results m.1).4 m.2))
  | red, func (inr f) choosing => (lt-full-metavar {colored-env red}, \lam {s1} mvar => rewrite ++_nil (\case \elim s1, \elim mvar \with {
    | s1, idp => (func {env} (inr f) choosing)
  }), inv (apply-subst-with-extended-identity-inv {env} (func (inr f) choosing) (plain-identity {env})) *> (pmap (func {env} (inr f)) (ext (\lam index => {?}))), \lam {s1} m => {?})
  | blue, func (inl f) choosing => {?}
  | blue, func (inr b) choosing => {?}

\func join-monochrome-terms {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                            (a b c : Term (colored-env color) context s meta-signature)
                            (a~>b : TClosure (monochrome-reduction color) a b)
                            (a~>c : TClosure (monochrome-reduction color) a c)
                            (conf : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin b c (TClosure (monochrome-reduction color)) \elim color
  | red => conf a b c a~>b a~>c
  | blue => conf a b c a~>b a~>c

\func decompose-along-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
                                (color : Color)
                                (t : Term (colored-env {tc} color) context s inner-meta-signature)
                                (B : Term env context s meta-signature)
                                (subst : MetaSubstitution env nil (inner-meta-signature) meta-signature)
                                (root-colors : \Pi {s : Sort'} (m : inner-meta-signature.metaname s) -> HasColoredRoot (Color.flip color) (subst m))
                                (A~>B : TopLevelColoredReduction color (MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist-trivial subst) B)
  : \Sigma (u : Term (colored-env color) context s (inner-meta-signature))
           (MetaSubstitution.apply {env} (inject-monochrome-term color u) sublist-trivial subst = B)
           (monochrome-reduction color t u) \elim color, t, B, A~>B
  | red, func f choosing, func (inl f') choosing', rewrite-with-parameter-f-colored p _ step => {?}
  | red, func f choosing, B, rewrite-with-rule-colored _ ((rule : LinearRewriteRule), big-subst, l[bs]=injt, r[bs]=B) =>
    \let | pattern => uninject-linear-pattern red rule.linear-pattern
         | linear-ms-eq : LinearMetasignature {envL} pattern = LinearMetasignature {env} (rule.linear-pattern) => {?}
         | unlarge-metasubst => transport (\lam (x : MetaSignature (Sort {env})) => MetaSubstitution env context x meta-signature) (inv linear-ms-eq) big-subst
         | modified-eq : MetaSubstitution.apply {env}
             (weakening {env} (inject-monochrome-term red (LinearPattern.convert-to-term {envL} pattern)) sublist-trivial) SubList.identity unlarge-metasubst
           = MetaSubstitution.apply {env} (inject-monochrome-term red (func f choosing)) sublist-trivial subst
         => {?} *> l[bs]=injt -- a bit technical
         | (middle-subst, substitution-equality, l-eq) => decompose-metasubstitution red sublist-trivial SubList.identity idp pattern (func f choosing) unlarge-metasubst subst modified-eq root-colors
         | monochrome-r => transport (Term envL nil s) (inv linear-ms-eq) (uninject-term red rule.r)
         | term-u => MetaSubstitution.apply {envL} (weakening {envL} monochrome-r sublist-trivial) SubList.identity middle-subst
         | coh => coherent-application {env} (inv linear-ms-eq) big-subst rule.r
         | colored-coherence => colored-metacomposition red middle-subst subst unlarge-metasubst substitution-equality SubList.identity (weakening {envL} monochrome-r sublist-trivial)
    \in (term-u, (inv colored-coherence) *> (pmap (MetaSubstitution.apply {env} __ SubList.identity unlarge-metasubst) {?}) *> (inv coh) *> r[bs]=B, produce-monochrome-reduction red pattern monochrome-r middle-subst (func f choosing) term-u l-eq idp)
  | red, metavar m choosing, B, A~>B =>
    \let
      | other-root-color => root-colors m
      | root-color => TopLevelColoredReduction.extract-root-coloring A~>B
      | empty : Empty => eliminate-colors {tc} (blue) other-root-color root-color
    \in contradiction
  | red, var index p, B, A~>B => \let rc => TopLevelColoredReduction.extract-root-coloring A~>B \in \case \elim rc \with {
  }
  | red, func f choosing, func (inr s1) choosing1, rewrite-with-parameter-f-colored p p1 r => contradiction
  | blue, t, B, A~>B => {?}
  \where {
    \func eliminate-colors {tc : TheoremContext} (color : Color) {context context' : List Sort'} {s : Sort'} {msig : MetaSignature Sort'}
      {T : Term env context s msig} {subst : Substitution {env} context context' msig} (hcr : HasColoredRoot color T) (hcr' : HasColoredRoot (Color.flip color) (Substitution.apply {env} T subst))
      : Empty \elim color, T, hcr, hcr'
      | red, func (inl s1) choosing, red-func-root, ()
      | blue, var index p, (), hcr'
      | blue, metavar m choosing, (), hcr'
      | blue, func f choosing1, hcr, hcr' => \let | eq => (inv (HasColoredRoot.reorganize red hcr')) *> HasColoredRoot.reorganize blue hcr
                                             \in contradiction
  }

\func coherent-application {env : Environment} {context  : List Sort} {inner-meta-signature meta-signature inner-meta-signature' : MetaSignature Sort}
                           (metasig-eq : inner-meta-signature = inner-meta-signature')
                           (subst : MetaSubstitution env context inner-meta-signature meta-signature)
                           {s : Sort}
                           (T : Term env nil s inner-meta-signature)
  : MetaSubstitution.apply (weakening T sublist-trivial) SubList.identity subst = MetaSubstitution.apply {_} {_} {_} {_} {inner-meta-signature'} (weakening (rewriteI metasig-eq T) sublist-trivial) SubList.identity (rewriteI metasig-eq subst) \elim inner-meta-signature, metasig-eq
  | metasig, idp => idp

\func produce-monochrome-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                                   (pattern : LinearPattern (colored-env color) nil s)
                                   (rule-r : Term (colored-env color) nil s (LinearMetasignature {colored-env color} pattern))
                                   (subst : MetaSubstitution (colored-env color) context (LinearMetasignature {colored-env color} pattern) meta-signature)
                                   (l r : Term (colored-env color) context s meta-signature)
                                   (l-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} pattern) sublist-trivial) SubList.identity subst = l)
                                   (r-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} rule-r sublist-trivial) SubList.identity subst = r)
  : monochrome-reduction color l r \elim color
  | red => rewrite-with-rule (\new RewriteStep {
    | rule => \new LinearRewriteRule {
      | linear-pattern => pattern
      | r => rule-r
      | l-is-func => {?} -- easy
    }
    | substitution => subst
    | left-coherence => l-eq
    | right-coherence => r-eq
  }) {?} -- easy
  | blue => {?} -- same as above

\func uninject-linear-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                              (l : LinearPattern env context s)
  : LinearPattern (colored-env color) context s \elim color, l
  | red, lp-func (inl f) choosing => lp-func f (\lam index => uninject-linear-pattern red (choosing index))
  | blue, lp-func (inr f) choosing => lp-func f (\lam index => uninject-linear-pattern blue (choosing index))
  | color, lp-metavar => lp-metavar {colored-env color}
  | red, lp-func (inr b) choosing => {?}
  | blue, lp-func (inl a) choosing => {?}

\func inject-linear-pattern {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                            (l : LinearPattern (colored-env color) context s) : LinearPattern env context s \elim color, l
  | red, lp-func f choosing => lp-func (inl f) (\lam i => inject-linear-pattern red (choosing i))
  | color, lp-metavar => lp-metavar {env}
  | blue, lp-func f choosing => lp-func (inr f) (\lam i => inject-linear-pattern blue (choosing i))

\func inject-linear-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                         (l : LinearTerm (colored-env color) context s) : LinearTerm env context s \elim color, l
  | red, lt-func f choosing => lt-func (inl f) (\lam i => inject-linear-term red (choosing i))
  | blue, lt-func f choosing => lt-func (inr f) (\lam i => inject-linear-term blue (choosing i))
  | color, lt-metavar params choosing => lt-metavar params (\lam i => inject-linear-term color (choosing i))
  | color, lt-full-metavar => lt-full-metavar {env}
  | color, lt-var index p => lt-var index p
  \where {
    \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} (l : LinearTerm env context s) \elim l
      | lt-func f choosing =>
      lt-witness-f (color-of-root {tc} f = color)
                   (\Pi (i : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> InjectionWitness {tc} color (choosing i))
      | lt-metavar params choosing =>
      lt-witness-m (\Pi (i : Fin (length params)) -> InjectionWitness {tc} color (choosing i))
      | lt-var _ _ => lt-witness-v
      | lt-full-metavar => lt-witness-fm

    \func generate-injection-witness {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                                     (l : LinearTerm (colored-env color) context s) : InjectionWitness color (inject-linear-term color l) \elim color, l
      | red, lt-func f choosing => lt-witness-f idp (\lam i => generate-injection-witness red (choosing i))
      | blue, lt-func f choosing => lt-witness-f idp (\lam i => generate-injection-witness blue (choosing i))
      | red, lt-metavar params choosing => lt-witness-m (\lam i => generate-injection-witness red (choosing i))
      | blue, lt-metavar params choosing => lt-witness-m (\lam i => generate-injection-witness blue (choosing i))
      | red, lt-full-metavar => lt-witness-fm
      | blue, lt-full-metavar => lt-witness-fm
      | red, lt-var index p => lt-witness-v
      | blue, lt-var index p => lt-witness-v

    \func extract-from-witness {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color) (f : env.FunctionalSymbol.symbol s)
                               (choosing :  \Pi (index : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> LinearTerm env (f FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index ++ context) (f FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index))
                               (witness : InjectionWitness color (lt-func {env} f choosing))
                               : \Sigma (\Pi (i : Fin (length (domain {FunctionalSymbol {env {tc}}} f))) -> InjectionWitness {tc} color (choosing i)) (color-of-root f = color) \elim color, witness
      | color, lt-witness-f p _x => (_x, p)
  }

\func uninject-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'} (color : Color)
                    (t : Term env context s meta-signature)
  : Term (colored-env color) context s meta-signature => {?}

\func colored-metacomposition {tc : TheoremContext} {global-context : List Sort'} {ms-a ms-b ms-c : MetaSignature Sort'}
                              (color : Color)
                              (subst-a : MetaSubstitution (colored-env color) global-context ms-a ms-b)
                              (subst-b : MetaSubstitution env nil ms-b ms-c)
                              (subst-c : MetaSubstitution env global-context ms-a ms-c)
                              (eq : \Pi {s : Sort'} (m : ms-a.metaname s) -> subst-c m = MetaSubstitution.apply {env} (inject-monochrome-term color (subst-a m)) (sublist-trivial) subst-b)
                              {context : List Sort'} {s : Sort'} (sublist : SubList global-context context) (t : Term (colored-env color) context s ms-a)
  : MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term color (MetaSubstitution.apply {colored-env color} t sublist subst-a)) sublist-trivial subst-b \elim color, t
  | red, var index p => idp
  | red, metavar m choosing =>
    \let | inner i : MetaSubstitution.apply {env} (inject-monochrome-term red (choosing i)) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (choosing i) sublist subst-a)) sublist-trivial subst-b => colored-metacomposition red subst-a subst-b subst-c eq sublist (choosing i)
         | inner-ext : (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (choosing i)) sublist subst-c) = (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (choosing i) sublist subst-a)) sublist-trivial subst-b) => ext inner
    \in rewrite (eq m) (inv (rewrite inner-ext (rewrite twist-application (commutation sublist subst-b (\lam i => MetaSubstitution.apply {envL} (choosing i) sublist subst-a) (subst-a m)))))
  | red, func f choosing => pmap (func {env} (inl f)) (ext (\lam index => (colored-metacomposition red subst-a subst-b subst-c eq (SubList.extend-right-single-left sublist) (choosing index)) *> invariant-through-empty-subst {env} subst-b sublist-trivial (SubList.extend-right-single-left sublist-trivial) _))
  | blue, t => {?} -- completely symmetrical
  \where {
    \func commutation {tc : TheoremContext} {global-context inner-context context : List Sort'} {s : Sort'} {ms-a ms-b : MetaSignature Sort'}
                      (sublist : SubList global-context context)
                      (metasubst : MetaSubstitution env nil ms-a ms-b)
                      (subst : Substitution {envL} inner-context context ms-a)
                      (T : Term envL (inner-context ++ global-context) s ms-a)
      :
      MetaSubstitution.apply {env}
          (Substitution.apply {env} (Injections.inject-term-left envL envR T) (\lam i => Injections.inject-term-left envL envR (extend-substitution-right {envL} sublist subst i)))
          sublist-trivial
          metasubst =
      Substitution.apply {env}
          (MetaSubstitution.apply {env} (Injections.inject-term-left envL envR T) (sublist-trivial) metasubst)
          (extend-substitution-right {env} sublist
              (\lam i => MetaSubstitution.apply {env} (Injections.inject-term-left envL envR (subst i)) sublist-trivial metasubst)) \elim T
      | var index p => \case \elim s, \elim p \with {
        | s, idp => {?}
      }
      | metavar m choosing => {?}
      | func f choosing => pmap (func {env} (inl f)) (ext (\lam index => {?}))

    \func twist-application
      {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {ms : MetaSignature Sort'}
      (t : Term envL context s ms) (subst : Substitution {envL} context context' ms)
      : Injections.inject-term-left envL envR (Substitution.apply {envL} t subst) = Substitution.apply {env} (Injections.inject-term-left envL envR t) (\lam i => Injections.inject-term-left envL envR (subst i)) \elim t
      | var index p => \case \elim s, \elim p \with {
        | s, idp => idp
      }
      | metavar m choosing => pmap (metavar {env} m) (ext (\lam index => twist-application (choosing index) subst))
      | func f choosing => pmap (func {env} (inl f)) (ext (\lam index => {?})) -- push append-context-left further
  }

\func decompose-metasubstitution
  {tc : TheoremContext} {pattern-context context core-context : List Sort'} {s : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
  (color : Color)
  (sublist : SubList pattern-context context)
  (sublist-core : SubList core-context context)
  (context-eqs : pattern-context ++ core-context = context)
  (l : LinearPattern (colored-env color) pattern-context s)
  (t : Term (colored-env color) context s inner-meta-signature)
  (big-substitution : MetaSubstitution env core-context (LinearMetasignature {colored-env color} l) meta-signature)
  (middle-substitution : MetaSubstitution env nil inner-meta-signature meta-signature)
  (eq :
  MetaSubstitution.apply {env}
      (weakening {env} (inject-monochrome-term color (LinearPattern.convert-to-term {colored-env color} l)) sublist)
      sublist-core big-substitution =
  MetaSubstitution.apply {env}
      (inject-monochrome-term color t)
      sublist-trivial
      middle-substitution)
  (root-colors : \Pi {s : Sort'} (m : inner-meta-signature.metaname s) -> HasColoredRoot (Color.flip color) (middle-substitution m))
  : \Sigma (inner-substitution : MetaSubstitution (colored-env color) core-context (LinearMetasignature {colored-env color} l) inner-meta-signature)
           (\Pi {s : Sort'} (m : metaname {LinearMetasignature {colored-env color} l} s) ->
               big-substitution m = MetaSubstitution.apply {env} (inject-monochrome-term color (inner-substitution m)) sublist-trivial middle-substitution)
           (MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (LinearPattern.convert-to-term {colored-env color} l) sublist) sublist-core inner-substitution = t) \elim color, l, t, eq
  | red, lp-func f choosing, metavar m choosing1, eq =>
    \let | opposite-color-for-m => root-colors m
         | colored-root-for-f : HasColoredRoot red (func (inl f)
             (\lam i => MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left tc.envL tc.envR (LinearPattern.upgrade-metavariables-p {envL}
                 (\lam i => LinearMetasignature {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing i))))
                 (SubList.extend-left sublist)) (SubList.extend-right-single-left sublist-core) big-substitution)) => red-func-root
         | colored-root-for-m : HasColoredRoot red (Substitution.apply {env} (middle-substitution m) (extend-substitution-right {env} sublist-trivial
             (\lam i => MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR (choosing1 i)) sublist-trivial middle-substitution))) => rewriteI eq colored-root-for-f
         | empty => decompose-along-reduction.eliminate-colors blue opposite-color-for-m colored-root-for-m
    \in contradiction
  | red, lp-func f choosing, func f1 choosing1, eq =>
    \let | f-eq : f = f1 => {?}
    \in \case \elim f, \elim f-eq, \elim choosing, \elim big-substitution, \elim eq \with {
      | f, idp, choosing, big-substitution, eq =>
        \let | args-eq : (\lam i => MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (LinearPattern.upgrade-metavariables-p {envL}
            (\lam i => LinearMetasignature {envL} (choosing i)) (LinearPattern.convert-to-term {envL} (choosing i))))
            (SubList.extend-left sublist)) (SubList.extend-right-single-left sublist-core) big-substitution) = (\lam i => MetaSubstitution.apply {env}
            (Injections.inject-term-left envL envR (choosing1 i)) (SubList.extend-right-single-left sublist-trivial)
            middle-substitution) => ext (\lam i => {?})
             | inductive i => decompose-metasubstitution red
                 (SubList.extend-left sublist)
                 (SubList.extend-right-single-left sublist-core)
                 (rewrite ++-assoc (pmap ((domain f1 Data.List.!! i).1 ++ __) context-eqs))
                 (choosing i)
                 (choosing1 i)
                 (\lam m => big-substitution (i, m)) middle-substitution ({?} *> (pmap (__ i) args-eq) *> {?})
                 root-colors
        \in (\lam {s1} mvar => (inductive mvar.1).1 mvar.2, \lam {s1} m => (inductive m.1).2 m.2, pmap (func {envL} f1) (ext (\lam index => {?}))) -- technical lemma about wrapping linear signature
    }
  | red, lp-metavar, t, eq =>
    (\lam {s1} mvar => transport2 (\lam ctx sort => Term envL ctx sort inner-meta-signature) (inv context-eqs) mvar t,
     \lam {s1} m => \case \elim s, \elim context, \elim context-eqs, \elim sublist, \elim sublist-core, \elim t, \elim big-substitution, \elim eq, \elim m \with {
       | s, context, idp, sublist, sublist-core, t, big-substitution, eq, idp => run {
         rewriteI (plain-identity-effect {env}),
         rewriteI (weakening-extension-ext {env} sublist-core sublist),
         eq
       }
     },
     \case \elim context, \elim context-eqs, \elim sublist, \elim sublist-core, \elim t \with {
       | context, idp, sublist, sublist-core, t => rewrite (weakening-extension-ext {colored-env red} sublist-core sublist) (plain-identity-effect {envL} _)
     } )
  -- symmetrical
  | blue, _, _, _ => {?}

\func weakening-extension-ext {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                          (sublist : SubList right-context (left-context ++ right-context))
                          (sublist' : SubList left-context (left-context ++ right-context)) : extend-substitution-right {_} {_} {_} {_} {meta-signature} sublist (\lam i => weakening (var i idp) sublist') = plain-identity =>
  ext (weakening-extension sublist sublist')

\func weakening-extension {env : Environment} {left-context right-context : List Sort} {meta-signature : MetaSignature Sort}
                          (sublist : SubList right-context (left-context ++ right-context))
                          (sublist' : SubList left-context (left-context ++ right-context)) (i : Fin (length (left-context ++ right-context)))
  : extend-substitution-right sublist (\lam i => weakening (var i idp) sublist') i = plain-identity {_} {_} {meta-signature} i \elim left-context, i
  | nil, i => {?} -- sublist is identity
  | :: a left-context, 0 => \case \elim sublist' \with {
    | sublist-match p sublist' => rewrite (Path.inProp p idp) idp
    | sublist-skip sublist' => {?} -- maybe smth about exclusive sublists?
  }
  | :: a left-context, suc i => \let inductive => weakening-extension {_} {_} {_} {meta-signature} sublist sublist' i \in {?}

