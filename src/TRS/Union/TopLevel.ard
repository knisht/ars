\import Data.List (!!, ++, ++-assoc, ++_nil, ::, List, length, nil)
\import Data.Or
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set \hiding (#)
\import TRS.Data.Fin
\import TRS.Data.Shifts
\import TRS.Data.SubList
\import TRS.HRS
\import TRS.Linearity
\import TRS.MetaContexts
\import TRS.Substitutions
\import TRS.Union
\import TRS.Union.Colors
\import TRS.Union.Confluence
\import TRS.Union.Embedding
\import TRS.Utils
\import TRS.Data.SubList
\open TheoremContext

\func join-tlcrs
  {tc : TheoremContext} {context : List Sort'} {s : Sort'}
  (color : Color)
  (A B C : PureTerm TheoremContext.env context s)
  (A~>B : TClosure (TopLevelColoredReduction color {EmptyMetaContext {env}} {context} {s}) A B)
  (A~>C : TClosure (TopLevelColoredReduction color {EmptyMetaContext {env}} {context} {s}) A C)
  (monochrome-confluence : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  (all-rules-are-linear : LinearDump)
  : \Sigma (X : PureTerm env context s) (TClosure (TopLevelColoredReduction color) B X) (TClosure (TopLevelColoredReduction color) C X) =>
  \let | (a, subst, eq-a, root-colors) => decompose-term color A
       | inner-ms => LinearMetaContext {colored-env color} a
       | (b, eq-b, a~>b) => unify-top.iterate-decomposition (Linear.convert-to-term {colored-env color} a) subst B (rewrite unify-top.unwrap-injection eq-a) A~>B root-colors
       | (c, eq-c, a~>c) => unify-top.iterate-decomposition (Linear.convert-to-term {colored-env color} a) subst C (rewrite unify-top.unwrap-injection eq-a) A~>C root-colors
       | join-b-c : StraightJoin b c (TClosure (\lam x y => \Sigma (rd : monochrome-reduction color x y) (FunctionalWitness {colored-env color} {colored-set-of-rules color} rd))) => join-monochrome-terms color {_} {_} {inner-ms} (Linear.convert-to-term {colored-env color} a) b c (TClosure.lift (\lam t => t) (\lam rel => rel.1) _ _ a~>b) (TClosure.lift (\lam t => t) (\lam rel => rel.1) _ _ a~>c) monochrome-confluence
       | injected-reduct => MetaSubstitution.apply {env} {_} {_} {_} {inner-ms} (inject-monochrome-term color {_} {_} {inner-ms} join-b-c.common-reduct) SubList.sublist-trivial-free subst
       | lifted-b~>d => TClosure.lift (\lam x => (MetaSubstitution.apply {env} (inject-monochrome-term color x) SubList.sublist-trivial-free subst)) (\lam rel => lift-relation color subst rel.1 rel.2 all-rules-are-linear) join-b-c.a common-reduct join-b-c.a~>cr
       | lifted-c~>d => TClosure.lift (\lam x => (MetaSubstitution.apply {env} (inject-monochrome-term color x) SubList.sublist-trivial-free subst)) (\lam rel => lift-relation color subst rel.1 rel.2 all-rules-are-linear) join-b-c.b common-reduct join-b-c.b~>cr
  \in (injected-reduct, transport (TClosure (TopLevelColoredReduction color) __ injected-reduct) eq-b lifted-b~>d, transport (TClosure (TopLevelColoredReduction color) __ injected-reduct) eq-c lifted-c~>d)

\func lift-relation
  {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
  (color : Color)
  (subst : MetaSubstitution env nil mc (EmptyMetaContext {env}))
  {t u : Term (colored-env color) context s mc}
  (t~>u : monochrome-reduction color t u)
  (fw : FunctionalWitness {colored-env color} {colored-set-of-rules color} t~>u)
  (all-rules-are-linear : LinearDump)
  : TopLevelColoredReduction color {_} {context} {s}
    (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-free subst)
    (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.sublist-trivial-free subst)
\elim color, t, u, t~>u, fw
  | red, t, u, rewrite-with-rule idx sort-eqs msubst msubst[l]=t msubst[r]=u, fw =>
    \let | (lp, meq, lcoh) => all-rules-are-linear (inl idx)
         | (uninjected-r, inject-uninj) => break-down-rule (inl idx)
         | (new-lp, new-r, composed, new-lcoh, new-rcoh, new-meq, new-lcx, new-rcx, new-fr, t-coloring) => untransport red lp meq sort-eqs msubst subst _ _ t u msubst[l]=t msubst[r]=u lcoh (RewriteRule.l-is-func {get {tc.L-rules} idx})
    \in rewrite-with-rule-colored t-coloring new-lp new-r new-fr composed new-lcoh new-rcoh (inl idx) sort-eqs new-meq new-lcx new-rcx
  | blue, t, u, rewrite-with-rule idx sort-eqs msubst msubst[l]=t msubst[r]=u, fw =>
    \let | (lp, meq, lcoh) => all-rules-are-linear (inr idx)
         | (uninjected-r, inject-uninj) => break-down-rule (inr idx)
         | (new-lp, new-r, composed, new-lcoh, new-rcoh, new-meq, new-lcx, new-rcx, new-fr, t-coloring) => untransport blue lp meq sort-eqs msubst subst _ _ t u msubst[l]=t msubst[r]=u lcoh (RewriteRule.l-is-func {get {tc.R-rules} idx})
    \in rewrite-with-rule-colored t-coloring new-lp new-r new-fr composed new-lcoh new-rcoh (inr idx) sort-eqs new-meq new-lcx new-rcx
  | red, func f-A arguments-A, func f-B arguments-B, rewrite-with-parameter-f idp index rd eq, param-rewriting fw =>
    rewrite-with-parameter-f-colored idp idp index
        (rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) (SubList.sublist-trivial-free)) (transport (\lam sl => TopLevelColoredReduction red (MetaSubstitution.apply {env}
            (Injections.inject-term-left envL envR (arguments-A index)) SubList.sublist-trivial-free subst)
            ((MetaSubstitution.apply {env}
                (Injections.inject-term-left envL envR (arguments-B index)) (sl)
                subst))) (trivial-sublist-contractible (SubList.sublist-trivial-free) (SubList.extend-right-single SubList.sublist-trivial-free) ) (lift-relation red subst rd fw all-rules-are-linear)))
        (\lam j _x => rewrite (eq j _x) idp)
  | blue, func f-A arguments-A, func f-B arguments-B, rewrite-with-parameter-f idp index rd eq, param-rewriting fw =>
    rewrite-with-parameter-f-colored idp idp index
        (rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) (SubList.sublist-trivial-free)) (transport (\lam sl => TopLevelColoredReduction blue (MetaSubstitution.apply {env}
            (inject-monochrome-term blue (arguments-A index)) SubList.sublist-trivial-free subst)
            ((MetaSubstitution.apply {env}
                (inject-monochrome-term blue (arguments-B index)) (sl)
                subst))) (trivial-sublist-contractible (SubList.sublist-trivial-free) (SubList.extend-right-single SubList.sublist-trivial-free) ) (lift-relation blue subst rd fw all-rules-are-linear)))
        (\lam j _x => rewrite (eq j _x) idp)
  | red, metavar m-A arguments-A, metavar m-B arguments-B, rewrite-with-parameter-m idp i rd eq, ()
  | blue, metavar m-A arguments-A, metavar m-B arguments-B, rewrite-with-parameter-m p i rd eq, ()
  \where {
    \func untransport
      {tc : TheoremContext} {context : List Sort'} {s rule-s : Sort'} {mc mc' mc'' : MetaContext Sort'}
      (color : Color)
      (lp : LinearPattern (colored-env color) nil rule-s)
      (meq : mc = LinearMetaContext {(colored-env color)} lp)
      (sort-eqs : s = rule-s)
      (msubst : MetaSubstitution (colored-env color) context mc mc')
      (outer-subst : MetaSubstitution env nil mc' mc'')
      (l r : Term (colored-env color) nil rule-s mc)
      (t u : Term (colored-env color) context s mc')
      (ms-leq : MetaSubstitution.apply {(colored-env color)} (weakening {(colored-env color)} l SubList.sublist-trivial-free) SubList.identity msubst = transport (Term (colored-env color) context __ mc') sort-eqs t)
      (ms-req : MetaSubstitution.apply {(colored-env color)} (weakening {(colored-env color)} r SubList.sublist-trivial-free) SubList.identity msubst = transport (Term (colored-env color) context __ mc') sort-eqs u)
      (lcoh : convert-to-injected-term color lp = transport (Term env nil rule-s) meq (inject-monochrome-term color l))
      (froot : FunctionalRoot {(colored-env color)} l)
      : \Sigma (new-lp : LinearPattern (colored-env color) nil s)
               (new-r : Term (colored-env color) nil s (LinearMetaContext {(colored-env color)} new-lp))
               (composed : MetaSubstitution env context (LinearMetaContext {(colored-env color)} new-lp) mc'')
               (new-lcoh : MetaSubstitution.apply {env}
                   (weakening {env} (convert-to-injected-term color new-lp) SubList.sublist-trivial-free) SubList.identity composed = MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-free outer-subst)
               (new-rcoh : MetaSubstitution.apply {env}
                   (weakening {env} (inject-monochrome-term color new-r) SubList.sublist-trivial-free) SubList.identity composed = MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.sublist-trivial-free outer-subst)
               (new-meq : LinearMetaContext {(colored-env color)} new-lp = mc)
               (inject-monochrome-term color l = transport2 (Term env nil) sort-eqs new-meq (convert-to-injected-term color new-lp))
               (inject-monochrome-term color r = transport2 (Term env nil) sort-eqs new-meq (inject-monochrome-term color new-r))
               (FunctionalRoot {(colored-env color)} (Linear.convert-to-term {(colored-env color)} new-lp))
               (HasColoredRoot color (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-free outer-subst))
    \elim color, meq, sort-eqs
      | red, idp, idp =>
        (lp,
         r,
         \lam {s1} mvar => MetaSubstitution.apply {env} (inject-monochrome-term red (msubst mvar)) SubList.sublist-trivial-free outer-subst,
         rewrite lcoh (rewriteI ms-leq (unfold transport (rewrite (injection-weakening-commutation red) (rewrite (push-injection red) (metacommutation {env} (\lam m => Injections.inject-term-left envL envR (msubst m)) outer-subst  _ SubList.identity))))),
         rewriteI ms-req (rewrite (injection-weakening-commutation red) (rewrite (push-injection red) (metacommutation {env} (\lam m => Injections.inject-term-left envL envR (msubst m)) outer-subst  _ SubList.identity))),
         idp,
         inv lcoh,
         idp,
         embed-rewrite-relation.extract-functional-root red lp idp (inject-monochrome-term red l) lcoh (promote-functional-root red _ froot),
         produce-colored-root red t msubst outer-subst l ms-leq froot)
      | blue, idp, idp =>
        (lp,
         r,
         \lam {s1} mvar => MetaSubstitution.apply {env} (inject-monochrome-term blue (msubst mvar)) SubList.sublist-trivial-free outer-subst,
         rewrite lcoh (rewriteI ms-leq (unfold transport (rewrite (injection-weakening-commutation blue) (rewrite (push-injection blue) (metacommutation {env} (\lam m => inject-monochrome-term blue (msubst m)) outer-subst  _ SubList.identity))))),
         rewriteI ms-req (rewrite (injection-weakening-commutation blue) (rewrite (push-injection blue) (metacommutation {env} (\lam m => inject-monochrome-term blue (msubst m)) outer-subst  _ SubList.identity))),
         idp,
         inv lcoh,
         idp,
         embed-rewrite-relation.extract-functional-root blue lp idp (inject-monochrome-term blue l) lcoh (promote-functional-root blue _ froot),
         produce-colored-root blue t msubst outer-subst l ms-leq froot)

    \func produce-colored-root
      {tc : TheoremContext} {context : List Sort'} (color : Color) {s : Sort'} {mc mc' mc'' : MetaContext Sort'}
      (t : Term (colored-env color) context s mc')
      (msubst : MetaSubstitution (colored-env color) context mc mc')
      (outer-msubst : MetaSubstitution env nil mc' mc'')
      (l : Term (colored-env color) nil s mc)
      (eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} l SubList.sublist-trivial-free) SubList.identity msubst = t)
      (froot : FunctionalRoot {colored-env color} l)
      : HasColoredRoot color (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-free outer-msubst)
      \elim color, t, l, froot
        | red, var index p, func f arguments, T-has-functional-root => contradiction
        | red, metavar m arguments, func f arguments1, T-has-functional-root => contradiction
        | red, func f arguments, func f1 arguments1, T-has-functional-root => red-func-root
        | blue, var index p, func f arguments, T-has-functional-root => contradiction
        | blue, func f arguments, func f1 arguments1, T-has-functional-root => blue-func-root
        | blue, metavar m arguments, func f arguments1, T-has-functional-root => contradiction

    \func promote-functional-root {tc : TheoremContext} {context : List Sort'} (color : Color) {s : Sort'} {mc : MetaContext Sort'} (t : Term (colored-env color) context s mc)
                                  (fr : FunctionalRoot {colored-env color} t) : FunctionalRoot {env} (inject-monochrome-term color t) \elim color, t, fr
      | red, func f arguments, T-has-functional-root => T-has-functional-root {env}
      | blue, func f arguments, T-has-functional-root => T-has-functional-root {env}

    \func push-injection
      {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {mc mc' : MetaContext Sort'} (color : Color)
      (msubst : MetaSubstitution (colored-env color) context' mc mc')
      (t : Term (colored-env color) context s mc)
      (sublist : SubList context' context)
      : inject-monochrome-term color (MetaSubstitution.apply {colored-env color} t sublist msubst) = MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist (\lam m => inject-monochrome-term color (msubst m))
    \elim color, t
      | red, var index p => idp
      | red, metavar m arguments =>
        \let inductive : (\lam i => inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (arguments i) sublist msubst)) = (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (arguments i)) sublist (\lam m => inject-monochrome-term red (msubst m))) => ext (\lam i => push-injection red msubst (arguments i) sublist)
        \in rewriteI inductive (rewrite (injection-over-left-extension.ext' red _ (\lam (i : Index (mc.m-domain m)) => MetaSubstitution.apply {envL} (arguments i) sublist msubst)) (injection-over-substitution red _ (msubst m)))
      | red, func f arguments => pmap (func {env} (inl f)) (ext (\lam index => push-injection red msubst (arguments index) _))
      | blue, var index p => idp
      | blue, metavar m arguments =>
        \let inductive : (\lam i => inject-monochrome-term blue (MetaSubstitution.apply {colored-env blue} (arguments i) sublist msubst)) = (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term blue (arguments i)) sublist (\lam m => inject-monochrome-term blue (msubst m))) => ext (\lam i => push-injection blue msubst (arguments i) sublist)
        \in rewriteI inductive (rewrite (injection-over-left-extension.ext' blue _ (\lam (i : Index (mc.m-domain m)) => MetaSubstitution.apply {envR} (arguments i) sublist msubst)) (injection-over-substitution blue _ (msubst m)))

      | blue, func f arguments => pmap (func {env} (inr f)) (ext (\lam index => push-injection blue msubst (arguments index) _))
      \where {
        \func injection-over-left-extension
          {tc : TheoremContext} {context context' add-context : List Sort'} {mc : MetaContext Sort'} (color : Color)
          (sublist : SubList add-context context')
          (subst : Substitution {colored-env color} context context' mc)
          (i : Index (add-context ++ context))
          : extend-substitution-left {env} sublist (\lam i => inject-monochrome-term color (subst i)) i
          =
        inject-monochrome-term color (extend-substitution-left {colored-env color} sublist subst i) \elim color
          | red => partial-fin-induction (\lam fin => extend-substitution-left {env} sublist (\lam i => inject-monochrome-term red (subst i)) fin
            =
          inject-monochrome-term red (extend-substitution-left {colored-env red} sublist subst fin))
              (\lam i1 => rewrite (extend-substitution-left.on-begin {env}) (rewrite (extend-substitution-left.on-begin {colored-env red}) idp))
              (\lam i1 => rewrite (extend-substitution-left.on-end {env}) (rewrite (extend-substitution-left.on-end {colored-env red}) (untransport red _ _)))
              i
          | blue => partial-fin-induction (\lam fin => extend-substitution-left {env} sublist (\lam i => inject-monochrome-term blue (subst i)) fin
            =
          inject-monochrome-term blue (extend-substitution-left {colored-env blue} sublist subst fin))
              (\lam i1 => rewrite (extend-substitution-left.on-begin {env}) (rewrite (extend-substitution-left.on-begin {colored-env blue}) idp))
              (\lam i1 => rewrite (extend-substitution-left.on-end {env}) (rewrite (extend-substitution-left.on-end {colored-env blue}) (untransport blue _ _)))
              i
          \where {
            \func untransport {tc : TheoremContext} {context : List Sort'} {s s' : Sort'}
                              {mc : MetaContext Sort'}
                              (color : Color)
                              (eq : s = s')
                              (t : Term (colored-env color) context s mc)
              : transport (Term env context __ mc) eq (inject-monochrome-term color t) = inject-monochrome-term color (transport (Term (colored-env color) context __ mc) eq t) \elim color, eq
              | red, idp => idp
              | blue, idp => idp

            \func ext' {tc : TheoremContext} {context context' add-context : List Sort'} {mc : MetaContext Sort'} (color : Color)
                       (sublist : SubList add-context context')
                       (subst : Substitution {colored-env color} context context' mc)
              : extend-substitution-left {env} sublist (\lam i => inject-monochrome-term color (subst i))
              =
            (\lam i => inject-monochrome-term color (extend-substitution-left {colored-env color} sublist subst i)) =>
              ext (injection-over-left-extension color sublist subst)
          }

        \func injection-over-right-extension
          {tc : TheoremContext} {context context' add-context : List Sort'} {mc : MetaContext Sort'} (color : Color)
          (subst : Substitution {colored-env color} context context' mc)
          (i : Index (context ++ add-context))
          : append-context-right {env} (\lam i => inject-monochrome-term color (subst i)) i
          =
        inject-monochrome-term color (append-context-right {colored-env color} subst i) \elim color
          | red => partial-fin-induction
              (\lam fin => append-context-right {env} (\lam i => inject-monochrome-term red (subst i)) fin = inject-monochrome-term red (append-context-right {colored-env red} subst fin))
              (\lam i1 => rewrite (append-context-right.on-begin {env}) (rewrite (append-context-right.on-begin {colored-env red}) (untransport-lemma red _ _ _)))
              (\lam i1 => rewrite (append-context-right.on-end {env}) (rewrite (append-context-right.on-end {colored-env red}) idp))
              i
          | blue => partial-fin-induction
              (\lam fin => append-context-right {env} (\lam i => inject-monochrome-term blue (subst i)) fin = inject-monochrome-term blue (append-context-right {colored-env blue} subst fin))
              (\lam i1 => rewrite (append-context-right.on-begin {env}) (rewrite (append-context-right.on-begin {colored-env blue}) (untransport-lemma blue _ _ _)))
              (\lam i1 => rewrite (append-context-right.on-end {env}) (rewrite (append-context-right.on-end {colored-env blue}) idp))
              i
          \where {
            \func untransport-lemma {tc : TheoremContext} {context context' : List Sort'} {s s' : Sort'} {mc : MetaContext Sort'}
                                    (color : Color)
                                    (eq : s = s')
                                    (t : Term (colored-env color) context s mc)
                                    (sublist : SubList context context')
              : weakening {env} (transport (Term env context __ mc) eq (inject-monochrome-term color t)) sublist = inject-monochrome-term color (weakening {colored-env color} (transport (Term (colored-env color) context __ mc) eq t) sublist) \elim color, eq
              | red, idp => unfold transport (injection-weakening-commutation red _ _)
              | blue, idp => unfold transport (injection-weakening-commutation blue _ _)
          }

        \func injection-over-substitution
          {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (color : Color)
          (subst : Substitution {colored-env color} context context' mc)
          (t : Term (colored-env color) context s mc)
          : inject-monochrome-term color (Substitution.apply {colored-env color} t subst) = Substitution.apply {env} (inject-monochrome-term color t) (\lam i => inject-monochrome-term color (subst i)) \elim color, t
          | red, var index idp => idp
          | red, metavar m arguments => pmap (metavar {env} m) (ext (\lam index => injection-over-substitution red subst (arguments index)))
          | red, func f arguments => pmap (func {env} (inl f)) (ext (\lam index => (injection-over-substitution red (append-context-right {envL} subst) (arguments index)) *> (pmap (Substitution.apply {env} (inject-monochrome-term red (arguments index))) (ext (\lam index1 => (inv (injection-over-right-extension red _ index1)))))))
          | blue, var index idp => idp
          | blue, metavar m arguments => pmap (metavar {env} m) (ext (\lam index => injection-over-substitution blue subst (arguments index)))
          | blue, func f arguments => pmap (func {env} (inr f)) (ext (\lam index => (injection-over-substitution blue (append-context-right {envR} subst) (arguments index)) *> (pmap (Substitution.apply {env} (inject-monochrome-term blue (arguments index))) (ext (\lam index1 => (inv (injection-over-right-extension blue _ index1)))))))
      }

    \func metacommutation {env : FSignature} {context context' : List Sort} {s : Sort} {mc mc' mc'' : MetaContext Sort}
                          (msubst : MetaSubstitution env context' mc mc')
                          (msubst2 : MetaSubstitution env nil mc' mc'')
                          (t : Term env context s mc)
                          (sublist : SubList context' context)
      :
      MetaSubstitution.apply t sublist (\lam m => MetaSubstitution.apply (msubst m) SubList.sublist-trivial-free msubst2)
        =
      MetaSubstitution.apply (MetaSubstitution.apply t sublist msubst) SubList.sublist-trivial-free msubst2 \elim t
      | var index p => idp
      | metavar m arguments =>
        \let inductive : (\lam i => MetaSubstitution.apply (arguments i) sublist
            (\lam {s : env.Sort} (m : mc.metaname s) => MetaSubstitution.apply (msubst m) SubList.sublist-trivial-free msubst2)) = (\lam i => MetaSubstitution.apply (MetaSubstitution.apply (arguments i) sublist msubst) SubList.sublist-trivial-free msubst2) => ext (\lam i => metacommutation msubst msubst2 (arguments i) sublist)
        \in rewrite inductive (rewrite (subst-extend-left-comm.ext' msubst2 sublist (\lam (i : Index (mc.m-domain m)) => MetaSubstitution.apply (arguments i) sublist msubst)) (subst-metasubst-comm msubst2 (msubst m) _))
      | func f arguments => pmap (func f) (ext (\lam index => rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) (SubList.sublist-trivial-free)) (metacommutation msubst msubst2 (arguments index) (SubList.extend-right-single sublist))))

    \func subst-metasubst-comm
      {env : FSignature} {context context' : List Sort} {s : Sort} {mc' mc'' : MetaContext Sort}
      (msubst2 : MetaSubstitution env nil mc' mc'')
      (t : Term env (context') s mc')
      (subst : Substitution context' context mc')
      :
      Substitution.apply (MetaSubstitution.apply t SubList.sublist-trivial-free msubst2) (\lam i => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free msubst2)
        =
      MetaSubstitution.apply (Substitution.apply t (subst)) SubList.sublist-trivial-free msubst2 \elim t
      | var index idp => idp
      | metavar m arguments => \let inductive-ext : (\lam i => Substitution.apply (MetaSubstitution.apply (arguments i) SubList.sublist-trivial-free msubst2) (\lam i => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free msubst2))
        =
      (\lam i => MetaSubstitution.apply (Substitution.apply (arguments i) (subst)) SubList.sublist-trivial-free msubst2) => ext (\lam i => subst-metasubst-comm msubst2 (arguments i) subst) \in rewriteI inductive-ext (tlcr-over-substitution.commutation.subst-comm _ _ _)
      | func f arguments => pmap (func f) (ext (\lam index => rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) SubList.sublist-trivial-free) (rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) SubList.sublist-trivial-free) (rewriteI (subst-metasubst-comm msubst2 (arguments index) (append-context-right subst)) (pmap (Substitution.apply (MetaSubstitution.apply (arguments index) SubList.sublist-trivial-free msubst2)) (ext (append-context-right-inside-metaapply subst msubst2)))))))

    \func append-context-right-inside-metaapply
      {env : FSignature} {context context' add-context : List Sort} {mc' mc'' : MetaContext Sort}
      (subst : Substitution context context' mc')
      (msubst : MetaSubstitution env nil mc' mc'')
      (index : Index (context ++ add-context))
      : append-context-right (\lam i => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free msubst) {add-context} index = MetaSubstitution.apply (append-context-right subst index) SubList.sublist-trivial-free msubst =>
      partial-fin-induction
          (\lam fin => append-context-right (\lam i => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free msubst) {add-context} fin = MetaSubstitution.apply (append-context-right subst fin) SubList.sublist-trivial-free msubst)
          (\lam fin => repeat {2} (rewrite append-context-right.on-begin) (untransport2 _ (subst fin) msubst _))
          (\lam fin => repeat {2} (rewrite append-context-right.on-end) idp)
          index
      \where {
        \func untransport2 {env : FSignature} {s s' : Sort} (eq : s = s') {mc mc' : MetaContext Sort} {context context' : List Sort}
                           (t : Term env context s mc)
                           (msubst : MetaSubstitution env nil mc mc')
                           (sublist : SubList context context')
          : weakening (transport (\lam (p0 : env.Sort) => Term env context p0 mc') eq
            (MetaSubstitution.apply t SubList.sublist-trivial-free msubst)) sublist =
        MetaSubstitution.apply
            (weakening (transport (\lam (p0 : env.Sort) => Term env context p0 mc) eq t)
                (sublist)) SubList.sublist-trivial-free msubst \elim eq, t
          | idp, var index p => idp
          | idp, metavar m arguments => \let inductive-ext : (\lam i => weakening ((MetaSubstitution.apply (arguments i) SubList.sublist-trivial-free msubst)) sublist) =
              (\lam i => MetaSubstitution.apply
              (weakening (arguments i)
                  (sublist)) SubList.sublist-trivial-free msubst) => ext (\lam i => untransport2 idp (arguments i) msubst sublist) \in unfold transport (rewriteI inductive-ext (rewrite weakening.substitution-eq (\let induced : (\lam (i : Index (mc.m-domain m)) =>
              weakening (MetaSubstitution.apply (arguments i) SubList.sublist-trivial-free msubst) sublist) = (\lam i => Substitution.apply (MetaSubstitution.apply (arguments i) SubList.sublist-trivial-free msubst) (weakening.substitution sublist)) => ext (\lam i => rewrite weakening.substitution-eq idp) \in rewrite induced (tlcr-over-substitution.commutation.subst-comm _ _ _))))
          | idp, func f arguments => (pmap (func f) (ext (\lam index => rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) SubList.sublist-trivial-free) (rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) SubList.sublist-trivial-free) (untransport2 idp (arguments index) msubst (SubList.extend-right-both sublist))))))
      }

    \func subst-extend-left-comm {env : FSignature} {context context' add-context : List Sort} {mc' mc'' : MetaContext Sort}
                                 (msubst2 : MetaSubstitution env nil mc' mc'')
                                 (sublist : SubList context' context)
                                 (subst : Substitution add-context context mc')
                                 (index : Index (context' ++ add-context))
      : (extend-substitution-left
        sublist (\lam (i : Index add-context) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free msubst2)) index = (MetaSubstitution.apply (extend-substitution-left sublist subst index) SubList.sublist-trivial-free msubst2) =>
      partial-fin-induction
          (\lam fin => (extend-substitution-left
              sublist (\lam (i : Index add-context) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free msubst2)) fin = (MetaSubstitution.apply (extend-substitution-left sublist subst fin) SubList.sublist-trivial-free msubst2))
          (\lam fin => repeat {2} (rewrite (extend-substitution-left.on-begin)) idp)
          (\lam fin => repeat {2} (rewrite (extend-substitution-left.on-end)) (untransport-2 _ (subst fin) msubst2))
          index
      \where {
        \func ext' {env : FSignature} {context context' add-context : List Sort} {mc' mc'' : MetaContext Sort}
                   (msubst2 : MetaSubstitution env nil mc' mc'')
                   (sublist : SubList context' context)
                   (subst : Substitution add-context context mc')
          : (extend-substitution-left
            sublist (\lam (i : Index add-context) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free msubst2)) = (\lam i => MetaSubstitution.apply (extend-substitution-left sublist subst i) SubList.sublist-trivial-free msubst2) =>
          ext (subst-extend-left-comm msubst2 sublist subst)
      }

    \func untransport-2 {env : FSignature} {s s' : Sort} (eq : s = s') {mc mc' : MetaContext Sort} {context : List Sort}
                        (t : Term env context s mc)
                        (msubst : MetaSubstitution env nil mc mc'): transport (\lam (p0 : env.Sort) => Term env context p0 mc') (eq)
        (MetaSubstitution.apply (t) SubList.sublist-trivial-free msubst) = MetaSubstitution.apply
                                                                               (transport (\lam (p0 : env.Sort) => Term env context p0 mc) (eq) (t))
                                                                               SubList.sublist-trivial-free msubst \elim eq
      | idp => idp
  }

\func decompose-term {tc : TheoremContext} {context : List Sort'} {s : Sort'}
                     (color : Color)
                     (A : PureTerm env context s) :
  \Sigma (t : LinearTerm (colored-env color) context s)
         (subst : MetaSubstitution env nil (LinearMetaContext {colored-env color} t) (EmptyMetaContext {env}))
         (MetaSubstitution.apply {env} ((convert-to-injected-term color t)) SubList.sublist-trivial-free subst = A)
         (\Pi {s : Sort'} (m : metaname {LinearMetaContext {colored-env color} t} s) -> HasColoredRoot (Color.flip color) (subst m)) \elim color, A
  | color, var index p => (lt-var {colored-env color} index p, \lam {s1} mvar => contradiction, \case \elim color \with {
    | red => idp
    | blue => idp
  }, \lam {s1} m => contradiction)
  | color, metavar m arguments => contradiction
  | red, func (inl f) arguments =>
    \let | inner-results i => decompose-term red (arguments i)
         | context-producer i => LinearMetaContext {colored-env red} (inner-results i).1
         | unified-meta-context => ModularMetaContext {env} context-producer
         | unified-substitution : MetaSubstitution env nil unified-meta-context (EmptyMetaContext {env}) => \lam m => (inner-results m.1).2 m.2
    \in (l-func f (\lam i => (inner-results i).1),
         unified-substitution,
         pmap (func {env} (inl f)) (ext (\lam index => (invariant-through-empty-subst {env} unified-substitution (SubList.extend-right-single SubList.sublist-trivial-free) SubList.sublist-trivial-free _) *>
         (inv (modular-commutation {env} (\lam i => LinearMetaContext {envL} (inner-results i).1) index SubList.sublist-trivial-free (convert-to-injected-term red ((inner-results index).1)) unified-substitution)) *>
         (inner-results index).3)),
         \lam {s1} m => ((inner-results m.1).4 m.2))
  | red, func (inr f) arguments =>
    (l-full-metavar {colored-env red},
     \lam {s1} mvar => transport (PureTerm env context __) (inv mvar) (func (inr f) arguments),
     pmap (func {env} (inr f)) (ext (\lam index => rewrite (append-context-right.to-identity {env}) (rewrite (plain-identity-effect {env}) idp))),
     \lam {s1} m => \case \elim s1, \elim m \with {
       | s1, idp => blue-func-root
     })
  | blue, func (inl f) arguments =>
    (l-full-metavar {colored-env blue},
     \lam {s1} mvar => transport (PureTerm env context __) (inv mvar) (func (inl f) arguments),
     pmap (func {env} (inl f)) (ext (\lam index => rewrite (append-context-right.to-identity {env}) (rewrite (plain-identity-effect {env}) idp))),
     \lam {s1} m => \case \elim s1, \elim m \with {
       | s1, idp => red-func-root
     })
  | blue, func (inr f) arguments =>
    \let | inner-results i => decompose-term blue (arguments i)
         | context-producer i => LinearMetaContext {colored-env blue} (inner-results i).1
         | unified-meta-context => ModularMetaContext {env} context-producer
         | unified-substitution : MetaSubstitution env nil unified-meta-context (EmptyMetaContext {env}) => \lam m => (inner-results m.1).2 m.2
    \in (l-func f (\lam i => (inner-results i).1),
         unified-substitution,
         pmap (func {env} (inr f)) (ext (\lam index => (invariant-through-empty-subst {env} unified-substitution (SubList.extend-right-single SubList.sublist-trivial-free) SubList.sublist-trivial-free _) *>
         (inv (modular-commutation {env} (\lam i => LinearMetaContext {envR} (inner-results i).1) index SubList.sublist-trivial-free (convert-to-injected-term blue ((inner-results index).1)) unified-substitution)) *>
         (inner-results index).3)),
         \lam {s1} m => ((inner-results m.1).4 m.2))

\func join-monochrome-terms {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                            (a b c : Term (colored-env color) context s mc)
                            (a~>b : TClosure (monochrome-reduction color) a b)
                            (a~>c : TClosure (monochrome-reduction color) a c)
                            (conf : ConfluentialSystem (colored-env color) (colored-set-of-rules color))
  : StraightJoin b c (TClosure (\lam x y => \Sigma (rd : monochrome-reduction color x y) (FunctionalWitness {colored-env color} {colored-set-of-rules color} rd))) \elim color
  | red => conf a b c a~>b a~>c
  | blue => conf a b c a~>b a~>c

\func decompose-along-reduction {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
                                (color : Color)
                                (t : Term (colored-env color) context s inner-mc)
                                (B : Term env context s mc)
                                (subst : MetaSubstitution env nil inner-mc mc)
                                (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip color) (subst m))
                                (A~>B : TopLevelColoredReduction color {mc} {context} {s} (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-free subst) B)
  : \Sigma (u : Term (colored-env color) context s (inner-mc))
           (MetaSubstitution.apply {env} (inject-monochrome-term color u) SubList.sublist-trivial-free subst = B)
           (rd : monochrome-reduction color t u)
           (FunctionalWitness {colored-env color} {colored-set-of-rules color} rd)\elim color, t, B, A~>B
  | red, func f arguments, func (inl f') arguments', rewrite-with-parameter-f-colored p p1 i tlcr eq =>
    \let | unmap => pmap (unor {_} {envR.symbol s} f) p
         | eq-p : p = pmap (inl) unmap => Path.inProp _ _
    \in inductive _ _ unmap arguments arguments' subst root-colors i (rewriteI eq-p tlcr) (rewriteI eq-p eq)
  | red, func f arguments, B, rewrite-with-rule-colored hcr lr r lf big-subst l[bs]=injt r[bs]=B (inl idx) seq meq lcx rcx =>
    \let | (middle-subst, substitution-equality, l-eq) =>
      decompose-metasubstitution
          red lr (transport (Term envL __ s inner-mc) (inv ++_nil) (func {envL} f arguments)) big-subst subst
          (rewrite (unwrap-injection {_} {red} lr) (rewrite (inv Transports.extension-to-nil-left)
              (rewrite Transports.extension-to-nil-right (rewrite (transport-over-injection red)
                  (metasubst-over-transport-2 {env} ++_nil
                      (convert-to-injected-term red lr)
                      (func (inl f) (\lam i => inject-monochrome-term red (arguments i))) big-subst subst l[bs]=injt))))) root-colors
         | term-u => MetaSubstitution.apply {envL} (weakening {envL} r SubList.sublist-trivial-free) SubList.identity middle-subst
         | colored-coherence => colored-metacomposition red middle-subst subst big-subst substitution-equality SubList.identity (weakening {envL} r SubList.sublist-trivial-free)
    \in (term-u,
         inv (colored-coherence) *> (pmap (MetaSubstitution.apply {env} __ SubList.identity big-subst) (inv (injection-weakening-commutation red _ _))) *> r[bs]=B,
         produce-monochrome-reduction red lr r middle-subst (func f arguments) term-u
             (rewrite (different-weakening {envL}) (metasubst-over-transport {envL} ++_nil _ (func f arguments) middle-subst
                 ((rewrite (inv Transports.extension-to-nil-right)
                     (pmap (\lam sl => MetaSubstitution.apply {envL} (weakening {envL} (Linear.convert-to-term {envL} lr) sl) (SubList.extend-right-single SubList.identity) middle-subst)
                         Transports.extension-to-nil-left)) *> l-eq)))
             idp lf (inl idx) seq meq lcx rcx,
         rule-rewriting {colored-env red})
  | red, func f arguments, B, rewrite-with-rule-colored hcr lr r lf big-subst l[bs]=injt r[bs]=B (inr b) seq meq lcx rcx =>
    \let | hcr-l => get-colored-root-for-l (inr b)
         | hcr-l-2 => get-color-from-lp red _ (Linear.convert-to-term {colored-env red} lr) meq seq (RewriteRule.l-is-func {get {JointRules {_} {envL} {envR} tc.L-rules tc.R-rules} (inr b)}) (rewrite (unwrap-injection {_} {red}) lcx)
         | empty => color-conflict blue hcr-l hcr-l-2 \in contradiction
  | red, metavar m arguments, B, A~>B =>
    \let
      | other-root-color => root-colors m
      | root-color => TopLevelColoredReduction.extract-root-coloring A~>B
      | empty : Empty => eliminate-colors (blue) other-root-color root-color
    \in contradiction
  | red, var index p, B, A~>B => \let rc => TopLevelColoredReduction.extract-root-coloring A~>B \in \case \elim rc \with {
  }
  | red, func f arguments, func (inr s1) arguments1, rewrite-with-parameter-f-colored p p1 i tlcr eq => contradiction
  | blue, func f arguments, func (inr f') arguments', rewrite-with-parameter-f-colored p p1 i tlcr eq =>
    \let | unmap => pmap (unor-r {_} {envR.symbol s} f) p
         | eq-p : p = pmap (inr) unmap => Path.inProp _ _
    \in inductive-blue _ _ unmap arguments arguments' subst root-colors i (rewriteI eq-p tlcr) (rewriteI eq-p eq)
  | blue, func f arguments, B, rewrite-with-rule-colored hcr lr r lf big-subst l[bs]=injt r[bs]=B (inr idx) seq meq lcx rcx =>
    \let | (middle-subst, substitution-equality, l-eq) =>
      decompose-metasubstitution
          blue lr (transport (Term envR __ s inner-mc) (inv ++_nil) (func {envR} f arguments)) big-subst subst
          (rewrite (unwrap-injection {_} {blue} lr) (rewrite (inv Transports.extension-to-nil-left)
              (rewrite Transports.extension-to-nil-right (rewrite (transport-over-injection blue)
                  (metasubst-over-transport-2 {env} ++_nil
                      (convert-to-injected-term blue lr)
                      (func (inr f) (\lam i => inject-monochrome-term blue (arguments i))) big-subst subst l[bs]=injt))))) root-colors
         | term-u => MetaSubstitution.apply {envR} (weakening {envR} r SubList.sublist-trivial-free) SubList.identity middle-subst
         | colored-coherence => colored-metacomposition blue middle-subst subst big-subst substitution-equality SubList.identity (weakening {envR} r SubList.sublist-trivial-free)
    \in (term-u,
         inv (colored-coherence) *> (pmap (MetaSubstitution.apply {env} __ SubList.identity big-subst) (inv (injection-weakening-commutation blue _ _))) *> r[bs]=B,
         produce-monochrome-reduction blue lr r middle-subst (func f arguments) term-u
             (rewrite (different-weakening {envR}) (metasubst-over-transport {envR} ++_nil _ (func f arguments) middle-subst
                 ((rewrite (inv Transports.extension-to-nil-right)
                     (pmap (\lam sl => MetaSubstitution.apply {envR} (weakening {envR} (Linear.convert-to-term {envR} lr) sl) (SubList.extend-right-single SubList.identity) middle-subst)
                         Transports.extension-to-nil-left)) *> l-eq)))
             idp lf (inr idx) seq meq lcx rcx,
         rule-rewriting {colored-env blue})
  | blue, func f arguments, B, rewrite-with-rule-colored hcr lr r lf big-subst l[bs]=injt r[bs]=B (inl b) seq meq lcx rcx =>
    \let | hcr-l => get-colored-root-for-l (inl b)
         | hcr-l-2 => get-color-from-lp blue _ (Linear.convert-to-term {colored-env blue} lr) meq seq (RewriteRule.l-is-func {get {JointRules {_} {envL} {envR} tc.L-rules tc.R-rules} (inl b)}) (rewrite (unwrap-injection {_} {blue}) lcx)
         | empty => color-conflict red hcr-l hcr-l-2 \in contradiction
  | blue, metavar m arguments, B, A~>B =>
    \let
      | other-root-color => root-colors m
      | root-color => TopLevelColoredReduction.extract-root-coloring A~>B
      | empty : Empty => eliminate-colors (red) other-root-color root-color
    \in contradiction
  | blue, var index p, B, A~>B => \let rc => TopLevelColoredReduction.extract-root-coloring A~>B \in \case \elim rc \with {
  }
  | blue, func f arguments, func (inl s1) arguments1, rewrite-with-parameter-f-colored p p1 i tlcr eq => contradiction
  \where {
    \func inductive {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
                    (f f' : envL.symbol s)
                    (eq : f = f')
                    (arguments :
                    \Pi (index : Index (envL.domain f)) ->
                        Term tc.envL (context ++ f envL.!!param index) (f envL.!!sort index) inner-mc)
                    (arguments' :
                    \Pi (index : Index (env.domain (inl f'))) ->
                        Term env (context ++ inl f' env.!!param index) (inl f' env.!!sort index) mc)
                    (subst : MetaSubstitution env nil (inner-mc) mc)
                    (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip red) (subst m))
                    (i : Index (domain {env} (inl f)))
                    (tlcr : TopLevelColoredReduction red (MetaSubstitution.apply {env}
                        (Injections.inject-term-left envL envR (arguments i)) (SubList.extend-right-single SubList.sublist-trivial-free)
                        subst) (transport-chooser-f {env} (pmap (inl {_} {envR.symbol s}) eq) arguments' i))
                    (eq' :
                    \Pi (j : Index (domain {env} (inl f))) -> (j = i -> Empty) -> MetaSubstitution.apply {env}
                        (Injections.inject-term-left envL envR (arguments j)) (SubList.extend-right-single SubList.sublist-trivial-free)
                        subst = transport-chooser-f {env} (pmap (inl {_} {envR.symbol s}) eq) arguments' j)
      :  \Sigma (u : Term envL context s inner-mc)
                (MetaSubstitution.apply {env} (Injections.inject-term-left envL envR u) SubList.sublist-trivial-free subst = func (inl f') arguments')
                (rd : monochrome-reduction red (func f arguments) u)
                (FunctionalWitness {colored-env red} {L-rules} rd)\elim eq
      | idp => \let inductive-step => (decompose-along-reduction red (arguments i) (arguments' i) subst root-colors (rewrite trivial-sublist-contractible tlcr)) \in
        (func f (pointed-function (\lam index => Term envL (context ++ f FSignature.!!param {envL} index) (f FSignature.!!sort {envL} index) inner-mc) arguments i (inductive-step).1),
         pmap (func {env} (inl f))
             (ext (\lam index => pointed-induction
                 (\lam index => Term envL (context ++ f FSignature.!!param {envL} index) (f FSignature.!!sort {envL} index) inner-mc) (\lam j fx => MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR
                     (fx)) (SubList.extend-right-single SubList.sublist-trivial-free) subst = arguments' j)
                 arguments
                 i
                 (inductive-step).1
                 (rewrite trivial-sublist-contractible inductive-step.2)
                 (\lam j n => eq' j n)
                 index)),
         rewrite-with-parameter-f idp i (rewrite pointed-function.at-index (inductive-step.3)) (\lam j _x => inv (pointed-function.not-at-index _ arguments _ _ j _x)),
         param-rewriting (unifying-lemma _ _ _ _ _ inductive-step.4))
      \where {
        \func unifying-lemma {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                             (t u v : Term envL context s mc) (eq : v = u) (rd : RewriteRelation {envL} L-rules t u)
                             (fw : FunctionalWitness {envL} {L-rules} rd):
          FunctionalWitness {envL} {L-rules} (transportInv (RewriteRelation {envL} tc.L-rules t) (eq) rd) \elim eq | idp => fw
      }

    \func inductive-blue {tc : TheoremContext} {context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
                    (f f' : envR.symbol s)
                    (eq : f = f')
                    (arguments :
                    \Pi (index : Index (envR.domain f)) ->
                        Term tc.envR (context ++ f envR.!!param index) (f envR.!!sort index) inner-mc)
                    (arguments' :
                    \Pi (index : Index (env.domain (inr f'))) ->
                        Term env (context ++ inr f' env.!!param index) (inr f' env.!!sort index) mc)
                    (subst : MetaSubstitution env nil (inner-mc) mc)
                    (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip blue) (subst m))
                    (i : Index (domain {env} (inr f)))
                    (tlcr : TopLevelColoredReduction blue (MetaSubstitution.apply {env}
                        (Injections.inject-term-right envL envR (arguments i)) (SubList.extend-right-single SubList.sublist-trivial-free)
                        subst) (transport-chooser-f {env} (pmap (inr {envL.symbol s} {_}) eq) arguments' i))
                    (eq' :
                    \Pi (j : Index (domain {env} (inr f))) -> (j = i -> Empty) -> MetaSubstitution.apply {env}
                        (Injections.inject-term-right envL envR (arguments j)) (SubList.extend-right-single SubList.sublist-trivial-free)
                        subst = transport-chooser-f {env} (pmap (inr {envL.symbol s}) eq) arguments' j)
      :  \Sigma (u : Term envR context s inner-mc)
                (MetaSubstitution.apply {env} (Injections.inject-term-right envL envR u) SubList.sublist-trivial-free subst = func (inr f') arguments')
                (rd : monochrome-reduction blue (func f arguments) u)
                (FunctionalWitness {colored-env blue} {R-rules} rd) \elim eq
      | idp => \let inductive-step => (decompose-along-reduction blue (arguments i) (arguments' i) subst root-colors (rewrite trivial-sublist-contractible tlcr)) \in
        (func f (pointed-function (\lam index => Term envR (context ++ f FSignature.!!param {envR} index) (f FSignature.!!sort {envR} index) inner-mc) arguments i (inductive-step).1),
         pmap (func {env} (inr f))
             (ext (\lam index => pointed-induction
                 (\lam index => Term envR (context ++ f FSignature.!!param {envR} index) (f FSignature.!!sort {envR} index) inner-mc) (\lam j fx => MetaSubstitution.apply {env} (Injections.inject-term-right tc.envL tc.envR
                     (fx)) (SubList.extend-right-single SubList.sublist-trivial-free) subst = arguments' j)
                 arguments
                 i
                 (inductive-step).1
                 (rewrite trivial-sublist-contractible inductive-step.2)
                 (\lam j n => eq' j n)
                 index)),
         rewrite-with-parameter-f idp i (rewrite pointed-function.at-index (inductive-step.3)) (\lam j _x => inv (pointed-function.not-at-index _ arguments _ _ j _x)),
         param-rewriting (unifying-lemma _ _ _ _ _ inductive-step.4))
      \where {
        \func unifying-lemma {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                             (t u v : Term envR context s mc) (eq : v = u) (rd : RewriteRelation {envR} R-rules t u)
                             (fw : FunctionalWitness {envR} {R-rules} rd):
          FunctionalWitness {envR} {R-rules} (transportInv (RewriteRelation {envR} tc.R-rules t) (eq) rd) \elim eq | idp => fw
      }

    \func get-color-from-lp {tc : TheoremContext} {context : List Sort'} {s s' : Sort'} {mc mc' : MetaContext Sort'}
                            (color : Color)
                            (t : Term env context s' mc')
                            (u : Term (colored-env color) context s mc)
                            (eq : mc = mc')
                            (seq : s = s')
                            (cr : FunctionalRoot {env} t)
                            (geq : t = transport2 (Term env context) seq eq (inject-monochrome-term color u))
      : HasColoredRoot color t \elim color, t, u, eq, seq, cr, geq
      | red, func f arguments, var index p, idp, idp, T-has-functional-root, geq => contradiction
      | red, func f arguments, metavar m arguments1, idp, idp, T-has-functional-root, geq => contradiction
      | red, func (inl a) arguments, func f1 arguments1, idp, idp, T-has-functional-root, geq => red-func-root
      | red, func (inr b) arguments, func f1 arguments1, idp, idp, T-has-functional-root, geq => contradiction
      | blue, func f arguments, var index p, idp, idp, T-has-functional-root, geq => contradiction
      | blue, func f arguments, metavar m arguments1, idp, idp, T-has-functional-root, geq => contradiction
      | blue, func (inl a) arguments, func f1 arguments1, idp, idp, T-has-functional-root, geq => contradiction
      | blue, func (inr b) arguments, func f1 arguments1, idp, idp, T-has-functional-root, geq => blue-func-root

    \func color-conflict  {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {msig : MetaContext Sort'}
                          {T : Term env context s msig} (hcr : HasColoredRoot color T) (hcr' : HasColoredRoot (Color.flip color) T) : Empty \elim color, T, hcr, hcr'
      | red, func (inl s1) arguments, red-func-root, ()
      | blue, func (inr b) arguments1, blue-func-root, ()

    \lemma eliminate-colors {tc : TheoremContext} (color : Color) {context context' : List Sort'} {s : Sort'} {msig : MetaContext Sort'}
                            {T : Term env context s msig} {subst : Substitution {env} context context' msig} (hcr : HasColoredRoot color T)
                            (hcr' : HasColoredRoot (Color.flip color) (Substitution.apply {env} T subst))
      : Empty \elim color, T, hcr, hcr'
      | red, func (inl s1) arguments, red-func-root, ()
      | blue, var index p, (), hcr'
      | blue, metavar m arguments, (), hcr'
      | blue, func f arguments1, hcr, hcr' =>
        \let | eq => (inv (HasColoredRoot.reorganize red hcr')) *> HasColoredRoot.reorganize blue hcr
        \in contradiction


    \lemma different-weakening {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort}
                              (T : Term env nil s ms)
      : weakening T (SubList.sublist-trivial-free {_} {context}) =
    transport (Term env __ s ms) (++_nil) (weakening T (SubList.extend-right-single SubList.identity)) \elim context
      | nil => idp
      | :: a context => lemma (++_nil) (sublist-skip SubList.sublist-trivial-free) (sublist-skip SubList.sublist-trivial-free) (trivial-sublist-contractible _ _) T
      \where {
        \lemma lemma  {env : FSignature} {context context' : List Sort} {s : Sort} {ms : MetaContext Sort}
                     (eq : context' = context) (sl : SubList nil context) (sl' : SubList nil context') (sl=sl' : sl = (transport (SubList nil) eq sl')) (T : Term env nil s ms) :
          weakening T sl = transport (Term env __ s ms) eq (weakening T sl') \elim context, eq, sl=sl'
          | nil, idp, idp => idp
          | :: a context, idp, idp => idp

      }

    \lemma metasubst-over-transport {env : FSignature} {context context' : List Sort} {s : Sort} {ms ms' : MetaContext Sort} (eq : context = context')
                                    (T : Term env context s ms) (S : Term env context' s ms') (msubst : MetaSubstitution env context' ms ms')
                                    (eq' : MetaSubstitution.apply T (transport (SubList context') (inv eq) SubList.identity) msubst = (transport (Term env __ s ms') (inv eq) S))
      : MetaSubstitution.apply (transport (Term env __ s ms) eq T) (SubList.identity) msubst = S \elim eq
      | idp => eq'

    \lemma transport-over-injection {tc : TheoremContext} {context context' : List Sort'} (color : Color) (eq : context = context') {s : Sort'} {ms : MetaContext Sort'}
                                    (T : Term (colored-env color) context s ms) : inject-monochrome-term color (transport (Term (colored-env color) __ s ms) eq T) = transport (Term env __ s ms) eq (inject-monochrome-term color T) \elim color, eq
      | red, idp => idp
      | blue, idp => idp

    \lemma metasubst-over-transport-2 {env : FSignature} {context context' : List Sort} {s : Sort} {ms ms' ms'' : MetaContext Sort}
                                      (eq : context' = context)
                                      (T : Term env nil s ms) (S : Term env context s ms'')
                                      (msubst : MetaSubstitution env context ms ms')
                                      (msubst2 : MetaSubstitution env nil ms'' ms')
                                      (eq' : MetaSubstitution.apply (weakening T SubList.sublist-trivial-free) SubList.identity msubst = MetaSubstitution.apply S SubList.sublist-trivial-free msubst2)
      : MetaSubstitution.apply (weakening T SubList.sublist-trivial-free) (transport (SubList context) (inv eq) SubList.identity) msubst = MetaSubstitution.apply (transport (Term env __ s ms'') (inv eq) S) SubList.sublist-trivial-free msubst2 \elim eq
      | idp => eq'

    \lemma unwrap-injection {tc : TheoremContext} {color : Color} {context : List Sort'} {s : Sort'} (t : LinearPattern (colored-env color) context s) :
      inject-monochrome-term color (Linear.convert-to-term {colored-env color} t) = convert-to-injected-term color {context} {s} t \elim color, t
      | red, l-func f arguments => pmap (func {env} (inl f))
          (ext (\lam index => rewriteI (unwrap-injection {_} {red} (arguments index)) (swap red (\lam i => LinearMetaContext {envL} (arguments i)) (Linear.convert-to-term {envL} (arguments index)))))
      | blue, l-func f arguments => pmap (func {env} (inr f))
          (ext (\lam index => rewriteI (unwrap-injection {_} {blue} (arguments index)) (swap blue (\lam i => LinearMetaContext {envR} (arguments i)) (Linear.convert-to-term {envR} (arguments index)))))
      | red, l-full-metavar => idp
      | blue, l-full-metavar => idp
      | color, l-var index p ()
      \where {
        \lemma swap
          {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {n : Nat} {i : Fin n} (msigs : \Pi (i : Fin n) -> MetaContext Sort')
          (t : Term (colored-env color) context s (msigs i)) :
          inject-monochrome-term color (ModularMetaContext.upgrade-metavariables {colored-env color} msigs t) =
          ModularMetaContext.upgrade-metavariables {env} msigs (inject-monochrome-term color t) \elim color, t
          | red, var index p => idp
          | red, metavar m arguments =>
            \let extt : (\lam i1 => Injections.inject-term-left envL envR (ModularMetaContext.upgrade-metavariables {envL} msigs (arguments i1))) = (\lam i1 => (ModularMetaContext.upgrade-metavariables {env} msigs (Injections.inject-term-left envL envR (arguments i1)))) => ext (\lam i => swap red msigs (arguments i))
            \in rewrite extt idp
          | red, func f arguments => pmap (func {env} (inl f)) (ext (\lam index => (swap red msigs (arguments index))))
          | blue, var index p => idp
          | blue, metavar m arguments =>
            \let extt : (\lam i1 => Injections.inject-term-right envL envR (ModularMetaContext.upgrade-metavariables {envR} msigs (arguments i1))) = (\lam i1 => (ModularMetaContext.upgrade-metavariables {env} msigs (Injections.inject-term-right envL envR (arguments i1)))) => ext (\lam i => swap blue msigs (arguments i))
            \in rewrite extt idp
          | blue, func f arguments => pmap (func {env} (inr f)) (ext (\lam index => (swap blue msigs (arguments index))))
      }
  }

\func produce-monochrome-reduction
  {tc : TheoremContext} {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (color : Color)
  (pattern : LinearPattern (colored-env color) nil s)
  (rule-r : Term (colored-env color) nil s (LinearMetaContext {colored-env color} pattern))
  (subst : MetaSubstitution (colored-env color) context (LinearMetaContext {colored-env color} pattern) mc)
  (l r : Term (colored-env color) context s mc)
  (l-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (Linear.convert-to-term {colored-env color} pattern) SubList.sublist-trivial-free) SubList.identity subst = l)
  (r-eq : MetaSubstitution.apply {colored-env color} (weakening {colored-env color} rule-r SubList.sublist-trivial-free) SubList.identity subst = r)
  (l-is-func : FunctionalRoot {colored-env color} (Linear.convert-to-term {colored-env color} pattern))
  (idx : J {JointRules {_} {envL} {envR} L-rules R-rules})
  (i-sort-eq : s = RewriteRule.s {get {JointRules {_} {envL} {envR} L-rules R-rules} idx})
  (i-meta-eq : (LinearMetaContext {colored-env color} pattern) = RewriteRule.meta-context {get {JointRules {_} {envL} {envR} L-rules R-rules} idx})
  (idx-l-eq : RewriteRule.l {get {JointRules {_} {envL} {envR} L-rules R-rules} idx} = transport2 (\lam sort mc => Term env nil sort mc) (i-sort-eq) i-meta-eq (convert-to-injected-term color pattern))
  (ifx-r-eq : RewriteRule.r {get {JointRules {_} {envL} {envR} L-rules R-rules} idx} = transport2 (\lam sort mc => Term env nil sort mc) i-sort-eq i-meta-eq (inject-monochrome-term color rule-r))
  : monochrome-reduction color l r \elim color, idx
  | red, inl idx =>
    rewrite-with-rule
        idx
        i-sort-eq
        (rewriteI i-meta-eq subst)
        (unembed-tlcr.untransport {envL} i-sort-eq i-meta-eq subst (Linear.convert-to-term {envL} pattern) (RewriteRule.l {L-rules.get idx}) l l-eq (uninject-equality red _ _ (RewriteRule.l {L-rules.get idx}) (Linear.convert-to-term {colored-env red} pattern) (rewrite (unwrap-injection red) idx-l-eq)))
        (unembed-tlcr.untransport {envL} i-sort-eq i-meta-eq subst rule-r (RewriteRule.r {L-rules.get idx}) r r-eq (uninject-equality red _ _ (RewriteRule.r {L-rules.get idx}) (rule-r) (ifx-r-eq)))
  | blue, inr idx => rewrite-with-rule
      idx
      i-sort-eq
      (rewriteI i-meta-eq subst)
      (unembed-tlcr.untransport {envR} i-sort-eq i-meta-eq subst (Linear.convert-to-term {envR} pattern) (RewriteRule.l {R-rules.get idx}) l l-eq (uninject-equality blue _ _ (RewriteRule.l {R-rules.get idx}) (Linear.convert-to-term {colored-env blue} pattern) (rewrite (unwrap-injection blue) idx-l-eq)))
      (unembed-tlcr.untransport {envR} i-sort-eq i-meta-eq subst rule-r (RewriteRule.r {R-rules.get idx}) r r-eq (uninject-equality blue _ _ (RewriteRule.r {R-rules.get idx}) (rule-r) (ifx-r-eq)))
  | red, inr b => \let | l-hcr => get-colored-root-for-l (inr b)
                       | lp-hcr => infer-hcr red pattern l-is-func \in \let q => contradictory _ _ _ _ idx-l-eq l-hcr lp-hcr \in contradiction
  | blue, inl a => \let | l-hcr => get-colored-root-for-l (inl a)
                        | lp-hcr => infer-hcr blue pattern l-is-func \in \let q => contradictory _ _ _ _ idx-l-eq l-hcr lp-hcr \in contradiction
  \where {
    \func infer-hcr {tc : TheoremContext} {s : Sort'} (color : Color) (lp : LinearPattern (colored-env color) nil s) (fr : FunctionalRoot {colored-env color} (Linear.convert-to-term {colored-env color} lp)) : HasColoredRoot color (convert-to-injected-term color lp) \elim color, lp, fr
      | red, l-func f arguments, T-has-functional-root => red-func-root
      | blue, l-func f arguments, T-has-functional-root => blue-func-root

    \func contradictory {tc : TheoremContext} {color : Color} {s s' : Sort'} {mc mc' : MetaContext Sort'} (eq1 : s = s') (eq2 : mc = mc') (t : Term env nil s' mc') (t2 : Term env nil s mc) (eqt : t = transport2 (Term env nil) eq1 eq2 t2) (hcr1 : HasColoredRoot color t) (hcr2 : HasColoredRoot (Color.flip color) t2) : Empty \elim color, eq1, eq2, t, t2, hcr1, hcr2
      | red, idp, idp, func (inl s1) arguments, func (inr b) arguments1, red-func-root, blue-func-root => \let q => pmap (decompose-metasubstitution.unfunc {env} (inl s1)) eqt \in contradiction
      | blue, idp, idp, func (inr s1) arguments, func (inl a) arguments1, blue-func-root, hcr2 => \let q => pmap (decompose-metasubstitution.unfunc {env} (inr s1)) eqt \in contradiction

    \lemma unwrap-injection {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} (t : LinearPattern (colored-env color) context s) :
      inject-monochrome-term color (Linear.convert-to-term {colored-env color} t) = convert-to-injected-term color {context} {s} t \elim color, t
      | red, l-func f arguments => pmap (func {env} (inl f)) (ext (\lam index => rewriteI (unwrap-injection red (arguments index)) (swap red _ _)))
      | red, l-full-metavar => idp
      | blue, l-func f arguments => pmap (func {env} (inr f)) (ext (\lam index => rewriteI (unwrap-injection blue (arguments index)) (swap blue _ _)))
      | blue, l-full-metavar => idp
      | color, l-var index p ()
      \where {
        \lemma swap
          {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {n : Nat} {i : Fin n} (msigs : \Pi (i : Fin n) -> MetaContext Sort')
          (t : Term (colored-env color) context s (msigs i)) :
          inject-monochrome-term color (ModularMetaContext.upgrade-metavariables {colored-env color} msigs t) =
          ModularMetaContext.upgrade-metavariables {env} msigs (inject-monochrome-term color t) \elim color, t
          | red, var index p => idp
          | red, metavar m arguments =>
            \let extt : (\lam i1 => Injections.inject-term-left envL envR (ModularMetaContext.upgrade-metavariables {envL} msigs (arguments i1))) = (\lam i1 => (ModularMetaContext.upgrade-metavariables {env} msigs (Injections.inject-term-left envL envR (arguments i1)))) => ext (\lam i => swap red msigs (arguments i))
            \in rewrite extt idp
          | red, func f arguments => pmap (func {env} (inl f)) (ext (\lam index => (swap red msigs (arguments index))))
          | blue, var index p => idp
          | blue, metavar m arguments =>
            \let extt : (\lam i1 => Injections.inject-term-right envL envR (ModularMetaContext.upgrade-metavariables {envR} msigs (arguments i1))) = (\lam i1 => (ModularMetaContext.upgrade-metavariables {env} msigs (Injections.inject-term-right envL envR (arguments i1)))) => ext (\lam i => swap blue msigs (arguments i))
            \in rewrite extt idp
          | blue, func f arguments => pmap (func {env} (inr f)) (ext (\lam index => (swap blue msigs (arguments index))))
      }

    \func uninject-equality {tc : TheoremContext} (color : Color) {s s' : Sort'} {context : List Sort'} {mc mc' : MetaContext Sort'} (eq1 : s = s') (eq2 : mc = mc')
                            (t : Term (colored-env color) context s' mc')
                            (u : Term (colored-env color) context s mc)
                            (ineq : inject-monochrome-term color t = transport2 (Term env context) eq1 eq2 (inject-monochrome-term color u))
      : t = transport2 (Term (colored-env color) context) eq1 eq2 u \elim color, eq1, eq2, t, u
      | red, idp, idp, var index p, var index1 p1 => \let unvared => pmap (unvar {env} index p) ineq \in pmap (to-var {envL}) unvared
      | red, idp, idp, var index p, metavar m arguments => contradiction
      | red, idp, idp, var index p, func f arguments => contradiction
      | red, idp, idp, metavar m arguments, var index p => contradiction
      | red, idp, idp, metavar m arguments, metavar m1 arguments1 =>
        \let | unmvared => pmap (unmetavar {env} m (\lam (i : Index (mc.m-domain m)) => Injections.inject-term-left tc.envL tc.envR (arguments i))) ineq
             | meta-eq : m = m1 => pmap (__.1) unmvared
             | meta-eq-2 : transport (\lam mx => Substitution {env} (mc.m-domain mx) context mc) meta-eq (\lam (i : Index (mc.m-domain m)) => Injections.inject-term-left tc.envL tc.envR (arguments i)) = (\lam (i : Index (mc.m-domain m1)) => Injections.inject-term-left tc.envL tc.envR (arguments1 i))
             => second-sigma {_} {\lam mx => Substitution {env} (mc.m-domain mx) context mc} unmvared
        \in \case \elim m, \elim arguments, \elim meta-eq, \elim unmvared, \elim meta-eq-2 \with {
          | m, arguments, idp, unmvared, meta-eq-2 => pmap (metavar {envL} m1) (ext (\lam index =>
              \let | q : (pmap (\lam (p0 : \Sigma (a : mc.metaname s) (Substitution {env} (mc.m-domain a) context mc)) => p0.1) unmvared) = idp => Path.inProp _ _
                   | at-index => rewrite q (pmap (__ index) meta-eq-2) \in uninject-equality red idp idp _ _ (at-index)))
        }
      | red, idp, idp, metavar m arguments, func f arguments1 => contradiction
      | red, idp, idp, func f arguments, var index p => contradiction
      | red, idp, idp, func f arguments, metavar m arguments1 => contradiction
      | red, idp, idp, func f arguments, func f1 arguments1 =>
        \let | unfunced => pmap (unfunc {env} (inl f) (\lam (i : Index (domain {JointFSignature tc.envL tc.envR} (inl f))) =>
            Injections.inject-term-left tc.envL tc.envR (arguments i))) ineq
             | choosers-eq => second-sigma {_} {\lam fx => \Pi (index : Index (domain {env} fx)) ->
                 Term env (context ++ fx FSignature.!!param {env} index) (fx FSignature.!!sort {env} index) mc} unfunced
             | inlfeq => pmap (\lam sig => unor f sig.1) unfunced
        \in \case \elim f, \elim arguments, \elim unfunced, \elim choosers-eq, \elim inlfeq \with {
          | f, arguments, unfunced, choosers-eq, idp => pmap (func {envL} f1) (ext (\lam index =>
              \let | q : (pmap (\lam (p0 : \Sigma (a : Or (symbol {tc.envL} s) (symbol {tc.envR} s)) (\Pi (index : Index (env.domain a)) ->
                  Term env (context ++ a FSignature.!!param {env} index) (a FSignature.!!sort {env} index) mc)) => p0.1) unfunced) = idp => Path.inProp _ _
                   | at-index => rewrite q (pmap (__ index) choosers-eq)
              \in uninject-equality red idp idp _ _ (at-index)))
        }
      | blue, idp, idp, var index p, var index1 p1 => \let unvared => pmap (unvar {env} index p) ineq \in pmap (to-var {envR}) unvared
      | blue, idp, idp, metavar m arguments, var index p => contradiction
      | blue, idp, idp, metavar m arguments, metavar m1 arguments1 =>
        \let | unmvared => pmap (unmetavar {env} m (\lam (i : Index (mc.m-domain m)) => inject-monochrome-term blue (arguments i))) ineq
             | meta-eq : m = m1 => pmap (__.1) unmvared
             | meta-eq-2 : transport (\lam mx => Substitution {env} (mc.m-domain mx) context mc) meta-eq (\lam (i : Index (mc.m-domain m)) => inject-monochrome-term blue (arguments i)) = (\lam (i : Index (mc.m-domain m1)) => inject-monochrome-term blue (arguments1 i))
             => second-sigma {_} {\lam mx => Substitution {env} (mc.m-domain mx) context mc} unmvared
        \in \case \elim m, \elim arguments, \elim meta-eq, \elim unmvared, \elim meta-eq-2 \with {
          | m, arguments, idp, unmvared, meta-eq-2 => pmap (metavar {envR} m1) (ext (\lam index =>
              \let | q : (pmap (\lam (p0 : \Sigma (a : mc.metaname s) (Substitution {env} (mc.m-domain a) context mc)) => p0.1) unmvared) = idp => Path.inProp _ _
                   | at-index => rewrite q (pmap (__ index) meta-eq-2) \in uninject-equality blue idp idp _ _ (at-index)))
        }
      | blue, idp, idp, metavar m arguments, func f arguments1 => contradiction
      | blue, idp, idp, func f arguments, var index p => contradiction
      | blue, idp, idp, func f arguments, metavar m arguments1 => contradiction
      | blue, idp, idp, func f arguments, func f1 arguments1 =>
        \let | unfunced => pmap (unfunc {env} (inr f) (\lam (i : Index (domain {JointFSignature tc.envL tc.envR} (inr f))) =>
            inject-monochrome-term blue (arguments i))) ineq
             | choosers-eq => second-sigma {_} {\lam fx => \Pi (index : Index (domain {env} fx)) ->
                 Term env (context ++ fx FSignature.!!param {env} index) (fx FSignature.!!sort {env} index) mc} unfunced
             | inlfeq => pmap (\lam sig => unor-r f sig.1) unfunced
        \in \case \elim f, \elim arguments, \elim unfunced, \elim choosers-eq, \elim inlfeq \with {
          | f, arguments, unfunced, choosers-eq, idp => pmap (func {envR} f1) (ext (\lam index =>
              \let | q : (pmap (\lam (p0 : \Sigma (a : Or (symbol {tc.envL} s) (symbol {tc.envR} s)) (\Pi (index : Index (env.domain a)) ->
                  Term env (context ++ a FSignature.!!param {env} index) (a FSignature.!!sort {env} index) mc)) => p0.1) unfunced) = idp => Path.inProp _ _
                   | at-index => rewrite q (pmap (__ index) choosers-eq)
              \in uninject-equality blue idp idp _ _ (at-index)))
        }
      \where {
        \func unvar
          {env : FSignature} {context : List Sort} {s : Sort} {mc : MetaContext Sort}
          (i : Index context) (eq : s = context !! i) (t : Term env context s mc) : \Sigma (j : Index context) (eq : s = context !! j) \elim t
          | var index p => (index, p)
          | metavar m arguments => (i, eq)
          | func f arguments => (i, eq)

        \func unmetavar
          {env : FSignature} {context : List Sort} {s : Sort} {mc : MetaContext Sort}
          (m : mc.metaname s)
          (chooser : \Pi (index : Index (mc.m-domain m)) -> Term (env) context (mc.m-domain m !! index) mc)
          (t : Term env context s mc) : \Sigma (m' : mc.metaname s) (ch : \Pi (index : Index (mc.m-domain m')) -> Term (env) context (mc.m-domain m' !! index) mc)
        \elim t
          | var index p => (m, chooser)
          | metavar m1 arguments => (m1, arguments)
          | func f arguments => (m, chooser)

        \func unfunc
          {env : FSignature} {context : List Sort} {s : Sort} {mc : MetaContext Sort}
          (f : env.symbol s)
          (chooser : \Pi (index : Index (env.domain f)) -> Term env (context ++ f FSignature.!!param index) (f FSignature.!!sort index) mc)
          (t : Term env context s mc) :
          \Sigma (f' : env.symbol s) (ch : \Pi (index : Index (env.domain f')) -> Term env (context ++ f' FSignature.!!param index) (f' FSignature.!!sort index) mc)
        \elim t
          | var index p => (f, chooser)
          | metavar m1 arguments => (f, chooser)
          | func f' arguments => (f', arguments)

        \func second-sigma {A : \Type} {B : A -> \Type} {s s' : \Sigma (a : A) (B a)} (geq : s = s') : transport B (pmap (__.1) geq) s.2 = s'.2 =>
          Jl (\lam sig eq => transport B (pmap (__.1) eq) s.2 = sig.2) idp geq
      }
  }

\func inject-linear-pattern
  {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
  (l : LinearPattern (colored-env color) context s) : LinearPattern env context s \elim color, l
  | red, l-func f arguments => l-func (inl f) (\lam i => inject-linear-pattern red (arguments i))
  | color, l-full-metavar => l-full-metavar {env}
  | blue, l-func f arguments => l-func (inr f) (\lam i => inject-linear-pattern blue (arguments i))
  | _, l-var index p ()
  \where {
    \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} (l : LinearPattern env context s) \elim l
      | l-func f arguments =>
      lp-witness-f (color-of-root f = color)
                   (\Pi (i : Index (env.domain f)) -> InjectionWitness color (arguments i))
      | lp-metavar => lp-witness-fm
  }

\func inject-linear-term {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                         (l : LinearTerm (colored-env color) context s) : LinearTerm env context s \elim color, l
  | red, l-func f arguments => l-func (inl f) (\lam i => inject-linear-term red (arguments i))
  | blue, l-func f arguments => l-func (inr f) (\lam i => inject-linear-term blue (arguments i))
  | color, l-full-metavar => l-full-metavar {env}
  | color, lt-var index p => lt-var {env} index p
  \where {
    \data InjectionWitness {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} (l : LinearTerm env context s) \elim l
      | l-func f arguments =>
      lt-witness-f (color-of-root f = color)
                   (\Pi (i : Index (env.domain f)) -> InjectionWitness color (arguments i))
      | lt-var _ _ => lt-witness-v
      | l-full-metavar => lt-witness-fm

    \lemma generate-injection-witness {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color)
                                      (l : LinearTerm (colored-env color) context s) : InjectionWitness color (inject-linear-term color l) \elim color, l
      | red, l-func f arguments => lt-witness-f idp (\lam i => generate-injection-witness red (arguments i))
      | blue, l-func f arguments => lt-witness-f idp (\lam i => generate-injection-witness blue (arguments i))
      | red, l-full-metavar => lt-witness-fm
      | blue, l-full-metavar => lt-witness-fm
      | red, lt-var index p => lt-witness-v
      | blue, lt-var index p => lt-witness-v

    \lemma extract-from-witness {tc : TheoremContext} {context : List Sort'} {s : Sort'} (color : Color) (f : env.symbol s)
                                (arguments :  \Pi (index : Index (env.domain f)) -> LinearTerm env (context ++ f env.!!param index) (f env.!!sort index)) -- Why env?
                                (witness : InjectionWitness color (l-func {env} f arguments))
      : \Sigma (\Pi (i : Index (env.domain f)) -> InjectionWitness color (arguments i)) (color-of-root f = color) \elim color, witness
      | color, lt-witness-f p _x => (_x, p)
  }

\lemma colored-metacomposition {tc : TheoremContext} {global-context : List Sort'} {ms-a ms-b ms-c : MetaContext Sort'}
                               (color : Color)
                               (subst-a : MetaSubstitution (colored-env color) global-context ms-a ms-b)
                               (subst-b : MetaSubstitution env nil ms-b ms-c)
                               (subst-c : MetaSubstitution env global-context ms-a ms-c)
                               (eq : \Pi {s : Sort'} (m : ms-a.metaname s) -> subst-c m = MetaSubstitution.apply {env} (inject-monochrome-term color (subst-a m)) (SubList.sublist-trivial-free) subst-b)
                               {context : List Sort'} {s : Sort'}
                               (sublist : SubList global-context context)
                               (t : Term (colored-env color) context s ms-a)
  : MetaSubstitution.apply {env} (inject-monochrome-term color t) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term color (MetaSubstitution.apply {colored-env color} t sublist subst-a)) SubList.sublist-trivial-free subst-b \elim color, t
  | red, var index p => idp
  | red, metavar m arguments =>
    \let | inner i : MetaSubstitution.apply {env} (inject-monochrome-term red (arguments i)) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (arguments i) sublist subst-a)) SubList.sublist-trivial-free subst-b => colored-metacomposition red subst-a subst-b subst-c eq sublist (arguments i)
         | inner-ext : (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (arguments i)) sublist subst-c) = (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term red (MetaSubstitution.apply {colored-env red} (arguments i) sublist subst-a)) SubList.sublist-trivial-free subst-b) => ext inner
    \in rewrite (eq m) (inv (rewrite inner-ext (rewrite (twist-application red) (commutation subst-b (\lam ind => Injections.inject-term-left tc.envL tc.envR (extend-substitution-left {envL} sublist (\lam i => MetaSubstitution.apply {envL} (arguments i) sublist subst-a) ind)) (Injections.inject-term-left envL envR (subst-a m)) *> (pmap (Substitution.apply {env} (MetaSubstitution.apply {env} (Injections.inject-term-left tc.envL tc.envR (subst-a m)) SubList.sublist-trivial-free subst-b)) (extend-left-commutation.ext' red _ _ _))))))
  | red, func f arguments => pmap (func {env} (inl f)) (ext (\lam index => (colored-metacomposition red subst-a subst-b subst-c eq (SubList.extend-right-single sublist) (arguments index)) *> invariant-through-empty-subst {env} subst-b SubList.sublist-trivial-free (SubList.extend-right-single SubList.sublist-trivial-free) _))
  | blue, var index p => idp
  | blue, metavar m arguments =>
    \let | inner i : MetaSubstitution.apply {env} (inject-monochrome-term blue (arguments i)) sublist subst-c = MetaSubstitution.apply {env} (inject-monochrome-term blue (MetaSubstitution.apply {colored-env blue} (arguments i) sublist subst-a)) SubList.sublist-trivial-free subst-b => colored-metacomposition blue subst-a subst-b subst-c eq sublist (arguments i)
         | inner-ext : (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term blue (arguments i)) sublist subst-c) = (\lam i => MetaSubstitution.apply {env} (inject-monochrome-term blue (MetaSubstitution.apply {colored-env blue} (arguments i) sublist subst-a)) SubList.sublist-trivial-free subst-b) => ext inner
    \in rewrite (eq m) (inv (rewrite inner-ext (rewrite (twist-application blue) (commutation subst-b (\lam ind => inject-monochrome-term blue (extend-substitution-left {envR} sublist (\lam i => MetaSubstitution.apply {envR} (arguments i) sublist subst-a) ind)) (inject-monochrome-term blue (subst-a m)) *> (pmap (Substitution.apply {env} (MetaSubstitution.apply {env} (inject-monochrome-term blue (subst-a m)) SubList.sublist-trivial-free subst-b)) (extend-left-commutation.ext' blue _ _ _))))))
  | blue, func f arguments => pmap (func {env} (inr f)) (ext (\lam index => (colored-metacomposition blue subst-a subst-b subst-c eq (SubList.extend-right-single sublist) (arguments index)) *> invariant-through-empty-subst {env} subst-b SubList.sublist-trivial-free (SubList.extend-right-single SubList.sublist-trivial-free) _))
  \where {
    \func extend-left-commutation {tc : TheoremContext} {context-a context-b context-c : List Sort'} {mc mc' : MetaContext Sort'}
                                  (color : Color)
                                  (subst : Substitution {(colored-env color)} context-b context-c mc)
                                  (sublist : SubList context-a context-c)
                                  (msubst : MetaSubstitution env nil mc mc')
                                  (i : Index (context-a ++ context-b)) :
      (MetaSubstitution.apply {env} (inject-monochrome-term color (extend-substitution-left {(colored-env color)} sublist subst i))
          SubList.sublist-trivial-free msubst) = extend-substitution-left {env} sublist (\lam (j : Index (context-b)) => MetaSubstitution.apply {env}
          (inject-monochrome-term color (subst j)) SubList.sublist-trivial-free msubst) i \elim color
      | red => \let color => red \in partial-fin-induction (\lam fin => (MetaSubstitution.apply {env} (inject-monochrome-term color (extend-substitution-left {colored-env color} sublist subst fin))
          SubList.sublist-trivial-free msubst) = extend-substitution-left {env} sublist (\lam (j : Index (context-b)) => MetaSubstitution.apply {env}
          (inject-monochrome-term color (subst j)) SubList.sublist-trivial-free msubst) fin)
          (\lam i1 => rewrite (extend-substitution-left.on-begin {env}) (rewrite (extend-substitution-left.on-begin {colored-env color}) idp))
          (\lam i1 => rewrite (extend-substitution-left.on-end {env}) (rewrite (extend-substitution-left.on-end {colored-env color}) (untransport red sublist msubst _ _)))
          i
      | blue => \let color => blue \in partial-fin-induction (\lam fin => (MetaSubstitution.apply {env} (inject-monochrome-term color (extend-substitution-left {colored-env color} sublist subst fin))
          SubList.sublist-trivial-free msubst) = extend-substitution-left {env} sublist (\lam (j : Index (context-b)) => MetaSubstitution.apply {env}
          (inject-monochrome-term color (subst j)) SubList.sublist-trivial-free msubst) fin)
          (\lam i1 => rewrite (extend-substitution-left.on-begin {env}) (rewrite (extend-substitution-left.on-begin {colored-env color}) idp))
          (\lam i1 => rewrite (extend-substitution-left.on-end {env}) (rewrite (extend-substitution-left.on-end {colored-env color}) (untransport blue sublist msubst _ _)))
          i
      \where {
      \func ext' {tc : TheoremContext} {context-a context-b context-c : List Sort'} {mc mc' : MetaContext Sort'}
                 (color : Color)
                 (subst : Substitution {(colored-env color)} context-b context-c mc)
                 (sublist : SubList context-a context-c)
                 (msubst : MetaSubstitution env nil mc mc'):
        (\lam (i : Index (context-a ++ context-b)) =>
          MetaSubstitution.apply {env} (inject-monochrome-term color (extend-substitution-left {(colored-env color)} sublist subst i))
              SubList.sublist-trivial-free msubst) = extend-substitution-left {env} sublist (\lam (i : Index (context-b)) => MetaSubstitution.apply {env}
          (inject-monochrome-term color (subst i))
          SubList.sublist-trivial-free msubst) \elim color | red =>  ext (extend-left-commutation red _ _ _)
                                                           | blue => ext (extend-left-commutation blue _ _ _)

      \func untransport {tc : TheoremContext} {s s' : Sort'} {context-a context-c : List Sort'} {mc mc' : MetaContext Sort'}
                        (color : Color)
                        (sublist : SubList context-a context-c)
                        (msubst : MetaSubstitution env nil mc mc')
                        (t : Term (colored-env color) context-c s mc)
                        (eq : s = s')
                        : MetaSubstitution.apply {env} (inject-monochrome-term color
                        (transport (Term (colored-env color) context-c __ mc) eq (t)))
        SubList.sublist-trivial-free msubst = transport (Term env context-c __ mc') eq
      (MetaSubstitution.apply {env} (inject-monochrome-term color t) SubList.sublist-trivial-free msubst) \elim eq
        | idp => idp
    }


    \lemma commutation {tc : TheoremContext} {term-context context : List Sort'} {s : Sort'} {ms-a ms-b : MetaContext Sort'}
                       (metasubst : MetaSubstitution env nil ms-a ms-b)
                       (subst : Substitution {env} term-context context ms-a)
                       (T : Term env term-context s ms-a)
      :
      MetaSubstitution.apply {env}
          (Substitution.apply {env} (T) (subst))
          SubList.sublist-trivial-free
          metasubst =
      Substitution.apply {env}
          (MetaSubstitution.apply {env} (T) (SubList.sublist-trivial-free) metasubst)
          ((\lam i => MetaSubstitution.apply {env} (subst i) SubList.sublist-trivial-free metasubst)) \elim T
      | var index idp => idp
      | metavar m arguments => rewrite (tlcr-over-substitution.commutation.subst-comm {env}) (pmap (Substitution.apply {env} (metasubst m)) (ext (\lam index => commutation metasubst subst (arguments index))))
      | func f arguments => pmap (func {env} (f)) (ext (\lam index => \let inductive => commutation metasubst (append-context-right {env} subst) (arguments index) \in ((rewrite (trivial-sublist-contractible _ (SubList.sublist-trivial-free))) (inductive *> ((rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) (SubList.sublist-trivial-free))) (pmap (Substitution.apply {env} (MetaSubstitution.apply {env} (arguments index) SubList.sublist-trivial-free metasubst)) (append-context-right-commutation.ext' {env} subst metasubst)))))))
      \where {
        \func append-context-right-commutation {env : FSignature} {context-a context-b context-c : List Sort} {ms ms' : MetaContext Sort}
                                               (subst : Substitution context-a context-c ms)
                                               (metasubst : MetaSubstitution env nil ms ms')
                                               (i : Index (context-a ++ context-b))
          : (MetaSubstitution.apply (append-context-right subst i) SubList.sublist-trivial-free metasubst) =
        append-context-right
            (\lam (i : Index context-a) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free metasubst) i =>
          partial-fin-induction
              (\lam ind => (MetaSubstitution.apply (append-context-right subst ind) SubList.sublist-trivial-free metasubst) =
              append-context-right
                  (\lam (i : Index context-a) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free metasubst) ind)
              (\lam i1 => repeat {2} (rewrite (append-context-right.on-begin)) (untransport _ _ _ _))
              (\lam i1 => repeat {2} (rewrite (append-context-right.on-end)) idp)
              i
          \where {
            \func ext' {env : FSignature} {context-a context-b context-c : List Sort} {ms ms' : MetaContext Sort}
                       (subst : Substitution context-a context-c ms)
                       (metasubst : MetaSubstitution env nil ms ms')
              : (\lam (i : Index (context-a ++ context-b)) => MetaSubstitution.apply (append-context-right subst i) SubList.sublist-trivial-free metasubst) =
            append-context-right (\lam (i : Index context-a) => MetaSubstitution.apply (subst i) SubList.sublist-trivial-free metasubst) =>
              ext (append-context-right-commutation _ _)

            \func untransport {env : FSignature} {context-a context-c : List Sort} {s s' : Sort} {ms ms' : MetaContext Sort}
                              (t : Term env context-a s ms)
                              (metasubst : MetaSubstitution env nil ms ms')
                              (sublist : SubList context-a context-c)
                              (eq : s = s')
              : MetaSubstitution.apply
                (weakening (transport (Term env context-a __ ms) eq t)
                    (sublist)) SubList.sublist-trivial-free metasubst = weakening (transport (Term env context-a __ ms') eq
                (MetaSubstitution.apply t SubList.sublist-trivial-free metasubst)) (sublist) \elim t, eq
              | var index p, idp => idp
              | metavar m arguments, idp => \let | inductive i => untransport (arguments i) metasubst sublist idp
                                           | inductive-ext : (\lam i => MetaSubstitution.apply
                                               (weakening ((arguments i)) sublist)
                                               SubList.sublist-trivial-free metasubst) = (\lam i => weakening ((MetaSubstitution.apply (arguments i) SubList.sublist-trivial-free metasubst)) sublist) => ext inductive \in unfold transport (rewrite (weakening.substitution-eq sublist ((Substitution.apply (metasubst m)
                  (\lam (j : Index (nil ++ ms.m-domain m)) => MetaSubstitution.apply (arguments j) SubList.sublist-trivial-free metasubst)))) (rewrite inductive-ext (rewrite (internal-lemma arguments sublist metasubst) (inv (tlcr-over-substitution.commutation.subst-comm _ _ _)))))
              | func f arguments, idp => pmap (func f) (ext (\lam index => repeat {2} (rewrite (trivial-sublist-contractible (SubList.extend-right-single SubList.sublist-trivial-free) (SubList.sublist-trivial-free))) (untransport (arguments index) metasubst (SubList.extend-right-both sublist) idp)))

            \func internal-lemma {env : FSignature} {s : Sort} {context context-b : List Sort} {ms ms' : MetaContext Sort} {m : ms.metaname s}
                                 (arguments : \Pi (index : Index (ms.m-domain m)) -> Term env context (ms.m-domain m !! index) ms)
                                 (sublist : SubList context context-b)
                                 (metasubst : MetaSubstitution env nil ms ms')
              : (\lam (j : Index (nil ++ ms.m-domain m)) =>
                weakening (MetaSubstitution.apply (arguments j) SubList.sublist-trivial-free metasubst) sublist) = (\lam (j : Index (nil ++ ms.m-domain m)) =>
                Substitution.apply (MetaSubstitution.apply (arguments j) SubList.sublist-trivial-free metasubst) (weakening.substitution sublist)) => ext (\lam j => rewrite weakening.substitution-eq idp)
          }
      }

    \lemma twist-application
      {tc : TheoremContext} {context context' : List Sort'} {s : Sort'} {ms : MetaContext Sort'}
      (color : Color)
      (t : Term (colored-env color) context s ms) (subst : Substitution {colored-env color} context context' ms)
      : inject-monochrome-term color (Substitution.apply {colored-env color} t subst) = Substitution.apply {env} (inject-monochrome-term color t) (\lam i => inject-monochrome-term color (subst i)) \elim color, t
      | red, var index p => \case \elim s, \elim p \with {
        | s, idp => idp
      }
      | red, metavar m arguments => pmap (metavar {env} m) (ext (\lam index => twist-application red (arguments index) subst))
      | red, func f arguments => pmap (func {env} (inl f)) (ext (\lam index => rewrite (push-append-context-right red subst) (twist-application red (arguments index) (append-context-right {envL} subst))))
      | blue, var index p => \case \elim s, \elim p \with {
        | s, idp => idp
      }
      | blue, metavar m arguments => pmap (metavar {env} m) (ext (\lam index => twist-application blue (arguments index) subst))
      | blue, func f arguments => pmap (func {env} (inr f)) (ext (\lam index => rewrite (push-append-context-right blue subst) (twist-application blue (arguments index) (append-context-right {envR} subst))))
      \where {
        \lemma push-append-context-right {tc : TheoremContext} {context context' additional-context : List Sort'} {ms : MetaContext Sort'}
                                         (color : Color)
                                         (subst : Substitution {(colored-env color)} context context' ms)
          : (append-context-right {env} {_} {_} {_} (\lam i => inject-monochrome-term color (subst i)) {additional-context}) =
        (\lam i => inject-monochrome-term color (append-context-right {colored-env color} subst i)) =>
          ext (push-append-context-right-ext color subst)

        \lemma push-append-context-right-ext {tc : TheoremContext}
                                             (color : Color)
                                             {context context' additional-context : List Sort'} {ms : MetaContext Sort'}
                                             (subst : Substitution {colored-env color} context context' ms) (index : Index (context ++ additional-context))
          : (append-context-right {env} {_} {_} {_} (\lam i => inject-monochrome-term color (subst i))) {additional-context}  index =
        (inject-monochrome-term color (append-context-right {colored-env color} subst index)) \elim color, context, index
          | red, nil, index => idp
          | red, :: a context, 0 => injection-weakening-commutation red (SubList.extend-right-single SubList.identity) _
          | red, :: a additional-context, suc index => push-append-context-right-ext red (\lam i => subst (suc i)) index
          | blue, nil, index => idp
          | blue, :: a context, 0 => injection-weakening-commutation blue (SubList.extend-right-single SubList.identity) _
          | blue, :: a context, suc index => push-append-context-right-ext blue (\lam i => subst (suc i)) index
      }
  }

\lemma injection-weakening-commutation
  {tc : TheoremContext} (color : Color) {context context' : List Sort'} {ms : MetaContext Sort'} {s : Sort'}
  (sublist : SubList context context')
  (t : Term (colored-env color) context s ms)
  : weakening {env} (inject-monochrome-term color t) sublist = inject-monochrome-term color (weakening {colored-env color} t sublist) \elim color, t
  | red, var index p => idp
  | red, metavar m arguments => pmap (metavar {env} m) (ext (\lam index => injection-weakening-commutation red sublist (arguments index)))
  | red, func f arguments => pmap (func {env} (inl f)) (ext (\lam index => injection-weakening-commutation red (SubList.extend-right-both sublist) (arguments index)))
  | blue, var index p => idp
  | blue, metavar m arguments => pmap (metavar {env} m) (ext (\lam index => injection-weakening-commutation blue sublist (arguments index)))
  | blue, func f arguments => pmap (func {env} (inr f)) (ext (\lam index => injection-weakening-commutation blue (SubList.extend-right-both sublist) (arguments index)))


\func decompose-metasubstitution
  {tc : TheoremContext} {pattern-context core-context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
  (color : Color)
  (l : LinearPattern (colored-env color) pattern-context s)
  (t : Term (colored-env color) (core-context ++ pattern-context) s inner-mc)
  (big-substitution : MetaSubstitution env core-context (LinearMetaContext {colored-env color} l) mc)
  (middle-substitution : MetaSubstitution env nil inner-mc mc)
  (eq :
  MetaSubstitution.apply {env}
      (weakening {env} (inject-monochrome-term color (Linear.convert-to-term {colored-env color} l)) (SubList.extend-left-single SubList.identity {core-context}))
      (SubList.extend-right-single SubList.identity) big-substitution =
  MetaSubstitution.apply {env}
      (inject-monochrome-term color t)
      SubList.sublist-trivial-free
      middle-substitution)
  (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip color) (middle-substitution m))
  : \Sigma (inner-substitution : MetaSubstitution (colored-env color) core-context (LinearMetaContext {colored-env color} l) inner-mc)
           (\Pi {s : Sort'} (m : metaname {LinearMetaContext {colored-env color} l} s) ->
               big-substitution m = MetaSubstitution.apply {env} (inject-monochrome-term color (inner-substitution m)) SubList.sublist-trivial-free middle-substitution)
           (MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (Linear.convert-to-term {colored-env color} l) (SubList.extend-left-single SubList.identity {core-context})) (SubList.extend-right-single SubList.identity) inner-substitution = t)
\elim color, l, t
  | red, l-func f arguments, metavar m arguments1 =>
    \let | opposite-color-for-m => root-colors m
         | colored-root-for-f : HasColoredRoot red (func (inl f)
             (\lam i => MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (ModularMetaContext.upgrade-metavariables {envL}
                 (\lam i => LinearMetaContext {envL} (arguments i)) (Linear.convert-to-term {envL} (arguments i))))
                 (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)) => red-func-root
         | colored-root-for-m : HasColoredRoot red (Substitution.apply {env} (middle-substitution m) (extend-substitution-left {env} SubList.sublist-trivial-free
             (\lam i => MetaSubstitution.apply {env} (Injections.inject-term-left envL envR (arguments1 i)) SubList.sublist-trivial-free middle-substitution))) => rewriteI eq colored-root-for-f
         | empty => decompose-along-reduction.eliminate-colors blue opposite-color-for-m colored-root-for-m
    \in contradiction
  | red, l-func f arguments, func f1 arguments1 =>
    \let | f-eq : f = f1 => pmap (unor f) (pmap (unfunc {env} (inl f)) eq)
    \in inductive-step red f f1 f-eq arguments arguments1 big-substitution middle-substitution root-colors eq
  | red, l-full-metavar, t =>
    (\lam {s1} mvar => transport (\lam sort => Term envL (core-context ++ pattern-context) sort inner-mc) (inv mvar) t,
     \lam {s1} m => \case \elim s, \elim t, \elim big-substitution, \elim eq, \elim m \with {
       | s, t, big-substitution, eq, idp =>
         (rewrite {1} (inv (plain-identity-effect {env} (big-substitution idp))) (pmap (Substitution.apply {env} (big-substitution idp)) (inv (weakening-extension-ext {env})))) *> eq
     },
     (unfold transport (transport (\lam sbst => Substitution.apply {envL} t sbst = t) (inv (weakening-extension-ext {envL} {core-context} {pattern-context} {inner-mc})) (plain-identity-effect {envL} _))))
  | blue, l-func f arguments, metavar m arguments1 =>
    \let | opposite-color-for-m => root-colors m
         | colored-root-for-f : HasColoredRoot blue (func (inr f)
             (\lam i => MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-right envL envR (ModularMetaContext.upgrade-metavariables {envR}
                 (\lam i => LinearMetaContext {envR} (arguments i)) (Linear.convert-to-term {envR} (arguments i))))
                 (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)) => blue-func-root
         | colored-root-for-m : HasColoredRoot blue (Substitution.apply {env} (middle-substitution m) (extend-substitution-left {env} SubList.sublist-trivial-free
             (\lam i => MetaSubstitution.apply {env} (Injections.inject-term-right envL envR (arguments1 i)) SubList.sublist-trivial-free middle-substitution))) => rewriteI eq colored-root-for-f
         | empty => decompose-along-reduction.eliminate-colors red opposite-color-for-m colored-root-for-m
    \in contradiction
  | blue, l-func f arguments, func f1 arguments1 =>
    \let | f-eq : f = f1 => pmap (unor-r f) (pmap (unfunc {env} (inr f)) eq)
    \in inductive-step blue f f1 f-eq arguments arguments1 big-substitution middle-substitution root-colors eq
  | blue, l-full-metavar, t =>
    (\lam {s1} mvar => transport (\lam sort => Term envR (core-context ++ pattern-context) sort inner-mc) (inv mvar) t,
     \lam {s1} m => \case \elim s, \elim t, \elim big-substitution, \elim eq, \elim m \with {
       | s, t, big-substitution, eq, idp =>
         (rewrite {1} (inv (plain-identity-effect {env} (big-substitution idp))) (pmap (Substitution.apply {env} (big-substitution idp)) (inv (weakening-extension-ext {env})))) *> eq
     },
     (unfold transport (transport (\lam sbst => Substitution.apply {envR} t sbst = t) (inv (weakening-extension-ext {envR} {core-context} {pattern-context} {inner-mc})) (plain-identity-effect {envR} _))))
  | _, l-var index p (), t
  \where {
    \lemma unfunc-eq {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort} (f f' : symbol s)
                     (arguments : \Pi (index : Index (domain f)) -> Term env (context ++ (f FSignature.!!param index)) (f FSignature.!!sort index) ms)
                     (arguments' : \Pi (index : Index (domain f')) -> Term env (context ++ (f' FSignature.!!param index)) (f' FSignature.!!sort index) ms)
                     (eq : (func f arguments) = (func f' arguments')) : f = f' => pmap (unfunc f) eq

    \func unfunc {env : FSignature} {context : List Sort} {s : Sort} {ms : MetaContext Sort} (f : symbol s)
                 (T : Term env context s ms) : symbol s \elim T
      | var index p => f
      | metavar m arguments => f
      | func f1 arguments => f1

    \func inductive-step
      {tc : TheoremContext} {pattern-context core-context : List Sort'} {s : Sort'} {inner-mc mc : MetaContext Sort'}
      (color : Color)
      (f : symbol {colored-env color} s)
      (f1 : symbol {colored-env color} s)
      (eq : f = f1)
      (arguments :
      \Pi (index : Index (domain {colored-env color} f)) ->
          LinearPattern (colored-env color) (pattern-context ++ f FSignature.!!param {colored-env color} index) (f FSignature.!!sort {colored-env color} index))
      (arguments1 :
      \Pi (index : Index (domain {colored-env color} f1)) ->
          Term (colored-env color) ((core-context ++ pattern-context) ++ f1 FSignature.!!param {colored-env color} index) (f1 FSignature.!!sort {colored-env color} index)
              inner-mc)
      (big-substitution : MetaSubstitution env core-context (LinearMetaContext {colored-env color} (l-func f arguments)) mc)
      (middle-substitution : MetaSubstitution env nil inner-mc mc)
      (root-colors : \Pi {s : Sort'} (m : inner-mc.metaname s) -> HasColoredRoot (Color.flip color) (middle-substitution m))
      (eq' : MetaSubstitution.apply {env}
          (weakening {env} (inject-monochrome-term color (Linear.convert-to-term {colored-env color} (l-func {colored-env color} f arguments))) (SubList.extend-left-single SubList.identity {core-context}))
          (SubList.extend-right-single SubList.identity) big-substitution =
      MetaSubstitution.apply {env}
          (inject-monochrome-term color (func {colored-env color} f1 arguments1))
          SubList.sublist-trivial-free
          middle-substitution):
      \Sigma (inner-substitution : MetaSubstitution (colored-env color) core-context (LinearMetaContext {colored-env color} (l-func f arguments)) inner-mc)
             (\Pi {s : Sort'} (m : metaname {LinearMetaContext {colored-env color} (l-func f arguments)} s) ->
                 big-substitution m = MetaSubstitution.apply {env} (inject-monochrome-term color (inner-substitution m)) SubList.sublist-trivial-free middle-substitution)
             (MetaSubstitution.apply {colored-env color} (weakening {colored-env color} (Linear.convert-to-term {colored-env color} (l-func f arguments)) (SubList.extend-left-single SubList.identity {core-context})) (SubList.extend-right-single SubList.identity) inner-substitution = (func f1 arguments1))
    \elim color, eq
      | red, idp =>
        \let | args-eq i  : (MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (ModularMetaContext.upgrade-metavariables {envL}
            (\lam i => LinearMetaContext {envL} (arguments i)) (Linear.convert-to-term {envL} (arguments i))))
            (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)
          =
        (MetaSubstitution.apply {env}
            (Injections.inject-term-left envL envR (arguments1 i)) (SubList.extend-right-single SubList.sublist-trivial-free)
            middle-substitution) =>
          (\let | sigmas-or =>  (pmap (alternate-subst.unwrap-func {env}) eq')
                | inf : env.symbol s => inl f
                | z => pmap (unor-r {Nat} {(\Sigma (f : symbol {env} s) (\Pi (index : Index (domain {env} f)) ->
                    Term env ((core-context ++ pattern-context) ++ f env.!!param index) (f env.!!sort index)
                        mc))} ((inl {_} {envR.symbol s} f, \lam i => MetaSubstitution.apply {env}
                    (Injections.inject-term-left envL envR (arguments1 i)) (SubList.extend-right-single SubList.sublist-trivial-free)
                    middle-substitution))) sigmas-or
                | rhs => sigmas-or @ left
                | res => alternate-subst.sigma-set-equalizer {symbol {env} s} ((\lam f => \Pi (index : Index (domain {env} f)) ->
                    Term env ((core-context ++ pattern-context) ++ f env.!!param index) (f env.!!sort index)
                        mc)) {inl f} z
                | res' => pmap (__ i) res
           \in res')
             | inductive i => decompose-metasubstitution red
                 (arguments i)
                 (transport (Term envL __ _ inner-mc) (++-assoc {_} {core-context} {pattern-context} {f1 envL.!!param i}) (arguments1 i))
                 (\lam m => big-substitution (i, m))
                 middle-substitution
                 (\let ind : ( MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-left envL envR (ModularMetaContext.upgrade-metavariables {envL}
                     (\lam i => LinearMetaContext {envL} (arguments i)) (Linear.convert-to-term {envL} (arguments i))))
                     (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)
                   =
                 (MetaSubstitution.apply {env}
                     (Injections.inject-term-left envL envR (arguments1 i)) (SubList.extend-right-single SubList.sublist-trivial-free)
                     middle-substitution) => args-eq i \in apply-modularity-colored red (\lam i => LinearMetaContext {envL} (arguments i)) (\lam j m => big-substitution (j, m)) _ _ _ *> (rewrite Transports.lb-ls-to-ls.inv' (rewrite Transports.rs-rs-to-rs.inv' (rewrite Transports.nil-to-right-nil (ad-hoc-lemma red (\lam i => LinearMetaContext {envL} (arguments i))  (Linear.convert-to-term {envL} (arguments i)) ++-assoc _ _ (\lam {s1} m => big-substitution (m.1, m.2)) (arguments1 i) middle-substitution _ ind))))
                 )
                 root-colors
        \in (\lam {s1} mvar => (inductive mvar.1).1 mvar.2,
             \lam {s1} m => (inductive m.1).2 m.2,
             pmap (func {envL} f1) (ext (\lam index =>
                 \let ind => (inductive index).3
                 \in rewrite (inv (alternate-subst.apply-modularity {envL}
                     (\lam i => LinearMetaContext {envL} (arguments i))
                     (\lam i => (inductive i).1)
                     (SubList.extend-right-single (SubList.extend-right-single SubList.identity))
                     (SubList.extend-right-both (SubList.extend-left-single SubList.identity))
                     (Linear.convert-to-term {envL} (arguments index))))
                     (rewrite Transports.lb-ls-to-ls
                         (rewrite Transports.rs-rs-to-rs
                             (expand-substitution-3 {envL} _ _ _ _ _ _ ind))))))
      | blue, idp =>
        \let | args-eq i  : (MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-right envL envR (ModularMetaContext.upgrade-metavariables {envR}
            (\lam i => LinearMetaContext {envR} (arguments i)) (Linear.convert-to-term {envR} (arguments i))))
            (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)
          =
        (MetaSubstitution.apply {env}
            (Injections.inject-term-right envL envR (arguments1 i)) (SubList.extend-right-single SubList.sublist-trivial-free)
            middle-substitution) =>
          (\let | sigmas-or =>  (pmap (alternate-subst.unwrap-func {env}) eq')
                | z => pmap (unor-r {Nat} {(\Sigma (f : symbol {env} s) (\Pi (index : Index (domain {env} f)) ->
                    Term env ((core-context ++ pattern-context) ++ f env.!!param index) (f env.!!sort index)
                        mc))} ((inr {envL.symbol s} {_} f, \lam i => MetaSubstitution.apply {env}
                    (Injections.inject-term-right envL envR (arguments1 i)) (SubList.extend-right-single SubList.sublist-trivial-free)
                    middle-substitution))) sigmas-or
                | res => alternate-subst.sigma-set-equalizer {symbol {env} s} ((\lam f => \Pi (index : Index (domain {env} f)) ->
                    Term env ((core-context ++ pattern-context) ++ f env.!!param index) (f env.!!sort index)
                        mc)) {inr f} z
                | res' => pmap (__ i) res
           \in res')
             | inductive i => decompose-metasubstitution blue
                 (arguments i)
                 (transport (Term envR __ _ inner-mc) (++-assoc {_} {core-context} {pattern-context} {f1 envR.!!param i}) (arguments1 i))
                 (\lam m => big-substitution (i, m))
                 middle-substitution
                 (\let ind : ( MetaSubstitution.apply {env} (weakening {env} (Injections.inject-term-right envL envR (ModularMetaContext.upgrade-metavariables {envR}
                     (\lam i => LinearMetaContext {envR} (arguments i)) (Linear.convert-to-term {envR} (arguments i))))
                     (SubList.extend-right-both (SubList.extend-left-single SubList.identity {core-context}))) (SubList.extend-right-single (SubList.extend-right-single SubList.identity)) big-substitution)
                   =
                 (MetaSubstitution.apply {env}
                     (Injections.inject-term-right envL envR (arguments1 i)) (SubList.extend-right-single SubList.sublist-trivial-free)
                     middle-substitution) => args-eq i \in apply-modularity-colored blue (\lam i => LinearMetaContext {envR} (arguments i)) (\lam j m => big-substitution (j, m)) _ _ _ *> (rewrite Transports.lb-ls-to-ls.inv' (rewrite Transports.rs-rs-to-rs.inv' (rewrite Transports.nil-to-right-nil (ad-hoc-lemma blue (\lam i => LinearMetaContext {envR} (arguments i))  (Linear.convert-to-term {envR} (arguments i)) ++-assoc _ _ (\lam {s1} m => big-substitution (m.1, m.2)) (arguments1 i) middle-substitution _ ind))))
                 )
                 root-colors
        \in (\lam {s1} mvar => (inductive mvar.1).1 mvar.2,
             \lam {s1} m => (inductive m.1).2 m.2,
             pmap (func {envR} f1) (ext (\lam index =>
                 \let ind => (inductive index).3
                 \in rewrite (inv (alternate-subst.apply-modularity {envR}
                     (\lam i => LinearMetaContext {envR} (arguments i))
                     (\lam i => (inductive i).1)
                     (SubList.extend-right-single (SubList.extend-right-single SubList.identity))
                     (SubList.extend-right-both (SubList.extend-left-single SubList.identity))
                     (Linear.convert-to-term {envR} (arguments index))))
                     (rewrite (Transports.lb-ls-to-ls)
                         (rewrite Transports.rs-rs-to-rs
                             (expand-substitution-3 {envR} _ _ _ _ _ _ ind))))))

    \lemma ad-hoc-lemma
      {tc : TheoremContext} {subst-context context big-context big-context' : List Sort'} {s : Sort'} {ms-a ms-b : MetaContext Sort'}
      {n : Nat} {index : Fin n}
      (color : Color)
      (producer : Fin n -> MetaContext Sort')
      (term : Term (colored-env color) context s (producer index))
      (eq : big-context = big-context')
      (sublist : SubList context big-context)
      (sublist' : SubList subst-context big-context)
      (msubst : MetaSubstitution env subst-context (ModularMetaContext {env} producer) ms-b)
      (S : Term (colored-env color) big-context s ms-a)
      (msubst' : MetaSubstitution env nil ms-a ms-b)
      (sublist'' : SubList nil big-context)
      (target-eq : MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color (ModularMetaContext.upgrade-metavariables {colored-env color} producer term)) sublist) sublist' msubst = MetaSubstitution.apply {env} (inject-monochrome-term color S) sublist'' msubst')
      : MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color (ModularMetaContext.upgrade-metavariables {colored-env color} producer term)) (transport (SubList context) eq sublist)) (transport (SubList subst-context) eq sublist') msubst = MetaSubstitution.apply {env} (inject-monochrome-term color (transport (Term (colored-env color) __ s ms-a) eq S)) (transport (SubList nil) eq sublist'') msubst' \elim color, eq
      | red, idp => target-eq
      | blue, idp => target-eq
  }


\lemma weakening-extension-ext {env : FSignature} {left-context right-context : List Sort} {mc : MetaContext Sort}
  : extend-substitution-left {_} {left-context} {right-context} (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) = plain-identity {_} {_} {mc}
  => ext (weakening-extension)

\lemma weakening-extension {env : FSignature} {left-context right-context : List Sort} {mc : MetaContext Sort}
                          (i : Index (left-context ++ right-context))
  : extend-substitution-left (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i = plain-identity {_} {_} {mc} i =>
  partial-fin-induction
      (\lam i =>
          extend-substitution-left (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i
            =
          plain-identity {_} {_} {mc} i)
      (\lam i1 => \let | q => extend-substitution-left.on-begin (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i1
                  \in q *> (var-extensionality (Shifts.over-right-single _)))
      (\lam i1 => \let | q => extend-substitution-left.on-end (SubList.extend-right-single SubList.identity) (\lam i => weakening (var i idp) (SubList.extend-left-single SubList.identity)) i1
                       | big-eq => Shifts.left-extension {Sort} {left-context} {right-context} i1
                  \in q *> (rewrite (pmap to-var big-eq) (append-context-right.to-identity.lem2 (expand-fin-right i1) (expand-fin-right i1) (inv (expand-fin-right-eq i1)) idp (inv (expand-fin-right-eq i1)) idp)))
      i

\lemma expand-substitution-3 {env : FSignature} {term-context ms-context big-context big-context' : List Sort} {s : Sort} {ms ms' : MetaContext Sort}
                             (T : Term env term-context s ms)
                             (msubst : MetaSubstitution env ms-context ms ms')
                             (sublist : SubList term-context big-context)
                             (sublist' : SubList ms-context big-context)
                             (S : Term env big-context' s ms')
                             (eq : big-context' = big-context)
                             (target : MetaSubstitution.apply (weakening T sublist) sublist' msubst = transport (Term env __ s ms') eq S)
  : MetaSubstitution.apply (weakening T (transport (SubList term-context) (inv eq) sublist)) (transport (SubList ms-context) (inv eq) sublist') msubst = S \elim eq
  | idp => target

\lemma apply-modularity-colored
  {tc : TheoremContext} {context subst-context pattern-context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} {n : Nat} {index : Fin n}
  (color : Color)
  (producer : Fin n -> MetaContext Sort')
  (substitutions : \Pi (i : Fin n) -> MetaSubstitution env subst-context (producer i) mc)
  (sublist : SubList subst-context context)
  (pat-sublist : SubList pattern-context context)
  (t : Term (colored-env color) pattern-context s (producer index)) :
  MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color t) pat-sublist) sublist (substitutions index) = MetaSubstitution.apply {env} (weakening {env} (inject-monochrome-term color (ModularMetaContext.upgrade-metavariables {colored-env color} producer t)) pat-sublist) sublist (\lam m => substitutions m.1 m.2) \elim color, t
  | red, var index1 p => idp
  | red, metavar m arguments => pmap (\lam e => Substitution.apply {env} (substitutions index m) (extend-substitution-left {env} sublist e)) (ext (\lam i => apply-modularity-colored red producer substitutions sublist pat-sublist (arguments i)))
  | red, func f arguments => pmap (func {env} (inl f)) (ext (\lam i => apply-modularity-colored red producer substitutions (SubList.extend-right-single sublist) (SubList.extend-right-both pat-sublist) (arguments i)))
  | blue, var index1 p => idp
  | blue, metavar m arguments => pmap (\lam e => Substitution.apply {env} (substitutions index m) (extend-substitution-left {env} sublist e)) (ext (\lam i => apply-modularity-colored blue producer substitutions sublist pat-sublist (arguments i)))
  | blue, func f arguments => pmap (func {env} (inr f)) (ext (\lam i => apply-modularity-colored blue producer substitutions (SubList.extend-right-single sublist) (SubList.extend-right-both pat-sublist) (arguments i)))
