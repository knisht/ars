\import Data.List (++, List, nil)
\import Data.Or
\import Paths
\import Paths.Meta
\import Set
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.TRS
\import TRS.Union
\import TRS.Utils
\open Confluence
\open TheoremContext

\func fill-confluence {tc : TheoremContext} {context : List Sort'} {s : Sort'}
                      (A B C : Term env context s (EmptyMetasignature {env}))
                      (A~>B : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) A B)
                      (A~>C : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) A C)
                      (l-confluential : ConfluentialSystem envL L-rules)
                      (r-confluential : ConfluentialSystem envR R-rules)
                      (all-rules-are-linear :
                      \Pi (point : L-rules.J `Or` R-rules.J) ->
                          \Sigma (color : Color)
                                 (linear-pattern : LinearPattern (colored-env {tc} color) nil (RewriteRule.s {(get {(JointRules {Sort'} {envL} {envR} L-rules R-rules)} point)}))
                                 (meta-eq : RewriteRule.meta-signature {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)} = LinearMetasignature {colored-env {tc} color} linear-pattern)
                                 (LinearPattern.convert-to-injected-term {tc} color linear-pattern = transport (Term env nil (RewriteRule.s {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)})) meta-eq (RewriteRule.l {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)})))
  : StraightJoin B C (Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules))) =>
  \let | lifted-a => Closure.lift
      {Term env context s (EmptyMetasignature {env})}
      {Term env context s (EmptyMetasignature {env})}
      {RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)}
      {TrichromaticParallelReduction {tc}}
      (\lam t => t)
      (\lam {x} {y} rel => embed-rewrite-relation x y rel all-rules-are-linear) A B A~>B
       | lifted-b => Closure.lift
           {Term env context s (EmptyMetasignature {env})}
           {Term env context s (EmptyMetasignature {env})}
           {RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)}
           {TrichromaticParallelReduction {tc}}
           (\lam t => t)
           (\lam {x} {y} rel => embed-rewrite-relation x y rel all-rules-are-linear) A C A~>C
       | joins => unify-reduction A B C lifted-a lifted-b (\lam a b c a->b a->c => \let (D, m1, m2, b->D, c->D) => bpr-confluence a->b.2 a->c.2 a->b.3 a->c.3 l-confluential r-confluential \in (D, (a->c.1, m1, b->D), (a->b.1, m2, c->D)))
       | long-closure-b-w => Closure.lift {_} {_}
           {TrichromaticParallelReduction}
           {Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules))}
           (\lam x => x)
           (\lam {a} {b} bpr => unembed-rewrite-relation bpr.2 bpr.3)
           B joins.1 joins.2
       | long-closure-c-w => Closure.lift {_} {_}
           {TrichromaticParallelReduction}
           {Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules))}
           (\lam x => x)
           (\lam {a} {b} bpr => unembed-rewrite-relation bpr.2 bpr.3)
           C joins.1 joins.3
  \in \new StraightJoin {
    | common-reduct => joins.1
    | a~>cr => Closure.flatten long-closure-b-w
    | b~>cr => Closure.flatten long-closure-c-w
  }

\func unify-reduction
  {A : \Type} {Rel : A -> A -> \Type} (x y z : A)
  (x->y : Closure Rel x y) (x->z : Closure Rel x z)
  (unifier : \Pi (a b c : A) (a->b : Rel a b) (a->c : Rel a c) -> \Sigma (d : A) (b->d : Rel b d) (c->d : Rel c d))
  : \Sigma (w : A) (y->w : Closure Rel y w) (z->w : Closure Rel z w) \elim x->y
  | c-trivial idp => (z, x->z, c-trivial idp)
  | c-basic x->y => unify-line x y z x->y x->z unifier
  | c-connect c x->c c->y => \let | (w, c->w, z->w) => unify-line x c z x->c x->z unifier
                                  | (w', y->w', w->w') => unify-reduction c y w c->y c->w unifier
                             \in (w', y->w', Closure.concat z->w w->w')
  \where {
    \func unify-line
      {A : \Type} {Rel : A -> A -> \Type} (x y z : A)
      (x->y : Rel x y) (x->z : Closure Rel x z)
      (unifier : \Pi (a b c : A) (a->b : Rel a b) (a->c : Rel a c) -> \Sigma (d : A) (b->d : Rel b d) (c->d : Rel c d))
      : \Sigma (w : A) (y->w : Closure Rel y w) (z->w : Closure Rel z w) \elim x->z
      | c-trivial idp => (y, c-trivial idp, c-basic x->y)
      | c-basic x->z => \let (w, y->w, z->w) => unifier x y z x->y x->z \in (w, c-basic y->w, c-basic z->w)
      | c-connect c x->c c->z =>
        \let | (w, y->w, c->w) => unifier x y c x->y x->c
             | (w', w->w', z->w') => unify-line c w z c->w c->z unifier
        \in (w', c-connect w y->w w->w', z->w')
  }

\func embed-rewrite-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'}
                             (A B : Term env context s (EmptyMetasignature {env}))
                             (A~>B : RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules) A B)
                             (all-rules-are-linear :
                             \Pi (point : L-rules.J `Or` R-rules.J) ->
                                 \Sigma (color : Color)
                                        (linear-pattern : LinearPattern (colored-env {tc} color) nil (RewriteRule.s {(get {(JointRules {Sort'} {envL} {envR} L-rules R-rules)} point)}))
                                        (meta-eq : RewriteRule.meta-signature {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)} = LinearMetasignature {colored-env {tc} color} linear-pattern)
                                        (LinearPattern.convert-to-injected-term {tc} color linear-pattern = transport (Term env nil (RewriteRule.s {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)})) meta-eq (RewriteRule.l {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)})))
  : TrichromaticParallelReduction A B \elim A, B, A~>B
  | var index p, B, rewrite-with-rule ((rule,msubst,l-coherence,r-coherence)) i => ({?}, {?}, {?})
  | func f choosing1, B, rewrite-with-rule ((rule : RewriteRule (env {tc}) {s},subst,l-coherence,r-coherence)) (point,rules[point]=rule)
  =>
    \let | (color, lp, meta-eq, lp=l) => all-rules-are-linear point
         | color-eq : (TheoremContext.color-of-root f) = color => {?}
         | sort-eq : RewriteRule.s {get {(JointRules {Sort'} {envL} {envR} L-rules R-rules)} point} = s => rewrite rules[point]=rule idp
         | unified => unify-tlcr (color) (rule.l) rule.r (sort-eq) lp (rewriteI rules[point]=rule meta-eq) (lp=l *> {?}) subst (func f choosing1) B l-coherence r-coherence
    \in
      ((TheoremContext.color-of-root f),
       just (color),
       parallelization-f
           (choosing1)
           (\lam i1 => (nothing, inl idp, equal-trees idp))
           (cr-rewrite (tc-basic (rewrite-with-rule-colored {?} (unified.1) (unified.2) {?} unified.3 unified.4 unified.5)) color-eq))
  | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f idp index rd eq =>
    \let | (global-color, color, bpr) => embed-rewrite-relation (choosing-A index) (choosing-B index) rd all-rules-are-linear
         | (someColor, mediator, inrd, cwr) => collect-reductions-together-raw {_} {_} {_} {_} {global-color} f-A choosing-A choosing-B (\lam i => \case (FinDec i index) \with {
           | yes e => rewrite e (color, bpr)
           | no n => (nothing, equal-trees (eq i n))
         })
    \in (global-color, someColor, parallelization-f mediator inrd cwr)
  | metavar () choosing-A, _, _
  \where {
    \func unify-tlcr
      {tc : TheoremContext} {context : List Sort'} {s s' : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
      (color : Color)
      (old-l old-r : Term env nil s inner-meta-signature)
      (eq : s' = s)
      (new-l : LinearPattern (colored-env color) nil s')
      (ms-eq : inner-meta-signature = LinearMetasignature {TheoremContext.colored-env color} new-l)
      (lp=l : LinearPattern.convert-to-injected-term color new-l = transport (Term env nil s') ms-eq (transport (Term env nil __ inner-meta-signature) (inv eq) old-l))
      (subst : MetaSubstitution env context inner-meta-signature meta-signature)
      (A B : Term env context s meta-signature)
      (l-coherence : MetaSubstitution.apply {env} (weakening {env} (old-l) SubList.sublist-trivial-skip) SubList.identity subst = A)
      (r-coherence : MetaSubstitution.apply {env} (weakening {env} (old-r) SubList.sublist-trivial-skip) SubList.identity subst = B)
      : \Sigma (new-lp : LinearPattern (colored-env color) nil s)
               (new-r : Term (TheoremContext.colored-env color) nil s (LinearMetasignature {TheoremContext.colored-env color} new-lp))
               (new-subst : MetaSubstitution env context (LinearMetasignature {TheoremContext.colored-env color} new-lp) meta-signature)
               (new-l-coherence : MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-injected-term color new-lp) SubList.sublist-trivial-skip) SubList.identity new-subst = A)
               (new-r-coherence : MetaSubstitution.apply {env} (weakening {env} (TheoremContext.inject-monochrome-term color new-r) SubList.sublist-trivial-skip) SubList.identity new-subst = B) \elim eq
      | idp => \case \elim inner-meta-signature, \elim old-l, \elim old-r, \elim ms-eq, \elim lp=l, \elim subst, \elim l-coherence \with {
        | inner-meta-signature, old-l, old-r, idp, idp, subst, l-coherence => (new-l, {?}, subst, l-coherence, {?})
      }
  }

\func unembed-rewrite-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
                               {gc : Color}
                               (color : Maybe Color)
                               {A B : Term env context s meta-signature}
                               (A=>B : BorderedParallelReduction gc color A B)
  : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) A B \elim color, A, A=>B
  | color, A, equal-trees p => c-trivial p
  | color, func f choosing, parallelization-f mediator _x c =>
    \let | from-indices i => unembed-rewrite-relation (_x i).1 (_x i).3
         | joined : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (func {env} f choosing) (func f mediator) => {?}
         | from-cwr : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (func {env} f mediator) B => {?}
    \in Closure.concat joined from-cwr


--\func unembed-tlcr {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
--                   (color : Color)
--                   {A B : Term env context s meta-signature}
--                   (A=>B : TopLevelColoredReduction color A B)
--  : RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules) A B \elim A, B, A=>B
--  | A, B, rewrite-with-rule-colored h step => rewrite-with-rule step {?}
--  | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => {?}
