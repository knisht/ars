\import Data.List (++, List, nil)
\import Data.Or
\import Paths
\import Paths.Meta
\import Set
\import TRS.HRS
\import TRS.Linearity
\import TRS.List
\import TRS.Maybe
\import TRS.Substitutions
\import TRS.Union
\import TRS.Utils
\open Confluence
\open TheoremContext

--\func fill-confluence {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
--                      (A B C : Term env context s meta-signature)
--                      (A~>B : RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules) A B)
--                      (A~>C : RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules) A C)
--                      (l-confluential : ConfluentialSystem envL L-rules)
--                      (r-confluential : ConfluentialSystem envR R-rules)
--  : StraightJoin B C (Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules))) =>
--  \let | A=>B => embed-rewrite-relation A B A~>B
--       | A=>C => embed-rewrite-relation A C A~>C
--       | grand-result : StraightJoin B C (Closure TrichromaticParallelReduction) => bpr-confluence A=>B.1 A=>C.1 A=>B.2 A=>C.2 l-confluential r-confluential
--  \in \new StraightJoin {
--    | common-reduct => grand-result.common-reduct
--    | a~>cr => \let closure-sequence => Closure.lift {_} {_} {_}
--        {Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules))} (\lam x => x)
--        (\lam tpr => unembed-rewrite-relation tpr.1 tpr.2) B grand-result.common-reduct grand-result.a~>cr
--               \in Closure.flatten closure-sequence
--    | b~>cr => \let closure-sequence => Closure.lift {_} {_} {_}
--        {Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules))} (\lam x => x)
--        (\lam tpr => unembed-rewrite-relation tpr.1 tpr.2) C grand-result.common-reduct grand-result.b~>cr
--               \in Closure.flatten closure-sequence
--  }

\func embed-rewrite-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'}
                             (A B : Term env context s (EmptyMetasignature {env}))
                             (A~>B : RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules) A B)
                             (all-rules-are-linear :
                             \Pi (point : L-rules.J `Or` R-rules.J) ->
                                 \Sigma (color : Color)
                                        (linear-pattern : LinearPattern (colored-env {tc} color) nil (RewriteRule.s {(get {(JointRules {Sort'} {envL} {envR} L-rules R-rules)} point)}))
                                        (meta-eq : RewriteRule.meta-signature {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)} = LinearMetasignature {colored-env {tc} color} linear-pattern)
                                        (LinearPattern.convert-to-injected-term {tc} color linear-pattern = transport (Term env nil (RewriteRule.s {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)})) meta-eq (RewriteRule.l {(get {(JointRules {_} {envL} {envR} L-rules R-rules)} point)})))
  : TrichromaticParallelReduction A B \elim A, B, A~>B
  | var index p, B, rewrite-with-rule ((rule,msubst,l-coherence,r-coherence)) i => ({?}, {?}, {?})
  | func f choosing1, B, rewrite-with-rule ((rule : RewriteRule (env {tc}) {s},subst,l-coherence,r-coherence)) (point,rules[point]=rule)
  =>
    \let | (color, lp, meta-eq, lp=l) => all-rules-are-linear point
         | color-eq : (TheoremContext.color-of-root f) = color => {?}
         | sort-eq : RewriteRule.s {get {(JointRules {Sort'} {envL} {envR} L-rules R-rules)} point} = s => rewrite rules[point]=rule idp
         | unified => unify-tlcr (color) (rule.l) rule.r (sort-eq) lp (rewriteI rules[point]=rule meta-eq) (lp=l *> {?}) subst (func f choosing1) B l-coherence r-coherence
    \in
      ((TheoremContext.color-of-root f),
       just (color),
       parallelization-f
           (choosing1)
           (\lam i1 => (nothing, inl idp, equal-trees idp))
           (cr-rewrite (tc-basic (rewrite-with-rule-colored {?} (unified.1) (unified.2) {?} unified.3 unified.4 unified.5)) color-eq))
  | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f idp index rd eq =>
    \let | (global-color, color, bpr) => embed-rewrite-relation (choosing-A index) (choosing-B index) rd all-rules-are-linear
         | (someColor, mediator, inrd, cwr) => collect-reductions-together-raw {_} {_} {_} {_} {global-color} f-A choosing-A choosing-B (\lam i => \case (FinDec i index) \with {
           | yes e => rewrite e (color, bpr)
           | no n => (nothing, equal-trees (eq i n))
         })
    \in (global-color, someColor, parallelization-f mediator inrd cwr)
  | metavar () choosing-A, _, _
  \where {
    \func unify-tlcr
      {tc : TheoremContext} {context : List Sort'} {s s' : Sort'} {inner-meta-signature meta-signature : MetaSignature Sort'}
      (color : Color)
      (old-l old-r : Term env nil s inner-meta-signature)
      (eq : s' = s)
      (new-l : LinearPattern (colored-env color) nil s')
      (ms-eq : inner-meta-signature = LinearMetasignature {TheoremContext.colored-env color} new-l)
      (lp=l : LinearPattern.convert-to-injected-term color new-l = transport (Term env nil s') ms-eq (transport (Term env nil __ inner-meta-signature) (inv eq) old-l))
      (subst : MetaSubstitution env context inner-meta-signature meta-signature)
      (A B : Term env context s meta-signature)
      (l-coherence : MetaSubstitution.apply {env} (weakening {env} (old-l) SubList.sublist-trivial-skip) SubList.identity subst = A)
      (r-coherence : MetaSubstitution.apply {env} (weakening {env} (old-r) SubList.sublist-trivial-skip) SubList.identity subst = B)
      : \Sigma (new-lp : LinearPattern (colored-env color) nil s)
               (new-r : Term (TheoremContext.colored-env color) nil s (LinearMetasignature {TheoremContext.colored-env color} new-lp))
               (new-subst : MetaSubstitution env context (LinearMetasignature {TheoremContext.colored-env color} new-lp) meta-signature)
               (new-l-coherence : MetaSubstitution.apply {env} (weakening {env} (LinearPattern.convert-to-injected-term color new-lp) SubList.sublist-trivial-skip) SubList.identity new-subst = A)
               (new-r-coherence : MetaSubstitution.apply {env} (weakening {env} (TheoremContext.inject-monochrome-term color new-r) SubList.sublist-trivial-skip) SubList.identity new-subst = B) \elim eq
      | idp => \case \elim inner-meta-signature, \elim old-l, \elim old-r, \elim ms-eq, \elim lp=l, \elim subst, \elim l-coherence \with {
        | inner-meta-signature, old-l, old-r, idp, idp, subst, l-coherence => (new-l, {?}, subst, l-coherence, {?})
      }

  }

--\func unembed-rewrite-relation {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
--                               (color : Maybe Color)
--                               {A B : Term env context s meta-signature}
--                               (A=>B : BorderedParallelReduction color A B)
--  : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) A B \elim color, A, B, A=>B
--  | color, A, B, equal-trees p => c-trivial p
--  | just color, A, B, reduction-top-level t => c-basic (unembed-tlcr color t)
--  | nothing, func f-A choosing-A, func f-B choosing-B, reduction-subterms f-A=f-B _x => redirection f-A f-B f-A=f-B choosing-A choosing-B _x
--  \where {
--    \func redirection {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
--                      (f-A f-B : env.FunctionalSymbol.symbol s)
--                      (f-A=f-B : f-A = f-B)
--                      (choosing-A : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-A))) -> Term env ((f-A FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-A FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
--                      (choosing-B : \Pi (index : Fin (length (env.FunctionalSymbol.domain f-B))) -> Term env ((f-B FunctionalSignature.!!param {_} {FunctionalSymbol {env {tc}}} index) ++ context) (f-B FunctionalSignature.!!sort {_} {FunctionalSymbol {env {tc}}} index) meta-signature)
--                      (args : (\Pi (i : F-param-index {Sort' {tc}} {FunctionalSymbol {env {tc}}} f-A) -> \Sigma
--                        (someColor : Maybe Color)
--                        ((someColor = nothing) `Or` (someColor = just (Color.flip (color-of-root {tc} f-A))))
--                        (BorderedParallelReduction {tc} someColor (choosing-A i) (transport-chooser-f {env {tc}} f-A=f-B choosing-B i))))
--      : Closure (RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules)) (func {env} f-A choosing-A) (func f-B choosing-B) \elim f-A=f-B
--      | idp => gather-closure-regular f-A choosing-A choosing-B (\lam i => unembed-rewrite-relation (args i).1 (args i).3)
--  }
--
--\func unembed-tlcr {tc : TheoremContext} {context : List Sort'} {s : Sort'} {meta-signature : MetaSignature Sort'}
--                   (color : Color)
--                   {A B : Term env context s meta-signature}
--                   (A=>B : TopLevelColoredReduction color A B)
--  : RewriteRelation {env} (JointRules {_} {envL} {envR} L-rules R-rules) A B \elim A, B, A=>B
--  | A, B, rewrite-with-rule-colored h step => rewrite-with-rule step {?}
--  | func f-A choosing-A, func f-B choosing-B, rewrite-with-parameter-f-colored p p1 r => {?}
