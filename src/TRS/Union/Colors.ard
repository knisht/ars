\import Data.List \hiding (Sort)
\import Data.Or
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import TRS.Data.Fin
\import TRS.HRS
\import TRS.Linearity
\import TRS.MetaContexts
\import TRS.Union
\import TRS.Union.Confluence
\import TRS.Utils

\data Color | red | blue \where {
  \func flip (c : Color) : Color \elim c
    | red => blue
    | blue => red

  \lemma double-flip (c : Color) : Color.flip (Color.flip c) = c \elim c
    | red => idp
    | blue => idp

  \lemma flip-contradiction {c : Color} (eq : c = flip c) : Empty \elim c
    | red => contradiction
    | blue => contradiction

  \func inject {A B : \Type} (c : Color) (t : \case \elim c \with {| red => A | blue => B }) : Or A B \elim c
    | red => inl t
    | blue => inr t
}

\class TheoremContext {
  | Sort' : \Set
  | envL : FSignature Sort'
  | envR : FSignature Sort'
  | L-rules : RuleRegistry envL
  | R-rules : RuleRegistry envR

  \func lfunc => func {envL}

  \func rfunc => func {envR}

  \func efunc => func {env}

  \func colored-env (color : Color) : FSignature Sort' \elim color
    | red => envL
    | blue => envR

  \func colored-rule-registry (color : Color) : RuleRegistry (colored-env {\this} color) \elim color
    | red => L-rules
    | blue => R-rules

  \func monochrome-reduction (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (A B : Term (colored-env color) context s mc) : \Type =>
    RewriteRelation {colored-env color} (colored-rule-registry color) A B

  \func JRegistry : RuleRegistry (JointFSignature envL envR) => JointRegistry envL envR L-rules R-rules

  \func inject-monochrome-term (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                               (t : Term (colored-env color) context s mc) : Term env context s mc \elim color
    | red => Injections.inject-term-left envL envR t
    | blue => Injections.inject-term-right envL envR t
    \where {
      \data InjectionWitness (color : Color) {context : List Sort'} {s : Sort'} {msig : MetaContext Sort'} (t : Term env context s msig) \elim t
        | func f arguments => iw-func (color-of-root f = color)
                                      (\Pi (i : Index (env.domain f)) -> InjectionWitness color (arguments i))
        | metavar m arguments => iw-mvar (\Pi (i : Index (msig.m-domain m)) -> InjectionWitness color (arguments i))
        | var _ _ => iw-var

      \lemma generate-injection-witness (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                                        (t : Term (colored-env color) context s mc) : InjectionWitness color (inject-monochrome-term color t) \elim color, t
        | red, func f arguments => iw-func idp (\lam i => generate-injection-witness red (arguments i))
        | red, var index p => iw-var
        | red, metavar m arguments => iw-mvar (\lam i => generate-injection-witness red (arguments i))
        | blue, var index p => iw-var
        | blue, metavar m arguments => iw-mvar (\lam i => generate-injection-witness blue (arguments i))
        | blue, func f arguments => iw-func idp (\lam i => generate-injection-witness blue (arguments i))
    }

  \data HasColoredRoot (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (term : Term env context s mc) \elim color, term
    | red, func (inl _) _ => red-func-root
    | blue, func (inr _) _ => blue-func-root
    \where {
      \lemma equalize-colors (color color' : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                             (f : env.symbol s)
                             (arguments arguments' : DArray {env.arity f} (\lam (index : Index (env.domain f)) => Term env (context ++ f env.!!domain index) (f env.!!sort index) mc))
                             (hcl1 : HasColoredRoot color (func f arguments))
                             (hcl2 : HasColoredRoot color' (func f arguments'))
        : color = color' \elim color, color', f, hcl1, hcl2
        | red, red, inl s1, red-func-root, red-func-root => idp
        | blue, blue, inr s1, blue-func-root, blue-func-root => idp
        | red, blue, inr b, (), hcl2
        | blue, red, inl a, (), hcl2

      \lemma reorganize (color : Color) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'}
                        {f : env.symbol s}
                        {arguments : DArray {env.arity f} (\lam (index : Index (env.domain f)) => Term env (context ++ f env.!!domain index) (f env.!!sort index) mc)}
                        (hcl : HasColoredRoot color (func f arguments))
        : color-of-root f = color \elim color, f, hcl
        | red, inl s1, red-func-root => idp
        | blue, inr s1, blue-func-root => idp
    }

  \func color-of-root {s : Sort'} (f : env.symbol s) : Color \elim f
    | inl _ => red
    | inr _ => blue

  \func env : FSignature => JointFSignature envL envR

--  \func colored-rules (color : Color) : IndexedSet (RewriteRule env) \elim color
--    | red => Injections.promote-indexed-set-left {Sort'} {envL} {envR} L-rules
--    | blue => Injections.promote-indexed-set-right {Sort'} {envL} {envR} R-rules
}

\open TheoremContext

\func convert-to-injected-term
  {tc : TheoremContext} {allow-variables : \Prop}
  (color : Color) {context : List tc.Sort'} {s : tc.Sort'}
  (term : GenericLinearTerm (TheoremContext.colored-env {tc} color) context s allow-variables)
  : Term (TheoremContext.env {tc}) context s (LinearMetaContext {TheoremContext.colored-env {tc} color} term)
\elim color, term
  | red, l-func f arguments => func (inl f) (\lam i => ModularMetaContext.upgrade-metavariables {TheoremContext.env} (\lam i => LinearMetaContext {envL} (arguments i)) (convert-to-injected-term red (arguments i)))
  | red, l-full-metavar => metavar idp (\lam i => var i idp)
  | red, l-var index p _ => var index p
  | blue, l-func f arguments => func (inr f) (\lam i => ModularMetaContext.upgrade-metavariables {TheoremContext.env} (\lam i => LinearMetaContext {envR} (arguments i)) (convert-to-injected-term blue (arguments i)))
  | blue, l-full-metavar => metavar idp (\lam i => var i idp)
  | blue, l-var index p _ => var index p

\lemma unwrap-injection {tc : TheoremContext} {color : Color} {context : List Sort'} {s : Sort'} {allow-variables : \Prop} (t : GenericLinearTerm (colored-env color) context s allow-variables) :
  inject-monochrome-term color (Linear.convert-to-term {colored-env color} t) = convert-to-injected-term color {context} {s} t \elim color, t
  | red, l-func f arguments => Term.fext {env} (\lam index => rewriteI (unwrap-injection {_} {red} (arguments index)) (swap red (\lam i => LinearMetaContext {envL} (arguments i)) (Linear.convert-to-term {envL} (arguments index))))
  | red, l-full-metavar => idp
  | red, l-var index p _ => idp
  | blue, l-func f arguments => Term.fext {env} (\lam index => rewriteI (unwrap-injection {_} {blue} (arguments index)) (swap blue (\lam i => LinearMetaContext {envR} (arguments i)) (Linear.convert-to-term {envR} (arguments index))))
  | blue, l-full-metavar => idp
  | blue, l-var index p _ => idp
  \where {
    \lemma swap
      {tc : TheoremContext} (color : Color) {context : List Sort'} {s : Sort'} {n : Nat} {i : Fin n} (msigs : \Pi (i : Fin n) -> MetaContext Sort')
      (t : Term (colored-env color) context s (msigs i)) :
      inject-monochrome-term color (ModularMetaContext.upgrade-metavariables {colored-env color} msigs t) =
      ModularMetaContext.upgrade-metavariables {env} msigs (inject-monochrome-term color t) \elim color, t
      | red, var index p => idp
      | red, metavar m arguments =>
        \let extt : (\lam i1 => inject-monochrome-term red (ModularMetaContext.upgrade-metavariables {envL} msigs (arguments i1))) = (\lam i1 => ModularMetaContext.upgrade-metavariables {env} msigs (Injections.inject-term-left envL envR (arguments i1))) => ext (\lam i => swap red msigs (arguments i))
        \in rewrite extt idp
      | red, func f arguments => Term.fext {env} (\lam index => swap red msigs (arguments index))
      | blue, var index p => idp
      | blue, metavar m arguments =>
        \let extt : (\lam i1 => inject-monochrome-term blue (ModularMetaContext.upgrade-metavariables {envR} msigs (arguments i1))) = (\lam i1 => ModularMetaContext.upgrade-metavariables {env} msigs (Injections.inject-term-right envL envR (arguments i1))) => ext (\lam i => swap blue msigs (arguments i))
        \in rewrite extt idp
      | blue, func f arguments => Term.fext {env} (\lam index => swap blue msigs (arguments index))
  }

\func break-down-rule {tc : TheoremContext}
                      {s : Sort'}
                      (idx : JRegistry.rule-J s)
  : \Sigma (new-r : Term (colored-env (color-of-idx idx)) nil s (JRegistry.rule-mc idx))
           (inject-monochrome-term (color-of-idx idx) new-r = JRegistry.rule-r idx) \elim idx
  | inl left-idx => (L-rules.rule-r left-idx, idp)
  | inr right-idx => (R-rules.rule-r right-idx, idp)

\func get-colored-root-for-l
  {tc : TheoremContext}
  {s : Sort'}
  (idx : JRegistry.rule-J s)
  : HasColoredRoot (color-of-idx idx) (JRegistry.rule-l idx) \elim idx
  | inl a => extract-left-l red (L-rules.rule-l a) (L-rules.rule-func-root a)
  | inr b => extract-left-l blue (R-rules.rule-l b) (R-rules.rule-func-root b)
  \where {
    \func extract-left-l {tc : TheoremContext} (color : Color) {s : Sort'} {mc : MetaContext Sort'} (t : Term (colored-env color) nil s mc) (fr : FunctionRoot {colored-env color} t) : HasColoredRoot color (inject-monochrome-term color t) \elim color, t, fr
      | red, func f arguments, T-has-functional-root => red-func-root
      | blue, func f arguments, T-has-functional-root => blue-func-root
  }

\func color-of-idx {tc : TheoremContext}
                   {s : Sort'}
                   (idx : JRegistry.rule-J s) : Color \elim idx
  | inl a => red
  | inr b => blue

\func or-by-color {A : \Type} (c : Color) (a : A) : Or A A \elim c
  | red => inl a
  | blue => inr a

