\import ARS
\import Data.List
\import Data.Or
\import Equiv
\import Function.Meta
\import Logic
\import Paths
\import Paths.Meta
\import Relation
\import Set.Fin

\func isNormalForm {A : ARS} (a : A) : \Prop => \Pi {b : A} -> Not (a ~> b)

\truncated \data HasNormalForm {A : ARS} (a : A) : \Prop
 | nf (b : A) (isNormalForm b) (a ~>_* b)

\func isNormalizing (A : ARS) : \Prop => \Pi (a : A) -> HasNormalForm a

{- | Definition of accessibility (termination) for ARS -}
\data Acc {A : \Set} (R : Rel A) (a : A)
  | acc (\Pi (a' : A) -> a `R` a' -> Acc R a')
  \where {
    \func apply {A : \Set} {R : Rel A} {a : A} (acc : Acc R a) (b : A) (p : a `R` b) : Acc R b \elim acc
      | acc f => f b p
  }

\func Acc-Trans {A : \Set} (R : Rel A) (a : A) : \Type => Acc (transitive-closure R) a

\lemma Acc=>AccTrans {A : \Set} {R : Rel A} (a : A) (a-acc : Acc R a) : Acc-Trans R a =>
  well-founded-induction (Acc-Trans R) (\lam a f => acc (\lam a' aR+a' => transit-to-last f aR+a')) a a-acc
  \where {
    \lemma transit-to-last {A : \Set} {R : Rel A} {a b : A}
                           (f : \Pi (b : A) -> R a b -> Acc-Trans R b)
                           (aR+b : transitive-closure R a b): Acc-Trans R b \elim aR+b
      | tc-direct aRb => f b aRb
      | tc-connect c aRc t => \case (f c aRc) \with {
        | acc g => transit-to-last (\lam b cRb => g b (tc-direct cRb)) t
      }
  }

\func isTerminating (A : ARS) : \Prop => \Pi (a : A) -> Acc (~>) a

\func well-founded-induction {A : \Set} {R : Rel A} (C : A -> \Type)
                             (induction : \Pi (a : A) (\Pi (b : A) (a `R` b) -> C b) -> C a)
                             (a : A) (a-is-accessible : Acc R a) : C a \elim a-is-accessible
  | acc successors => induction a (\lam b a~>b => well-founded-induction C induction b (successors b a~>b))

\func well-founded-induction-transitive {A : \Set} {R : Rel A} (C : A -> \Type)
                             (induction : \Pi (a : A) (\Pi (b : A) (transitive-closure R a b) -> C b) -> C a)
                             (a : A) (a-is-accessible : Acc-Trans R a) : C a \elim a-is-accessible
  | acc successors => induction a (\lam b a~>b => well-founded-induction C induction b (successors b a~>b))


\func one-step-reduction {A : ARS} (a : A) : \Set => \Sigma (b : A) (a ~> b)

\data ReductionTree {A : ARS} (a : A)
  | branch (b : A) (ReductionTree b) (a ~> b)
  | leaf (isNormalForm a)



