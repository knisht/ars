\import ARS
\import Data.List
\import Data.Or
\import Equiv
\import Logic
\import Paths
\import Paths.Meta
\import Set.Fin

\func isNormalForm {A : ARS} (a : A) : \Prop => \Pi (b : A) -> Not (a ~> b)

\func hasNormalForm {A : ARS} (a : A) : \Prop => TruncP (\Sigma (b : A) (isNormalForm b) (a ~>_* b))

\func isNormalizing (A : ARS) : \Prop => \Pi (a : A) -> hasNormalForm a

{- | Definition of accessibility (termination) for ARS -}
\data Acc {A : ARS} (a : A)
  | acc (\Pi (a' : A) -> a ~> a' -> Acc a')

{- | Definition of accessibility with the usage of transitive closure -}
\data AccTrans {A : ARS} (a : A)
  | acc-trans (\Pi (a' : A) -> a ~>_+ a' -> AccTrans a')

\lemma Acc=>AccTrans {A : ARS} (a : A) (a-acc : Acc {A} a) : AccTrans {A} a =>
  well-founded-induction (AccTrans) (\lam a f => acc-trans (\lam a' a~>+a' => \case a~>+a' \with {
    | inP (n, prod) => transit-to-last f n prod
  })) a a-acc
  \where {
    \lemma transit-to-last {A : ARS} {a b : A} (f : \Pi (c : A) -> a A.~> c -> AccTrans c) (n : Nat) (prod : n-product (~>) (suc n) a b) : AccTrans b \elim n, prod
      | 0, step c a~>c (direct c=b) => f b (rewrite (inv c=b) a~>c)
      | suc n, step c a~>c c~>nb => \case (f c a~>c) \with {
        | acc-trans acc-step => transit-to-last (\lam c' c~>c' => acc-step c' (inP (0, step c' c~>c' (direct idp)))) n c~>nb
      }
  }

\func isTerminating (A : ARS) : \Prop => \Pi (a : A) -> Acc a

\func well-founded-induction {A : ARS} (C : A -> \Type)
                             (induction : \Pi (a : A) (\Pi (b : A) (a ~> b) -> C b) -> C a)
                             (a : A) (a-is-accessible : Acc a) : C a \elim a-is-accessible
  | acc successors => induction a (\lam b a~>b => well-founded-induction C induction b (successors b a~>b))

\func well-founded-induction-transitive {A : ARS} (C : A -> \Type)
                                        (induction : \Pi (a : A) (\Pi (b : A) (a ~>_+ b) -> C b) -> C a)
                                        (a : A) (a-is-accessible : AccTrans a) : C a \elim  a-is-accessible
  | acc-trans successors => induction a (\lam b a~>_+b => well-founded-induction-transitive C induction b (successors b a~>_+b))

\func one-step-reduction {A : ARS} (a : A) : \Set => \Sigma (b : A) (a ~> b)

\data ReductionTree {A : ARS} (a : A)
  | branch (b : A) (ReductionTree b) (a ~> b)
  | leaf (isNormalForm a)



