\import Data.Or
\import Function.Meta ($)
\import HLevel
\import Logic
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set

\class AbstractReductionSystem \alias ARS (A : \Set)
  | \infix 4 ~> : A -> A -> \Prop -- | Reduction relation
  | quotient : Equivalence A

{- | An Abstract Reduction System with equivalence relation defaulted to identity one. -}
\class SimpleARS \extends AbstractReductionSystem
  | quotient => identity-equivalence A
  \where {
    \func identity-equivalence (A : \Set) : Equivalence A \cowith
      | ~ a b => a = b
      | ~-reflexive => idp
      | ~-symmetric => inv
      | ~-transitive => *>
  }

{- | Reduction in zero steps -}
\func \infix 4 ~>_0 {A : ARS} : A -> A -> \Prop => =

{- | Redunction in one step -}
\func \infix 4 ~>_1 {A : ARS} : A -> A -> \Prop => A.~>

{- | Composition of abstract relations -}
\func compose {A : \Set} (~>1 : A -> A -> \Prop) (~>2 : A -> A -> \Prop) : A -> A -> \Prop =>
  \lam a b => TruncP (\Sigma (c : A) (a `~>1 c) (c `~>2 b))

{- | n-fold composition of abstract relations -}
\data n-product {A : \Set} (~>1 : A -> A -> \Prop) (n : Nat) (a b : A) \elim n
  | 0 => direct (a = b)
  | suc n => step (c : A) (a `~>1` c) (n-product ~>1 n c b)

{- | Transitive closure of abstract relation -}
\func transitive-closure {A : \Set} (~>1 : A -> A -> \Prop) : A -> A -> \Prop =>
  \lam a b => TruncP (\Sigma (n : Nat) (n-product ~>1 (suc n) a b))

{- | Transitive and reflexive closure of abstract relation -}
\func transitive-reflexive-closure {A : \Set} (~>1 : A -> A -> \Prop) : A -> A -> \Prop =>
  \lam a b => TruncP (\Sigma (n : Nat) (n-product ~>1 n a b))

{- | n-fold composition of relations in ARS -}
\func ~>_=n {A : ARS} (n : Nat) : A -> A -> \Prop => \lam a b => TruncP (n-product (~>) n a b)

{- | Composition of relations with bounded length -}
\func \infix 4 ~>_<=n {A : ARS} (n : Nat) : A -> A -> \Prop =>
  \lam a b => TruncP (\Sigma (m : Nat) (m Nat.<= n) (~>_=n m a b))

{- | Reflexive closure of reduction relation -}
\func \infix 4 ~>_= {A : ARS} : A -> A -> \Prop => \lam a b => TruncP (a ~>_0 b `Or` a ~>_1 b)

{- | Transitive closure of reduction relation in ARS -}
\func \infix 4 ~>_+ {A : ARS} : A -> A -> \Prop => transitive-closure (~>)

{- | Reflexive transitive closure of reduction relations -}
\func \infix 4 ~>_* {A : ARS} : A -> A -> \Prop => transitive-reflexive-closure (~>)

{- | Inverse reduction relation -}
\func \infix 4 <~ {A : ARS} : A -> A -> \Prop => \lam a b => b ~> a

{- | Symmetric closure of inverse reduction relation -}
\func \infix 4 <~> {A : ARS} : A -> A -> \Prop => \lam a b => TruncP (a ~> b `Or` a <~ b)

\func <~>-reverse {A : ARS} {a b : A} (a<~>b : a <~> b) : b <~> a => \case a<~>b \with {
  | inP a1 => \case \elim a1 \with {
    | inl a1 => inP (inr a1)
    | inr b1 => inP (inl b1)
  }
}

{- | Symmetric reflexive transitive closure of inverse reduction relation -}
\func \infix 4 <~>* {A : ARS} : A -> A -> \Prop => transitive-reflexive-closure (<~>)

\lemma <~>*-compose {A : ARS} {a c : A} (b : A) (a<~>*b : a <~>* b) (b<~>*c : b <~>* c) : a <~>* c \elim a<~>*b
  | inP (n, a<~>nb) => <~>*-compose-helper b n a<~>nb b<~>*c \where {
  \lemma <~>*-compose-helper {A : ARS} {a c : A} (b : A) (n : Nat) (a<~>nb : n-product (<~>) n a b) (b<~>*c : b <~>* c) : a <~>* c \elim n, a<~>nb, b<~>*c
    | 0, direct a=b, inP (m, b<~>mc) => inP (m, rewrite a=b b<~>mc)
    | suc n, step c' a<~>c' c'<~>nb, b<~>c => \let c'<~>*c : c' <~>* c => <~>*-compose-helper b n c'<~>nb b<~>c \in \scase \elim c'<~>*c \with {
      | inP (k, prd) => inP (suc k, step c' a<~>c' prd)
    }
}

\lemma <~>*-reverse {A : ARS} {a b : A} (p : a <~>* b) : b <~>* a \elim p
  | inP (n, a<~>nb) => <~>*-reverse-helper n a<~>nb \where {
  \lemma <~>*-reverse-helper {A : ARS} {a b : A} (n : Nat) (a<~>nb : n-product (<~>) n a b) : b <~>* a \elim n, a<~>nb
    | 0, direct p => inP (0, direct (inv p))
    | suc n, step c a~>c c<~>nb => \let | b<~>c => <~>*-reverse-helper n c<~>nb
                                        | c<~>a => <~>-reverse a~>c \in <~>*-compose c b<~>c (inP (1, step a c<~>a (direct idp)))
}

\lemma ~>=><~>* {A : ARS} {a b : A} (red : a ~> b) : a <~>* b => inP (1, step b (inP (inl red)) (direct idp))

{- | Transitive reflexive closure of reduction implies transitive reflexive symmetric closure -}
\lemma ~>*=><~>* {A : ARS} {a b : A} (red : a ~>_* b) : a <~>* b \elim red
  | inP (n, product) => ~>*=><~>*-helper n product
  \where {
    \lemma ~>*=><~>*-helper {A : ARS} {a b : A} (n : Nat) (prf : n-product (~>) n a b) : a <~>* b \elim n, prf
      | 0, direct p => inP (0, direct p)
      | suc n, step c a~>c c~>nb => <~>*-compose c (~>=><~>* a~>c) (~>*=><~>*-helper n c~>nb)
  }

{- | Join for two elements -}
\func join {A : ARS} (a b : A) : \Set => \Sigma (c : A) (a ~>_* c) (b ~>_* c)

{- | Predicate for joinability for two elements -}
\func joinable {A : ARS} (a b : A) : \Prop => TruncP (join a b)




