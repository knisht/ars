\import Data.Or
\import Function.Meta ($)
\import HLevel
\import Logic
\import Paths
\import Paths.Meta
\import Relation
\import Relation.Equivalence
\import Set

\class AbstractReductionSystem \alias ARS (A : \Set)
  | \infix 4 ~> : Pred A -- | Reduction relation
  | quotient : Equivalence A

{- | An Abstract Reduction System with equivalence relation defaulted to identity one. -}
\class SimpleARS \extends AbstractReductionSystem
  | quotient => identity-equivalence A
  \where {
    \func identity-equivalence (A : \Set) : Equivalence A \cowith
      | ~ a b => a = b
      | ~-reflexive => idp
      | ~-symmetric => inv
      | ~-transitive => *>
  }

{- | Reduction in zero steps -}
\func \infix 4 ~>_0 {A : ARS} : Pred A => =

{- | Redunction in one step -}
\func \infix 4 ~>_1 {A : ARS} : Pred A => A.~>

{- | Reflexive closure of reduction relation -}
\func \infix 4 ~>_= {A : ARS} : Pred A => \lam a b => TruncP (a ~>_0 b `Or` a ~>_1 b)

{- | Transitive closure of reduction relation in ARS -}
\func \infix 4 ~>_+ {A : ARS} : Pred A => transitive-closure (~>)

{- | Reflexive transitive closure of reduction relations -}
\func \infix 4 ~>_* {A : ARS} : Pred A => transitive-refl-closure (~>)

{- | Inverse reduction relation -}
\func \infix 4 <~ {A : ARS} : Pred A => \lam a b => b ~> a

{- | Symmetric closure of inverse reduction relation -}
\func \infix 4 <~> {A : ARS} : Pred A => symmetric-closure (~>)

\func <~>-reverse {A : ARS} {a b : A} (a<~>b : a <~> b) : b <~> a \elim a<~>b
  | sc-left a~>b => sc-right a~>b
  | sc-right a<~b => sc-left a<~b

{- | Symmetric reflexive transitive closure of inverse reduction relation -}
\func \infix 4 <~>* {A : ARS} : A -> A -> \Prop => transitive-refl-closure (<~>)

\lemma <~>*-compose {A : ARS} {a c : A} (b : A) (a<~>*b : a <~>* b) (b<~>*c : b <~>* c) : a <~>* c \elim a<~>*b
  | trc-direct a=b => rewrite a=b b<~>*c
  | trc-connect c1 a<~>c1 c1<~>*c => trc-connect c1 a<~>c1 (<~>*-compose b c1<~>*c b<~>*c)

\lemma <~>*-reverse {A : ARS} {a b : A} (a<~>*b : a <~>* b) : b <~>* a \elim a<~>*b
  | trc-direct p => trc-direct (inv p)
  | trc-connect c a<~>c c<~>*b => <~>*-compose c (<~>*-reverse c<~>*b) (trc-connect a (<~>-reverse a<~>c) (trc-direct idp))

\lemma ~>=><~>* {A : ARS} {a b : A} (red : a ~> b) : a <~>* b => trc-connect b (sc-left red) (trc-direct idp)

{- | Transitive reflexive closure of reduction implies transitive reflexive symmetric closure -}
\lemma ~>*=><~>* {A : ARS} {a b : A} (red : a ~>_* b) : a <~>* b \elim red
  | trc-direct a=b => trc-direct a=b
  | trc-connect c r t => trc-connect c (sc-left r) (~>*=><~>* t)

{- | Join for two elements -}
\func join {A : ARS} (a b : A) : \Set => \Sigma (c : A) (a ~>_* c) (b ~>_* c)

{- | Predicate for joinability for two elements -}
\func joinable {A : ARS} (a b : A) : \Prop => TruncP (join a b)




